{"meta":{"title":"Hexo","subtitle":"","description":"","author":"heaven","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"7. Vue的组件系统","slug":"vue07","date":"2020-12-20T13:21:09.000Z","updated":"2020-12-24T15:15:21.592Z","comments":true,"path":"2020/12/20/vue07/","link":"","permalink":"http://example.com/2020/12/20/vue07/","excerpt":"","text":"之前我们讨论的模版都是没有使用组件的，不过我们在开发中，经常会在模版中使用组件的，接下来我们看看在模版中使用组件，Vue内部是如何处理的？假定模版如下所示：在模版中使用了全局组件global-component，局部组件local-component。 1234 &lt;div id=&#x27;app&#x27;&gt; &lt;global-component&gt;&lt;/global-component&gt; &lt;local-component&gt;&lt;/local-component&gt;&lt;/div&gt; 12345678910111213141516171819 Vue.component(&#x27;global-component&#x27;, &#123; data: function () &#123; return &#123; count: 0, msg: &quot;全局组件&quot; &#125; &#125;, template: &#x27;&lt;button v-on:click=&quot;count++&quot;&gt;&#123;&#123;msg&#125;&#125;count:&#123;&#123; count &#125;&#125;&lt;/button&gt;&#x27;&#125;)const LocalComponent = &#123; data: function () &#123; return &#123; count: 0, msg: &quot;局部组件&quot; &#125; &#125;, template: &#x27;&lt;button v-on:click=&quot;count++&quot;&gt;&#123;&#123;msg&#125;&#125;count:&#123;&#123; count &#125;&#125;&lt;/button&gt;&#x27;&#125; 编译组件在模版中里引入了两个组件之后，Vue内部依旧会走模版转render函数的流程，如下所示，下面三张图分别对应： 模版转成AST树 AST树转可执行代码 可执行代码转render函数 其实，不管在模版里面有没有组件，转成render函数的流程都是一样的。如果模版里面有组件的话，也会把组件当作普通的html标签处理。 挂载组件当把模版转成render函数之后，依旧会执行mountComponent函数走挂载组件的流程，接着是创建渲染watcher，并且触发渲染watcher的求值函数updateComponent，updateComponent的逻辑如下： vm._render()创建虚拟dom，并收集依赖 vm._update()基于虚拟dom创建真实dom 区分原生标签/组件对于上面的render函数，会使用_c(&#39;global-component&#39;)来创建组件的虚拟dom，我们看看Vue内部是如何创建组件的虚拟dom？可以看到，在_createElement内部分别处理了原生html标签和自定义组件，其中使用new VNode()创建html标签的虚拟dom，使用createComponent创建组件的虚拟dom。 123456789101112131415161718192021222324252627282930313233343536function _createElement(context,tag,data,children,normalizationType) &#123; if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children); &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children); &#125; var vnode; if (typeof tag === &#x27;string&#x27;) &#123; var Ctor; if (config.isReservedTag(tag)) &#123; // platform built-in elements vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ); &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, &#x27;components&#x27;, tag))) &#123; // component vnode = createComponent(Ctor, data, context, children, tag); &#125; &#125; return vnode&#125;function resolveAsset(options,type,id,warnMissing) &#123; var assets = options[type]; if (hasOwn(assets, id)) &#123; return assets[id] &#125; var camelizedId = camelize(id); if (hasOwn(assets, camelizedId)) &#123; return assets[camelizedId] &#125; var PascalCaseId = capitalize(camelizedId); if (hasOwn(assets, PascalCaseId)) &#123; return assets[PascalCaseId] &#125; var res = assets[id] || assets[camelizedId] || assets[PascalCaseId]; return res&#125; 上面有两个关键的变量Ctor，resolveAsset，Ctor是resolveAsset的返回值。当执行resolveAsset时，传入的参数分别是context.$options, components, global-component，函数的处理逻辑如下： assets存放options[&#39;components&#39;]的值。 如果assets私有属性上有global-component,那就返回 如果assets原型链上有global-component,那就返回 值得注意的是，global-component是全局组件，所以会保存在assets的原型链上,local-component是局部组件，所以会保存在assets的私有属性上，如下图所示：其中KeepAlive Transtion TransitionGroup都是Vue内置的全局组件 创建组件的虚拟dom根据上图可以看到，传入全局组件global-component返回的Ctor是组件的构造函数VueComponent，传入局部组件local-component返回的Ctor是配置对象。接着就把Ctor传入createComponent函数执行，createComponent函数里的处理如下： baseCtor指向Vue 如果是局部组件，就把Ctor这个配置对象传入Vue.extend，并返回组件的构造函数VueComponent。 如果是函数组件，就使用createFunctionalComponent来创建函数组件 执行installComponentHooks函数往data对象上挂载四个钩子函数，分别是init prepatch insert destroy 执行new VNode创建组件的虚拟dom，值得注意的是，创建组件的虚拟dom，会把组件的配置对象当作第七个参数传入并存到组件虚拟dom的componentOptions中，这是创建html的虚拟dom是没有的。 12345678910111213141516171819202122232425262728293031323334353637function createComponent( Ctor, data, context,children,tag)&#123; var baseCtor = context.$options._base; if (isObject(Ctor)) &#123; Ctor = baseCtor.extend(Ctor); &#125; data = data || &#123;&#125;; if (isTrue(Ctor.options.functional)) &#123; return createFunctionalComponent(Ctor, propsData, data, context, children) &#125; installComponentHooks(data); var name = Ctor.options.name || tag; var vnode = new VNode( (&quot;vue-component-&quot; + Ctor.cid + (name ? &quot;-&quot; + name : &#x27;&#x27;)), data, undefined, undefined, undefined, context, &#123; Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children &#125; ); return vnode&#125;function installComponentHooks(data) &#123; var hooks = data.hook || (data.hook = &#123;&#125;); for (var i = 0; i &lt; hooksToMerge.length; i++) &#123; var key = hooksToMerge[i]; var existing = hooks[key]; var toMerge = componentVNodeHooks[key]; if (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) &#123; hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge; &#125; &#125;&#125;var componentVNodeHooks = &#123; init: function init() &#123;&#125;, prepatch: function prepatch() &#123;&#125;, insert: function insert() &#123;&#125;, destroy: function destroy() &#123;&#125;&#125; 最终组件的虚拟dom如下： Vue.extend建立继承关系值得注意的是Vue和VueComponent都是构造函数，其中Vue是根组件的构造函数，VueComponent是组件的构造函数，并且VueComponent继承了Vue，这两者的继承关系就是通过Ctor = Vue.extend(Ctor)实现的，我们看看Vue.extend内部的代码： cachedCtors对象用来缓存组件构造函数VueComponent 执行Sub.prototype = Object.create(Super.prototype)，通过原型链继承，是的Sub.prototype的原型链上有Super.prototype的所有方法。这样组件的实例对象就有Vue.prototype的所有方法了。 123456789101112131415161718Vue.extend = function (extendOptions) &#123; // 此处省略若干代码 var Super = this; var SuperId = Super.cid; var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;); if (cachedCtors[SuperId]) &#123; return cachedCtors[SuperId] &#125; var Sub = function VueComponent(options) &#123; this._init(options); &#125;; Sub.prototype = Object.create(Super.prototype); Sub.prototype.constructor = Sub; cachedCtors[SuperId] = Sub; return Sub&#125;; 创建组件的真实dom以上就是创建全局组件global-component对应的虚拟dom的过程。当然创建局部组件local-component的虚拟dom也是一样的，在创建好虚拟dom之后，就要把虚拟dom传入到vm._update中去处理了。 当首次挂载组件时，必然会走到_update函数里的第一个if判断中，并走到createElm函数来创建真实dom。 123456789101112131415161718192021 Vue.prototype._update = function (vnode, hydrating) &#123; var vm = this; var prevEl = vm.$el; var prevVnode = vm._vnode; vm._vnode = vnode; if (!prevVnode) &#123; vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */); &#125; else &#123; vm.$el = vm.__patch__(prevVnode, vnode); &#125;&#125;function patch(oldVnode, vnode, hydrating, removeOnly) &#123; // 此处省略若干代码 var isRealElement = isDef(oldVnode.nodeType); if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly); &#125; else &#123; createElm( vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm,nodeOps.nextSibling(oldElm) ); &#125;&#125; 接下来看看createElm内部是如何处理的？其逻辑如下： 把根节点交给createComponent处理，处理的结果为false 再把根节点及其子节点交给createChildren函数处理，其实就是遍历根节点的子节点，再次交给createElm函数去处理 根节点的子节点分别是global-component，local-component的虚拟dom，createElm内部的createComponent先处理global-component的虚拟dom 在createComponent函数中，取出组件的init钩子执行来初始化组件。 1234567891011121314151617181920212223242526function createElm( vnode,insertedVnodeQueue,parentElm,refElm) &#123; // 此处省略若干代码 if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123; return &#125; var data = vnode.data; var children = vnode.children; var tag = vnode.tag; createChildren(vnode, children, insertedVnodeQueue);&#125;function createChildren(vnode, children, insertedVnodeQueue) &#123; // 此处省略若干代码 for (var i = 0; i &lt; children.length; ++i) &#123; createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i); &#125;&#125;function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) &#123; var i = vnode.data; if (isDef(i)) &#123; if (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123; i(vnode, false); &#125; &#125;&#125; 接下来，我们看看init函数里是如何初始化组件的，流程如下： 如果组件的虚拟domvnode上有componentInstance keepAlive，并且组件没有被销毁，就判定组件需要被缓存 如果组件不是缓存的组件，那就执行createComponentInstanceForVnode来初始化组件. 2.1 createComponentInstanceForVnode函数里中vnode.componentOptions.Ctor指向组件的构造函数VueComponent 2.2 创建组件实例的过程，也会为组件的数据对象data构建响应式系统，编译组件模版最终生成render函数等，流程和根组件一致。 执行child.$mount来挂载组件，因为VueComponent和Vue的继承关系已经通过Vue.extend建立了，所以child上有$mount方法。 3.1 组件挂载的过程，也会创建渲染watcher lazyWatcher 自定义watcher等，并建立属性和watcher的依赖关系，流程和根组件一致。12345678910111213141516171819202122232425var componentVNodeHooks = &#123; init: function init(vnode, hydrating) &#123; if ( vnode.componentInstance &amp;&amp; !vnode.componentInstance._isDestroyed &amp;&amp; vnode.data.keepAlive ) &#123; var mountedNode = vnode; // work around flow componentVNodeHooks.prepatch(mountedNode, mountedNode); &#125; else &#123; var child = vnode.componentInstance = createComponentInstanceForVnode(vnode,activeInstance); child.$mount(hydrating ? vnode.elm : undefined, hydrating); &#125; &#125;&#125;function createComponentInstanceForVnode( vnode,parent) &#123; // 此处省略若干代码 var options = &#123; _isComponent: true, _parentVnode: vnode, parent: parent &#125;; return new vnode.componentOptions.Ctor(options)&#125; keep-alive组件的实现原理函数式组件的实现原理","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"6. Vue的diff算法","slug":"vue06","date":"2020-12-19T07:03:14.000Z","updated":"2020-12-22T10:30:33.580Z","comments":true,"path":"2020/12/19/vue06/","link":"","permalink":"http://example.com/2020/12/19/vue06/","excerpt":"","text":"上一节我们已经知道在触发更新后，渲染watcher会重新触发求值函数，求值函数内部先要vm._render()生成新值对应的虚拟dom，并把结果交给vm._update处理，接下来我们看看vm._update内部的实现逻辑？ prevVnode存储上次更新时的虚拟dom vm._vnode存储本次更新时的虚拟dom 如果prevVnode没有值，即首次挂载组件，则创建真实dom 如果prevVnode有值，即非首次挂载组件，那就把更新前后的虚拟dom传入vm.__patch__函数中去比较。 显然组件更新时，应该走进else语句。 123456789101112131415161718updateComponent = function () &#123; vm._update(vm._render(), hydrating);&#125;;Vue.prototype._update = function (vnode, hydrating) &#123; // 此处省略若干代码 var vm = this; var prevEl = vm.$el; var prevVnode = vm._vnode; vm._vnode = vnode; if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */); &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode); &#125;&#125;; diff算法的入口函数vm.__patch__是Vue的diff算法入口，我们看看内部是如何处理的？ 判断当前虚拟dom是否是静态节点，如果是静态节点，那就不再进行比较了。 把新老虚拟dom，放到cbs.update数组中各个函数去比较，其中cbs.update数组中各函数的作用是比较虚拟dom的属性 把新老虚拟dom,放到updateChildren函数中去比较，比较出差异，最终更新视图 123456789101112131415161718function patchVnode( oldVnode,vnode) &#123; // 此处省略若干代码 if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) &#123; vnode.componentInstance = oldVnode.componentInstance; return &#125; var data = vnode.data; var oldCh = oldVnode.children; var ch = vnode.children; if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123; for (i = 0; i &lt; cbs.update.length; ++i) &#123; cbs.update[i](oldVnode, vnode); &#125; &#125; if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; if (oldCh !== ch) &#123; updateChildren(elm, oldCh, ch) &#125; &#125;&#125; 比较虚拟dom的data上面说到的cbs.update的结构以及假定本次生成的虚拟dom如下，其中： updateAttrs是用来比对attrs的差异并更新的 updateclass是用来比对class的差异并更新的 updateDomListeners是用来比对绑定事件的差异并更新的 updateDOMProps是用来比对 updateStyle是用来比对样式的差异并更新的 update是用来比对ref的差异并更新的 updateDirectives是用来比对自定义指令的差异并更新的具体详情见:https://cn.vuejs.org/v2/guide/render-function.html归根结底，cbs.update内部的函数其实就是用来找到虚拟dom上的所有属性并更新的，不过上面的比较方式是有弊端的，如果我本次没有更新这些虚拟dom上的属性，Vue内部还是会比较dom上的全部属性(全量比较)。其实当我们没有更新虚拟dom上的属性时，最好的做法就是不比较，只有在更新某些属性的时候，我们再比较这些更新的属性。这样做可以节省无谓的比较次数。当然Vue2.x采用的是全量比较，在Vue3中就给需要更新的属性加上flag，只更新有flag的属性值。这也是Vue3的性能比Vue2好的一个原因。 比较虚拟dom的children如果说上面的cbs.update函数是用来比较虚拟dom属性的差异，那updateChildren就是用来比较虚拟dom的子节点差异的，我们接下来看看updateChildren的内部实现： 定义四个指针，其中oldStartIdx,oldEndIdx指向更新前虚拟dom(老虚拟dom)的首尾索引，newStartIdx,newEndIdx指向更新后(新虚拟dom)的首尾索引。 再定义四个指针，其中oldStartVnode,oldEndVnode指向更新前虚拟dom的首尾节点，newStartVnode,newEndVnode指向更新后(新虚拟dom)的首尾节点。 启动while循环，前两个判断是处理越界情况的并不是重点，重要的是后面四个else if判断，分别是： 判断老dom的头和新dom中的头是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动oldStartIdx,newStartIdx,oldStartVnode,newStartVnode指针。 判断老dom的尾和新dom中的尾是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动oldEndIdx,newEndIdx,oldEndVnode,newEndVnode指针。 判断老dom的头和新dom中的尾是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动oldStartIdx,newEndIdx,oldStartVnode,newEndVnode指针。 判断老dom的尾和新dom中的头是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动oldEndIdx,newStartIdx,oldEndVnode,newStartVnode指针。 如果上面四个判断都没走进去，那就基于本次添加的新dom创建真实dom，并添加到页面上。归根结底上面的四个判断，其实就是老头对新头，老尾对新尾，老头对新尾，老尾对新头的比较，这样比较的好处是尽可能多的复用老的虚拟dom。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; var oldStartIdx = 0; var newStartIdx = 0; var oldEndIdx = oldCh.length - 1; var oldStartVnode = oldCh[0]; var oldEndVnode = oldCh[oldEndIdx]; var newEndIdx = newCh.length - 1; var newStartVnode = newCh[0]; var newEndVnode = newCh[newEndIdx]; var oldKeyToIdx, idxInOld, vnodeToMove, refElm; while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left &#125; else if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx]; &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx); oldStartVnode = oldCh[++oldStartIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx); oldEndVnode = oldCh[--oldEndIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx); canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx); canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm); oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else &#123; if (isUndef(oldKeyToIdx)) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); &#125; idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx); if (isUndef(idxInOld)) &#123; // New element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx); &#125; else &#123; vnodeToMove = oldCh[idxInOld]; if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx); oldCh[idxInOld] = undefined; canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm); &#125; else &#123; // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx); &#125; &#125; newStartVnode = newCh[++newStartIdx]; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm; addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue); &#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx); &#125;&#125; sameVNode上面的updateChildren函数中用到sameVNode来判断是否是同一个虚拟dom，我们看看内部是如何判断的？ key值必须相同，在没有给虚拟dom添加key的情况下，key都是undefined，所以在没有手动添加key的情况下a.key===b.key成立，都是undefined。 tag值必须相同，即虚拟dom对应的标签名必须一样。 对应input标签，type值必须相同。 满足以上条件，才会判定是同一个虚拟dom。才会有走到同一个虚拟dom的patch逻辑中。 12345678910111213141516function sameVnode(a, b) &#123; return ( a.key === b.key &amp;&amp; ( ( a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) ) || ( isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error) ) ) )&#125; v-for的key我们是不建议在列表循环时，用索引来动态绑定key值的，为什么呢，可以看下面的情况: 对比老dom的头和新dom的头，发现key都是0,则判定是同一个虚拟dom，比较出差异，由1-&gt;3 ，更新dom，之后移动指针 重复第一步， 比对老dom的头和新dom的头，发现key都是1,则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针 重复第一步， 比对老dom的头和新dom的头，发现key都是2,则判定是同一个虚拟dom，比较出差异，由3-&gt;1 ，更新dom 根据以上分析，用索引来动态绑定key值会有两次dom操作。 让我们换个方式，用数组内部来动态绑定key： 对比老dom的头和新dom的头，发现key不同，老头key：1,新头key：3，则判定不是同一个虚拟dom。 对比老dom的头和新dom的尾，发现key都是1，则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针 重复第一步， 比对老dom的头和新dom的头，发现key不同，老头key：2,新头key：3，则判定不是同一个虚拟dom。 对比老dom的头和新dom的尾，发现key都是2，则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针 重复第一步， 比对老dom的头和新dom的头，发现key都是3,则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针 根据以上分析，用数组内部来动态绑定key值没有进行dom操作。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"5. Vue的更新策略","slug":"vue05","date":"2020-12-16T17:00:34.000Z","updated":"2020-12-22T05:22:39.078Z","comments":true,"path":"2020/12/17/vue05/","link":"","permalink":"http://example.com/2020/12/17/vue05/","excerpt":"","text":"在上篇文章中，我们已经讲到Vue内部如何进行依赖收集的，咱们先假定模版如下： 1234567&lt;div id=&#x27;app&#x27;&gt; &lt;button @click=&#x27;handleClick&#x27;&gt;按钮&lt;/button&gt; &lt;div v-for=&#x27;item in list&#x27;&gt;&#123;&#123;item&#125;&#125; &lt;/div&gt; &lt;p&gt;&#123;&#123;obj&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;splitMsg&#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122let vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &#x27;我是数据&#x27;, list: [1, 2, 3], obj: &#123; name: &#x27;heaven&#x27; &#125; &#125;, computed: &#123; splitMsg() &#123; return this.msg.split(&#x27;&#x27;) &#125; &#125;, methods:&#123; handleClick()&#123; this.msg = &#x27;我是修改的数据&#x27;; this.lish.push(4) this.obj.name = &#x27;啦啦啦&#x27; &#125; &#125;&#125; 最终模版转成的render函数如上所示，依赖收集的结果如下: list对应的订阅器对象dep中subs=[渲染watcher] obj对应的订阅器对象dep中subs=[渲染watcher] splitMsg是计算属性，所以msg对应的订阅器对象dep中subs=[lazyWatcher,渲染watcher] name对应的订阅器对象dep中subs=[渲染watcher]并且因为childOb.dep.depend的原因，obj和list这俩引用数据的dep订阅器对象的sub也会存储watcher，并且subs=[渲染watcher] 渲染watcher的依赖图最终渲染watcher收集的dep如下 lazyWatcher的依赖图最终lazyWatcher收集的dep如下 视图更新我们知道Vue内部为普通对象/数组构建了响应式系统，想要视图更新共有两种： 给对象属性赋值，触发set钩子 执行数组变异方法，触发mutator函数 12345678let vm = new Vue(&#123; methods:&#123; handleClick()&#123; this.msg = &#x27;我是修改的数据&#x27;; this.lish.push(4) &#125; &#125;&#125;) 修改对象属性上面代码this.msg = &#39;我是修改的数据&#39;会触发下面的set钩子函数，dep.notify()就是触发视图更新的关键代码，视图更新的逻辑如下： 取出subs数组中所有的watcher，并触发watcher的update方法。对于msg来说，subs数组的watcher只有一个渲染watcher update内部是基于watcher的种类做不同的处理，对于渲染watcher直接放到queueWatcher函数中处理，对于lazyWatcher，把dirty置true，表示lazyWatcher并没有求值。queueWatcher函数内部拿到watcher会怎么处理，我们稍等再说，值得注意的是，此时视图还没有更新呢。1234567891011121314151617181920212223242526set: function reactiveSetter(newVal) &#123; if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; val = newVal; childOb = !shallow &amp;&amp; observe(newVal); dep.notify();&#125;Dep.prototype.notify = function notify() &#123; var subs = this.subs.slice(); for (var i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update(); &#125;&#125;;Watcher.prototype.update = function update() &#123; if (this.lazy) &#123; this.dirty = true; &#125; else if (this.sync) &#123; this.run(); &#125; else &#123; queueWatcher(this); &#125;&#125;; 数组变异方法接下来我们执行数组的变异方法this.lish.push(4)来触发mutator函数，大致逻辑是： original.apply执行数组原型的push方法 对push/unshift/splice这三个方法，对添加的到list数组的新数据进行观测 ob.dep.notify()触发视图更新，值得注意的是ob指向this.__ob__，mutator函数内部this指向list数组，在观测list数组时，就已经通过def(value, &#39;__ob__&#39;, this)给list数组添加__ob__属性了。所以this.__ob__指向的就是list数组对应的观测对象，一旦执行ob.dep.notify()，就会取出list数组对应的dep订阅器对象里subs所有的watcher，对于list数组来说，subs数组只有一个渲染watcher，接着再执行watcher.update，最后是把渲染watcher放到queueWatcher函数中处理。123456789101112131415161718192021222324methodsToPatch.forEach(function (method) &#123; var original = arrayProto[method]; def(arrayMethods, method, function mutator() &#123; var args = [], len = arguments.length; while (len--) args[len] = arguments[len]; var result = original.apply(this, args); var ob = this.__ob__; var inserted; switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args; break case &#x27;splice&#x27;: inserted = args.slice(2); break &#125; if (inserted) &#123; ob.observeArray(inserted); &#125; ob.dep.notify(); return result &#125;);&#125;); vm.$set如果要让视图中的obj更新，只要this.obj.name=&#39;啦啦啦&#39;即可，其更新视图的流程和上面分析的this.msg=&#39;我是修改的数据&#39;一致，当然我们修改的obj的name属性，因为在构建响应式系统时，已经给name属性添加get和set，自然可以触发视图更新了，假定我们this.obj.age=28这样是否可以触发视图更新呢，根据Vue的使用经验，其实这样是不会触发视图更新的，如果就是希望this.obj.age=28来触发视图更新，可以使用vm.$set这个API来触发视图更新，如下所示： 123456789let vm = new Vue(&#123; methods:&#123; handleClick()&#123; this.obj.name = &#x27;啦啦啦&#x27; //可以触发视图更新，因为构建响应式系统时已经添加set this.obj.age = 28 //不可以触发视图更新，因为构建响应式系统时，并没有添加set vm.$set(this.obj,&#x27;age&#x27;,28) &#125; &#125;&#125;) 接下来，我们看看vm.$set是如何实现的？ 取出ob，这里ob指向this.obj这个对象的Observe实例 使用defineReactive$$1函数给ob.value的age属性构建响应式系统，这里ob.value指向this.obj ob.dep.notify()触发更新，也是把渲染watcher放到queueWatcher函数中处理，因为childOb.dep.depend的原因，所以这里ob.dep的subs中已经存储了渲染watcher。1234567Vue.prototype.$set = function set(target, key, val) &#123; // 此处省略若干代码 var ob = (target).__ob__; defineReactive$$1(ob.value, key, val); ob.dep.notify(); return val&#125; 异步更新queueWatcher上面我们讨论了三种触发视图更新的方式，不过我们只讨论到把watcher交给queueWatcher中处理，在这之前其实视图并没有更新，也就是说真正视图更新的逻辑是放在queueWatcher去做的，我们看看queueWatcher内部的代码逻辑： has存储不同的watcher.id 定义开关flushing，只要flushing=false那就把watcher放到queue数组中,其实flushSchedulerQueue没执行，flushing就一直为false 定义开关waiting，只要waiting=false那就触发nextTick(flushSchedulerQueue),并立马把waiting置true，防止再次触发nextTick(flushSchedulerQueue)1234567891011121314151617181920var has = &#123;&#125;;var queue = [];var waiting = false;var flushing = false;function queueWatcher(watcher) &#123; // 此处省略若干代码 var id = watcher.id; if (has[id] == null) &#123; has[id] = true; if (!flushing) &#123; queue.push(watcher); &#125; // queue the flush if (!waiting) &#123; waiting = true; nextTick(flushSchedulerQueue); &#125; &#125;&#125; nextTicknextTick的作用是收集本次传入的cb回调函数，并立马触发timerFunc，处理方式如下： callbacks存放传入的cb回调函数，例如上面的nextTick(flushSchedulerQueue)就是把flushSchedulerQueue放入到callbacks中，其实当用户手动触发this.$nextTick(回调函数)，也会将回调函数放入到callbacks中 定义开关pending，只要pending=false那就触发timerFunc(),并立马把pending置true，防止再次触发timerFunc()123456789101112131415161718var callbacks = [];var pending = false;function nextTick(cb, ctx) &#123; var _resolve; callbacks.push(function () &#123; if (cb) &#123; cb.call(ctx); &#125; &#125;); if (!pending) &#123; pending = true; timerFunc(); &#125;&#125;// 手动触发this.$nextTick(回调函数)的逻辑Vue.prototype.$nextTick = function (fn) &#123; return nextTick(fn, this)&#125;; timerFunctimerFunc的作用异步处理flushCallbacks，其中flushCallbacks存放的全是nextTick函数中callbacks收集的cb回调函数，例如flushSchedulerQueue，自定义回调等 12345678910111213141516if (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; // 此处省略若干代码 var p = Promise.resolve(); timerFunc = function () &#123; p.then(flushCallbacks); &#125;; &#125;function flushCallbacks() &#123; pending = false; var copies = callbacks.slice(0); callbacks.length = 0; for (var i = 0; i &lt; copies.length; i++) &#123; copies[i](); &#125;&#125; flushSchedulerQueue终于走到flushSchedulerQueue函数了，这里才是真正视图更新的地方，先看看内部的逻辑： queue数组升序排列 判断before存在，其实只有渲染watcher创建时有配置before，所以对于渲染watcher需要触发before配置，即组件的beforeUpdate钩子函数 取出queue中的每个watcher，并执行watcher.run，在这个情况，queue数组中只有一个渲染watcher，可以看到watcher.run中就执行了get触发求值函数了，因为template中用到了list/obj/splitMsg三个值，所以求值函数会求出list/obj/splitMsg最新的值 123456789101112131415161718192021222324252627282930313233343536function flushSchedulerQueue() &#123; currentFlushTimestamp = getNow(); flushing = true; var watcher, id; queue.sort(function (a, b) &#123; return a.id - b.id; &#125;); for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index]; if (watcher.before) &#123; watcher.before(); &#125; id = watcher.id; has[id] = null; watcher.run(); &#125; callUpdatedHooks(updatedQueue);&#125;// 重置任务状态function resetSchedulerState() &#123; queue.length = 0; has = &#123;&#125;; waiting = flushing = false;&#125;Watcher.prototype.run = function run() &#123; if (this.active) &#123; var value = this.get(); if ( value !== this.value || isObject(value) || this.deep) &#123; var oldValue = this.value; this.value = value; if (this.user) &#123; this.cb.call(this.vm, value, oldValue); &#125; &#125; &#125;&#125;; 以上就是Vue的更新策略，其实就是将所有的watcher都放到queue数组中，并异步执行watcher.run从而让视图更新，当然我们知道触发求值函数一定可以算出新值，即list/obj/splitMsg，那算出新值之后是直接把新值作为内容直接渲染到dom结构中嘛？这样其实并不合理，假如我们没有更新list,那算出的list就和更新之前的list是一样的。这种情况，其实没有必要把没变化的list作为内容直接渲染到dom结构中。即在算出新值时，我们需要和更新前的值比较，新值和老值一样，就不进行dom操作，新值和老值不一样，就更新dom，这就涉及到解析来我们要讲的Vue内部的diff算法了。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"4. Vue首次挂载，发生了肾么事?","slug":"vue04","date":"2020-12-15T13:14:44.000Z","updated":"2020-12-22T13:30:04.006Z","comments":true,"path":"2020/12/15/vue04/","link":"","permalink":"http://example.com/2020/12/15/vue04/","excerpt":"","text":"挂载组件的入口在第三节文章中，我们知道了Vue把template编译成render函数的过程。接下来Vue内部会怎么处理呢？其实接下来Vue就会执行mountComponent函数来挂载组件，如下所示： 触发beforeMount钩子 创建watcher的求值函数updateComponent，其中_render函数是创建虚拟dom,_update函数在首次触发时会基于创建的虚拟dom来生成真实dom 创建渲染watcher,其中最后一个参数true表示该watcher是渲染watcher 触发mounted钩子 12345678910111213141516171819function mountComponent(vm, el,hydrating) &#123; callHook(vm, &#x27;beforeMount&#x27;); var updateComponent = function () &#123; vm._update(vm._render(), hydrating); &#125;; new Watcher(vm, updateComponent, noop, &#123; before: function before() &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &#x27;beforeUpdate&#x27;); &#125; &#125; &#125;, true /* isRenderWatcher */); if (vm.$vnode == null) &#123; vm._isMounted = true; callHook(vm, &#x27;mounted&#x27;); &#125; return vm&#125; 创建渲染watcher接下来咱们看看Vue是如何定义Watcher这个类的，对于Watcher类的参数需要详细说下： expOrFn存储watcher的求值函数 ，对于渲染watcher，expOrFn就是updateComponent ，当然除了渲染watcher之后，其实还会有别的两类watcher，分别是为计算属性创建的lazyWatcher和为watch选项创建的自定义watcher，这两类对应的求值函数都是用户自定义传入的。 cb存储求值函数执行后的回调函数，对于渲染watcher，cb就是noop空函数 options存储watcher创建的配置参数，其中创建渲染watcher传入的配置对象有before钩子函数，创建自定义watcher时传入的配置对象有user属性为true，创建lazyWatcher时传入的配置对象有lazy属性为true。 isRenderWatcher 表示创建的watcher是否是渲染watcher，isRenderWatcher为true表示渲染watcher，并将渲染watcher放到vm._watcher中。 除了这些参数之外，还有别的处理，比如: 每次创建watcher时都会把watcher放到vm._watchers 在创建watcher时，基于lazy值判断是否执行求值函数，其中如果是lazyWatcher就不立马求值，不是lazyWatcher就立马求值。 1234567891011121314151617181920212223242526272829303132var Watcher = function Watcher( vm, expOrFn, cb, options, isRenderWatcher)&#123; this.vm = vm; if (isRenderWatcher) &#123; vm._watcher = this; &#125; vm._watchers.push(this); if (options) &#123; this.deep = !!options.deep; this.user = !!options.user; this.lazy = !!options.lazy; this.sync = !!options.sync; this.before = options.before; &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false; &#125; this.cb = cb; this.id = ++uid$2; // uid for batching this.active = true; this.dirty = this.lazy; // for lazy watchers this.deps = []; this.newDeps = []; this.depIds = new _Set(); this.newDepIds = new _Set(); this.expression = expOrFn.toString(); // parse expression for getter if (typeof expOrFn === &#x27;function&#x27;) &#123; this.getter = expOrFn; &#125; else &#123; this.getter = parsePath(expOrFn); &#125; this.value = this.lazy ? undefined : this.get();&#125; watche.run经过上面的分析，只要不是lazyWatcher就求值，那我们在初始化渲染watcher就会触发求值函数了，接下来我们看看run函数的逻辑：1.触发pushTarget，当前的watcher入targetStack栈，Dep.target指向栈顶的watcher2.触发求值函数getter3.触发popTarget，当前的watcher出targetStack栈，Dep.target指向栈顶的watcher4.触发cleanupDeps函数，depIds/deps存储本次newDepIds/newDeps的值，之后再清空newDepIds/newDeps 12345678910111213141516171819202122232425262728293031323334353637383940Watcher.prototype.get = function get() &#123; pushTarget(this); var value; var vm = this.vm; value = this.getter.call(vm, vm); popTarget(); this.cleanupDeps(); return value&#125;;Dep.target = null;var targetStack = [];function pushTarget(target) &#123; targetStack.push(target); Dep.target = target;&#125;function popTarget() &#123; targetStack.pop(); Dep.target = targetStack[targetStack.length - 1];&#125;Watcher.prototype.cleanupDeps = function cleanupDeps() &#123; var i = this.deps.length; while (i--) &#123; var dep = this.deps[i]; if (!this.newDepIds.has(dep.id)) &#123; dep.removeSub(this); &#125; &#125; var tmp = this.depIds; this.depIds = this.newDepIds; this.newDepIds = tmp; this.newDepIds.clear(); tmp = this.deps; this.deps = this.newDeps; this.newDeps = tmp; this.newDeps.length = 0;&#125;; 渲染watcher求值对于渲染watcher来说，求值函数getter就是updateComponent，而updateComponent函数的逻辑也很清晰: 触发_render函数 触发_update函数可以看到_render函数内部就是执行生成的render函数，而这个render函数就是基于template模版创建的render函数，值的注意的是，执行render函数时，会将内部this指向vm._renderProxy，vm._renderProxy对象经过处理指向组件实例vm。 123456789101112var updateComponent = function () &#123; vm._update(vm._render(), hydrating);&#125;;Vue.prototype._render = function () &#123; // 此处省略若干代码 var vm = this; var ref = vm.$options; var render = ref.render; var vnode = render.call(vm._renderProxy, vm.$createElement); return vnode&#125; 假定template模版如下，则生成的render函数如下图所示： 1234&lt;div id=app class=&quot;heaven&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;button @click=&#x27;handleClick&#x27;&gt;按钮&lt;/button&gt;&lt;/div&gt; 渲染watcher收集依赖当执行render函数时，有个with语句，执行with内部逻辑时，总是从this中取值，即取msg的值时，等价取vm.msg，因为我们之前做了数据代理的原因， 所以取vm.msg时，等价取vm._data.msg ,此时就触发了msg的get钩子函数。这时候get函数内部就会构建属性msg和watcher的依赖关系，我们看看get函数内部是怎么做的？ 判断Dep.target是否存在，之所以要有这个判断，是因为我们只要在渲染watcher/lazyWatcher/自定义watcher的求值函数触发时，才触发dep.depend函数 判断childOb是否存在，存在就执行childOb.dep.depend，childOb是什么？为什么要执行childOb.dep.depend，我们会在Vue的更新策略再说。 1234567891011121314151617181920212223242526function defineReactive$$1( obj, key, val, customSetter,shallow) &#123; var dep = new Dep(key); var childOb = !shallow &amp;&amp; observe(val); Object.defineProperty(obj, key, &#123; get: function reactiveGetter() &#123; if (Dep.target) &#123; dep.depend(); if (childOb) &#123; childOb.dep.depend(); if (Array.isArray(value)) &#123; dependArray(value); &#125; &#125; &#125; return value &#125;, set: function reactiveSetter(newVal) &#123; if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; val = newVal; childOb = !shallow &amp;&amp; observe(newVal); dep.notify(); &#125; &#125;);&#125; 经过上面的分析，我们知道Dep.target存在的话就要执行dep.depend方法，我们看看这个函数内部做了什么？ 判断Dep.target是否存在，值得注意的是，此时Dep.target指向渲染watcher，并且执行渲染watcher的addDep方法 watcher的addDep方法内部用到两个if判断，第一个判断是为了防止在本次求值过程中重复把watcher放到dep对象中，第二个if判断是为了防止在不同的求值时刻（用户更新视图会再次求值，再次求值会再次走到addDep的逻辑中）重复把watcher放到dep对象中。 最终会触发dep.addSub方法，把watcher放到depd对象的subs中。至此属性msg的dep对象中的subs数组收集到了渲染watcher，这就是msg属性的依赖收集过程。 123456789101112131415161718192021222324var Dep = function Dep(key) &#123; this.id = uid++; this.subs = [];&#125;;Dep.prototype.addSub = function addSub(sub) &#123; this.subs.push(sub);&#125;;Dep.prototype.depend = function depend() &#123; if (Dep.target) &#123; Dep.target.addDep(this); &#125;&#125;;Watcher.prototype.addDep = function addDep(dep) &#123; var id = dep.id; if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id); this.newDeps.push(dep); if (!this.depIds.has(id)) &#123; dep.addSub(this); &#125; &#125;&#125;; childOb.dep.depend的作用上面留了一个疑问，在get钩子中为什么要判断childObj?要明确这一点，我们先要知道childObj是什么？根据上面代码可知，childObj是observe函数的返回值，先看看observe函数是什么？其实observe函数就是第一节说到的Vue响应式系统的入口，observe函数返回的是个观测后的对象。 123456789101112131415161718192021222324252627282930function observe(value, asRootData) &#123; var ob; if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__; &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value); &#125; return ob&#125;var Observer = function Observer(value) &#123; this.value = value; this.dep = new Dep(value); this.vmCount = 0; def(value, &#x27;__ob__&#x27;, this); if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods); &#125; this.observeArray(value); &#125; else &#123; this.walk(value); &#125;&#125;; 如果观测的数据是value=[1,2,3,4],那么observe函数返回的结果如下： 所以childObj就是类似上面的数据结构，之所以在get的钩子函数中还要在判断childObj是否存在，其实就是为了当childObj存在时，再把当前的watcher添加到childObj.dep.subs数组中，为什么要把watcher放到subs数组中？咱们在下一节Vue的更新策略中会讲到。 上面讲到的是渲染watcher的创建和收集依赖的过程，接下来再说一下lazyWatcher的创建和收集依赖的过程,假定模版如下所示 123&lt;div id=app class=&quot;heaven&quot;&gt; &#123;&#123;splitMsg&#125;&#125;&lt;/div&gt; 1234567891011let vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &#x27;我是数据&#x27;, &#125;, computed: &#123; splitMsg() &#123; return this.msg.split(&#x27;&#x27;) &#125; &#125;&#125; 创建lazyWatcher其实对于computed选项里的每个计算属性，Vue内部都会为其生成一个lazyWatcher，我们看下Vue内部的处理，大致逻辑如下： 遍历computed选项，为每个计算属性都创建一个watcher，这里传递的求值函数是用户自己配置的属性的get 触发defineComputed函数，给计算属性添加get/set，即vm.filterMsg就会触发get钩子函数值得注意的是，computedWatcherOptions的lazy值为true，用来标记是一个lazyWatcher，而且lazyWatcher上有个dirty表示lazyWatcher是否已经求值了，lazyWatcher初始时是不会求值的，所以dirty为true。 12345678910111213141516171819202122232425262728293031323334353637383940414243var computedWatcherOptions = &#123; lazy: true &#125;;function initComputed(vm, computed) &#123; var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR var isSSR = isServerRendering(); for (var key in computed) &#123; var userDef = computed[key]; var getter = typeof userDef === &#x27;function&#x27; ? userDef : userDef.get; if (!isSSR) &#123; // create internal watcher for the computed property. watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions ); &#125; defineComputed(vm, key, userDef); &#125;&#125;function defineComputed(target, key,userDef) &#123; // 此处省略若干代码 sharedPropertyDefinition.get = createComputedGetter(key) sharedPropertyDefinition.set = noop; Object.defineProperty(target, key, sharedPropertyDefinition);&#125;function createComputedGetter(key) &#123; return function computedGetter() &#123; var watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]; if (watcher) &#123; if (watcher.dirty) &#123; watcher.evaluate(); &#125; if (Dep.target) &#123; watcher.depend(); &#125; return watcher.value &#125; &#125;&#125; lazyWatcher收集依赖当然，在创建watcher时，一旦lazy是true，就不会在立马执行求值函数，那么lazyWatcher是在什么时刻求值的呢？其实也是在render函数中执行时才求值的，上面的模版最终编译的render函数如下，当执行this.filterMsg时，就会触发get函数，而get钩子函数的逻辑: 从_computedWatchers中取出lazyWatcher 判断dirty，如果值为true，就表示此刻lazyWatcher还没有求值，就触发evaluate函数 在evaluate函数函数里面,就会触发求值函数了，之后会把dirty置false，表示lazyWatcher已经求值完成，在lazyWatcher求值时，需要注意下面几点： 因为lazyWatcher是在render函数执行时遇到计算属性的基础上求值的，所以在lazyWatcher求值之前，targetStack=[渲染watcher],在lazyWatcher求值之后，targetStack=[渲染watcher,lazyWatcher] 此刻Dep.target指向lazyWatcher lazyWatcher的求值函数是用户自定义的，在这里应该是 splitMsg() &#123; return this.msg.split(&#39;&#39;) &#125;,可想而知，一旦执行该函数，就会执行this.msg，这时就会触发msg的get钩子函数进行依赖收集，把lazyWatcher添加到msg的dep(属性订阅器)的subs中（步骤和收集渲染watcher一致）。 执行popTarget函数，lazyWatcher从targetStack弹出，此刻Dep.target指向渲染watcher 求值结束后，判断Dep.target是否存在，此刻是存在的，再把Dep.target即渲染watcher添加到msg的dep(属性订阅器)的subs中,最终msg的dep(属性订阅器)的subs=[lazyWatcher,渲染watcher] 至此属性msg的dep对象中的subs数组收集到了lazyWatcher和渲染watcher，这就是某个计算属性的依赖收集过程。 1234567891011121314Watcher.prototype.evaluate = function evaluate() &#123; this.value = this.get(); this.dirty = false;&#125;;Watcher.prototype.get = function get() &#123; pushTarget(this); var value; var vm = this.vm; value = this.getter.call(vm, vm); popTarget(); this.cleanupDeps(); return value&#125;; 创建虚拟dom根据上面的分析，我们知道在触发vm._render函数时，会收集依赖，其实vm._render函数还有另外一个作用：创建虚拟dom，这就要说到生成的render函数里用到的辅助函数_c了，它是用来创建虚拟的元素节点，我们看看函数内部的逻辑： 执行createElement函数，作用是参数重载，用来确保data存节点的属性，children存子节点 执行_createElement函数，该函数作用有三： 2.1 处理传入的children子节点， 2.2 处理原生html标签如div,p，并使用 new VNode()来创建标签对应的虚拟dom 2.3 处理自定义组件，并使用createComponent来创建组件对应的虚拟dom(后面讲Vue组件系统时会讲到) 123456789101112131415161718192021222324252627282930313233343536vm._c = function (a, b, c, d) &#123; return createElement(vm, a, b, c, d, false); &#125;;// 参数重载 保证data存属性 children存子节点的顺序function createElement(context,tag,data,children,normalizationType,alwaysNormalize ) &#123; if (Array.isArray(data) || isPrimitive(data)) &#123; normalizationType = children; children = data; data = undefined; &#125; if (isTrue(alwaysNormalize)) &#123; normalizationType = ALWAYS_NORMALIZE; &#125; return _createElement(context, tag, data, children, normalizationType)&#125;function _createElement(context,tag,data,children,normalizationType) &#123; if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children); &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children); &#125; var vnode; if (typeof tag === &#x27;string&#x27;) &#123; var Ctor; if (config.isReservedTag(tag)) &#123; // platform built-in elements vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ); &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, &#x27;components&#x27;, tag))) &#123; // component vnode = createComponent(Ctor, data, context, children, tag); &#125; &#125; return vnode&#125; 当Vue内部创建好虚拟dom后，就会把虚拟dom交给vm._update处理，我们看看这个函数内部的逻辑： prevEl存储组件的挂载点(真实dom) prevVnode存储上次生成的虚拟dom，对于首次触发_update函数来说，prevVnode为undefined vm._vnode存储本次生成的虚拟dom 显然首次触发_update函数时，会走进if，从而触发vm.__patch__函数并传入vm.$el和vnode 12345678910111213Vue.prototype._update = function (vnode, hydrating) &#123; var vm = this; var prevEl = vm.$el; var prevVnode = vm._vnode; vm._vnode = vnode; if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */); &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode); &#125;&#125;; 创建真实domvm.patch接下来，我们看看vm.__patch__函数的实现： 判断oldVnode是不是真实的dom节点，如果是真实节点，那就说明是因为首次挂载组件触发patch函数的，那就使用createElm来创建真实dom 如果不是元素节点，那就说明是因为组件更新触发patch函数的，那就使用patchVnode来比对更新前后的虚拟dom。对于首次触发patch函数时，因为oldVnode是真实节点，所以会走进else语句，最终触发createElm函数。1234567891011121314151617181920function patch(oldVnode, vnode)&#123; var isRealElement = isDef(oldVnode.nodeType); if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; // patch existing root node patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly); &#125; else &#123; if (isRealElement) &#123; oldVnode = emptyNodeAt(oldVnode); var oldElm = oldVnode.elm; var parentElm = nodeOps.parentNode(oldElm); // create new node createElm( vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ); &#125;&#125; createElmVue内部是使用createElm函数来根据虚拟dom创建真实dom的，我们看看内部的处理: 如果虚拟dom里有组件，那就创建组件(这里没有组件，后面在讲Vue组件系统会讲到) 把vnode及其子节点children放到createChildren函数中处理，生成子节点对应的真实dom。 最终把生成的子节点插入到父节点parentElm中 1234567891011121314151617181920212223242526272829function createElm( vnode,insertedVnodeQueue,parentElm,refElm )&#123; if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123; return &#125; var data = vnode.data; var children = vnode.children; var tag = vnode.tag; if (isDef(tag)) &#123; vnode.elm = nodeOps.createElement(tag, vnode); createChildren(vnode, children ); insert(parentElm, vnode.elm, refElm); &#125;else if (isTrue(vnode.isComment)) &#123; vnode.elm = nodeOps.createComment(vnode.text); insert(parentElm, vnode.elm, refElm); &#125; else &#123; vnode.elm = nodeOps.createTextNode(vnode.text); insert(parentElm, vnode.elm, refElm); &#125;&#125;function createChildren(vnode, children, insertedVnodeQueue) &#123; if (Array.isArray(children)) &#123; checkDuplicateKeys(children); for (var i = 0; i &lt; children.length; ++i) &#123; createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i); &#125; &#125;&#125; 以上，就是Vue内部从挂载组件到生成真实dom的全部过程。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"实现express的洋葱模型","slug":"express01","date":"2020-12-11T09:39:55.000Z","updated":"2020-12-17T05:09:26.993Z","comments":true,"path":"2020/12/11/express01/","link":"","permalink":"http://example.com/2020/12/11/express01/","excerpt":"","text":"Layer.jsexpress.js123456789let express = (function () &#123; var instance = null return function () &#123; if (!instance) &#123; instance = new CreateApplication() &#125; return instance &#125;&#125;)() CreateApplication.js1234567891011121314151617181920212223const http = require(&#x27;http&#x27;)class CreateApplication &#123; constructor() &#123; this._router = new Router() &#125; get(path, ...handlers) &#123; this._router.get(path, handlers) &#125; post(path, ...handlers) &#123; this._router.post(path, handlers) &#125; use(path, ...handlers) &#123; this._router.use(path, handlers) &#125; listen(...args) &#123; function done(req, res) &#123; res.end(`Cannot $&#123;req.method&#125; $&#123;req.url&#125;`) &#125; http.createServer((req, res) =&gt; &#123; this._router.handle(req, res, done) &#125;).listen(...args) &#125;&#125; Router.js12345678910111213141516171819202122232425262728293031323334353637const url = require(&#x27;url&#x27;)class Router &#123; constructor() &#123; this.stacks = [] &#125; get(path, handlers) &#123; const layer = new Layer(path, &#x27;get&#x27;, handlers) this.stacks.push(layer) &#125; post(path, handlers) &#123; const layer = new Layer(path, &#x27;post&#x27;, handlers) this.stacks.push(layer) &#125; use(path, handlers) &#123; const layer = new Layer(path, &#x27;use&#x27;, handlers) this.stacks.push(layer) &#125; handle(req, res, done) &#123; const &#123; pathname &#125; = url.parse(req.url) let idx = 0 let next = () =&gt; &#123; if (idx &gt;= this.stacks.length) return done(req, res) let layer = this.stacks[idx++] const &#123; method &#125; = layer if ( pathname === layer.path &amp;&amp; (method === req.method.toLowerCase() || method === &#x27;use&#x27;) ) &#123; layer.dispatch(req, res, next)//触发内层 &#125; else &#123; next() //触发外层 &#125; &#125; next() &#125;&#125; Layer.js1234567891011121314151617class Layer &#123; constructor(path, method, handlers) &#123; this.stacks = [] this.method = method this.path = path this.stacks.push(...handlers) &#125; dispatch(req, res, out) &#123; let idx = 0; let next = () =&gt; &#123; if (idx &gt;= this.stacks.length) return out() let handler = this.stacks[idx++] handler(req, res, next) &#125; next() &#125;&#125;","categories":[{"name":"Node","slug":"Node","permalink":"http://example.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"}]},{"title":"3. Vue生成ast树后，发生了肾么事？","slug":"vue03","date":"2020-12-06T06:59:10.000Z","updated":"2020-12-21T11:28:41.748Z","comments":true,"path":"2020/12/06/vue03/","link":"","permalink":"http://example.com/2020/12/06/vue03/","excerpt":"","text":"Vue生成了ast语法树之后，还对这个树结构进行了静态标记，之所以给ast树打上是否是静态的标记，是因为在后面diff算法的时候，直接跳过静态的节点，可以节省diff的开销。下面我们看看是怎么给节点打静态标记的吧 1234567891011121314var ast = parse(template.trim(), options);if (options.optimize !== false) &#123; optimize(ast, options);&#125;function optimize(root, options) &#123; if (!root) &#123; return &#125; isStaticKey = genStaticKeysCached(options.staticKeys || &#x27;&#x27;); isPlatformReservedTag = options.isReservedTag || no; // 给节点打上是否是静态节点的标记 markStatic$1(root); // 给节点打上是否是静态根节点的标记 markStaticRoots(root, false);&#125; 上面的代码中，markStatic$1函数是给节点打上是否是静态节点的标记，markStaticRoots函数是给节点打上是否是静态根节点的标记，我们先看看markStatic$1函数内部的逻辑，其实核心isStatic函数，这个函数是判断节点是否是静态节点。判断的逻辑大致如下 如果是插值文本 那就不是静态节点 如果是普通文本 那就是静态节点 有跳过编译的指令pre 那就是静态节点 没有属性绑定&amp;有if for&amp;不是Vue内置标签等 那就是静态节点 在经过上面判断出这个节点是否是静态节点，如果是那就给这个节点在加上static:true标记，当然这还没结束，接着还会在遍历这个节点的子节点们，判断子节点是否是静态节点，一旦某个子节点不是静态节点，那就给这个节点打上static:false标记 1234567891011121314151617181920212223242526272829 function markStatic$1(node) &#123; node.static = isStatic(node); if (node.type === 1) &#123; for (var i = 0, l = node.children.length; i &lt; l; i++) &#123; var child = node.children[i]; markStatic$1(child); if (!child.static) &#123; node.static = false; &#125; &#125; &#125;&#125;function isStatic(node) &#123; if (node.type === 2) &#123; // expression return false &#125; if (node.type === 3) &#123; // text return true &#125; return !!(node.pre || ( !node.hasBindings &amp;&amp; // no dynamic bindings !node.if &amp;&amp; !node.for &amp;&amp; // not v-if or v-for or v-else !isBuiltInTag(node.tag) &amp;&amp; // not a built-in isPlatformReservedTag(node.tag) &amp;&amp; // not a component !isDirectChildOfTemplateFor(node) &amp;&amp; Object.keys(node).every(isStaticKey) ))&#125; 下面再看看markStaticRoots函数的逻辑,判断节点是否是静态根节点的逻辑大致如下 如果是该节点是静态节点，并且这个节点的子节点长度大于1，那这个节点就是静态根节点 不满足上述条件，则这个节点就不是静态根节点在经过上面判断出这个节点是否是静态根节点，如果是那就给这个节点在加上staticRoot:true标记，当然这还没结束，接着还会在遍历这个节点的子节点们，判断子节点是否是静态根节点，最后给子节点们打上staticRoot标记 123456789101112131415161718192021function markStaticRoots(node, isInFor) &#123; if (node.type === 1) &#123; // For a node to qualify as a static root, it should have children that // are not just static text. Otherwise the cost of hoisting out will // outweigh the benefits and it&#x27;s better off to just always render it fresh. if (node.static &amp;&amp; node.children.length &amp;&amp; !( node.children.length === 1 &amp;&amp; node.children[0].type === 3 )) &#123; node.staticRoot = true; return &#125; else &#123; node.staticRoot = false; &#125; if (node.children) &#123; for (var i = 0, l = node.children.length; i &lt; l; i++) &#123; markStaticRoots(node.children[i], isInFor || !!node.for); &#125; &#125; &#125;&#125; 最终Vue就处理好了ast树，接着会基于ast树生成代码，,这里使用到了generate函数，generate这个函数内部的逻辑大致是: genElement函数内部创建节点对应的代码存到data中 genChildren函数内部创建节点的子节点对应的代码存到children中 最终基于data和children拼接成最终的code，其中如果节点有if for once等指令，会转换成特殊的代码 如果是静态根节点，就生成代码并存到staticRenderFns中值得注意的是，我们在下面代码中可以得到结论：v-for的优先级比v-if的优先级因为generate函数内部是先处理el.for，再处理el.if的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var ast = parse(template.trim(), options);if (options.optimize !== false) &#123; optimize(ast, options);&#125;var code = generate(ast, options);function generate(ast, options ) &#123; var state = new CodegenState(options); var code = ast ? genElement(ast, state) : &#x27;_c(&quot;div&quot;)&#x27;; return &#123; render: (&quot;with(this)&#123;return &quot; + code + &quot;&#125;&quot;), staticRenderFns: state.staticRenderFns &#125;&#125;function genElement(el, state) &#123; if (el.parent) &#123; el.pre = el.pre || el.parent.pre; &#125; if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123; return genStatic(el, state) &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123; return genOnce(el, state) &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123; return genFor(el, state) &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123; return genIf(el, state) &#125; else if (el.tag === &#x27;template&#x27; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123; return genChildren(el, state) || &#x27;void 0&#x27; &#125; else if (el.tag === &#x27;slot&#x27;) &#123; return genSlot(el, state) &#125; else &#123; // component or element var code; if (el.component) &#123; code = genComponent(el.component, el, state); &#125; else &#123; var data; if (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) &#123; data = genData$2(el, state); &#125; var children = el.inlineTemplate ? null : genChildren(el, state, true); code = &quot;_c(&#x27;&quot; + (el.tag) + &quot;&#x27;&quot; + (data ? (&quot;,&quot; + data) : &#x27;&#x27;) + (children ? (&quot;,&quot; + children) : &#x27;&#x27;) + &quot;)&quot;; &#125; // module transforms for (var i = 0; i &lt; state.transforms.length; i++) &#123; code = state.transforms[i](el, code); &#125; return code &#125;&#125; 最终输出的code为下图，其中render为可执行的字符串，staticRenderFns为静态节点字符串 生成code之后，接下来的处理是在compileToFunctions函数中,大致逻辑是： 定义cache缓存对象 compile函数返回的是code对象,即compiled-&gt;code对象 基于render/staticRenderFns创建函数 返回res对象，并将key-&gt;res存到缓存对象中,这个是vue的优化策略，当第二次再次编译同样的模版时，会直接取出render/staticRenderFns，不会重复编译出render/staticRenderFns，这样在多次使用组件时，就可以极大的节省浏览器开销 123456789101112131415161718192021 function compileToFunctions( template, options, vm) &#123; var cache = Object.create(null); // 此时省略很多代码 if (cache[key]) &#123; return cache[key] &#125; // 编译模版 var compiled = compile(template, options); var res = &#123;&#125;; var fnGenErrors = []; res.render = createFunction(compiled.render, fnGenErrors); res.staticRenderFns = compiled.staticRenderFns.map(function (code) &#123; return createFunction(code, fnGenErrors) &#125;); return (cache[key] = res)&#125;function createFunction(code, errors) &#123; return new Function(code)&#125; 至此Vue编译模版终于结束了，过程是从html字符串-&gt;ast语法树-&gt;code对象-&gt;render函数。其实还有一个很重要的问题，就是Vue在模版编译的过程中，函数嵌套很严重，Vue内部为什么嵌套这么多层呢？其实","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"js小技巧","slug":"js骚操作","date":"2020-12-03T10:31:01.000Z","updated":"2020-12-17T05:14:55.895Z","comments":true,"path":"2020/12/03/js骚操作/","link":"","permalink":"http://example.com/2020/12/03/js%E9%AA%9A%E6%93%8D%E4%BD%9C/","excerpt":"","text":"金额格式化12345678let num = 1000000// 方法1:let result = num.toLocaleString() // 1,000,000// 方法2:const reg = /(?=(\\B)(\\d&#123;3&#125;)+$)/glet result = num.toString().replace(reg,&#x27;,&#x27;) // 1,000,000 交换值123456789let a = 1,b = 2// 方法1:b = [a,a=b][0] //a=1 b=2// 方法2a = a^bb = a^ba = a^b //a=1 b=2 1","categories":[{"name":"JS","slug":"JS","permalink":"http://example.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"2. Vue如何编译模版?","slug":"vue02","date":"2020-12-01T13:26:48.000Z","updated":"2020-12-19T04:23:21.613Z","comments":true,"path":"2020/12/01/vue02/","link":"","permalink":"http://example.com/2020/12/01/vue02/","excerpt":"","text":"Vue上手非常简单，因为我们可以直接编写html作为组件的模版，对比学习React还需要接触jsx语法，Vue对新手可以说是非常友好了，接下来我们看看vue是如何处理template模版的？ Vue编译器入口1234567891011121314151617var createCompiler = createCompilerCreator( function baseCompile(template, options) &#123; // template -&gt; ast 对template的第一层抽象 var ast = parse(template.trim(), options); // 优化ast树 标注静态节点 if (options.optimize !== false) &#123; optimize(ast, options); &#125; // ast -&gt; 可执行code 对template的第二层抽象 var code = generate(ast, options); return &#123; ast: ast, render: code.render, staticRenderFns: code.staticRenderFns &#125; &#125;); 可以看到首先是template模版放到parse函数中处理，得到ast对象(abstract syntax tree)，其实ast对象是对template的第一层抽象，template模版本质上是一个html字符串，现在用ast对象来描述template模版，接下来看看html字符串如何被转换成ast对象的？假定template模版如下： 12345678910111213141516171819202122232425// html模版let template = ` &lt;div id=app v-if=&#x27;msg&#x27; v-for=&#x27;item in 3&#x27; v-once:click=&#x27;handleClick&#x27;&gt; &lt;div class=&#x27;text&#x27; title=&#x27;heaven&#x27;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;`function parse(template,options) &#123; // ...此处省略部分代码 var stack = []; var root; var currentParent; parseHTML(template, &#123; // ...此处省略部分代码 // 解析到开始标签的钩子函数 start: function start()&#123;&#125;, // 解析到结束标签的钩子函数 end: function end() &#123;&#125;, // 解析到文本的钩子函数 chars: function()&#123; &#125; &#125;) return root&#125; parseHTML 编译模版可以看到真正处理template的是parseHTML这个函数，我们看看这个函数内部的逻辑是什么？其实大致有4步 定义token，这些token用来解析开始标签 标签属性 结束标签等 处理开始标签，并把处理的结果交给handleStartTag处理 处理结束标签，并把处理的结果交给parseEndTag处理 处理文本，并把文本交给chars钩子函数处理123456789101112131415161718192021222324252627282930313233343536373839404142434445// 解析属性的token id=&#x27;app&#x27;var attribute = /^\\s*([^\\s&quot;&#x27;&lt;&gt;\\/=]+)(?:\\s*(=)\\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\\s&quot;&#x27;=&lt;&gt;`]+)))?/;var ncname = &quot;[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z&quot; + (unicodeRegExp.source) + &quot;]*&quot;;var qnameCapture = &quot;((?:&quot; + ncname + &quot;\\\\:)?&quot; + ncname + &quot;)&quot;;// 解析开始标签的token &lt;div var startTagOpen = new RegExp((&quot;^&lt;&quot; + qnameCapture));// 解析开始标签结束的token /&gt; &gt;var startTagClose = /^\\s*(\\/?)&gt;/;// 解析结束标签的token &lt;/div&gt;var endTag = new RegExp((&quot;^&lt;\\\\/&quot; + qnameCapture + &quot;[^&gt;]*&gt;&quot;));function parseHTML(html, options) &#123; var stack = []; var index = 0; while (html) &#123; var textEnd = html.indexOf(&#x27;&lt;&#x27;); // ...此处省略部分代码 // 处理开始标签 var startTagMatch = parseStartTag(); if (startTagMatch) &#123; handleStartTag(startTagMatch); continue &#125; // 处理结束标签 var endTagMatch = html.match(endTag); if (endTagMatch) &#123; var curIndex = index; advance(endTagMatch[0].length); parseEndTag(endTagMatch[1], curIndex, index); continue &#125; // 处理文本 包括静态文本和插值 var text if (textEnd &gt;= 0) &#123; // ...此处省略部分代码 text = html.substring(0, textEnd); &#125; if (text) advance(text.length); if (options.chars &amp;&amp; text) &#123; options.chars(text, index - text.length, index); &#125; &#125;&#125; 解析开始标签接下来，我们看看parseStartTag函数是如何处理开始标签的？12345678910111213141516171819202122232425262728293031// 控制全局的index/html向前移动nfunction advance(n) &#123; index += n; html = html.substring(n);&#125;function parseStartTag() &#123; // 解析到开始标签 var start = html.match(startTagOpen); if (start) &#123; var match = &#123; tagName: start[1], attrs: [], start: index &#125;; advance(start[0].length); var end, attr; while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(dynamicArgAttribute) || html.match(attribute))) &#123; attr.start = index; advance(attr[0].length); attr.end = index; match.attrs.push(attr); &#125; if (end) &#123; match.unarySlash = end[1]; advance(end[0].length); match.end = index; return match &#125; &#125;&#125; 最终开始标签&lt;div id=&#39;app&#39;&gt;被解析成下面的结构，其中attrs里面存放开始标签的属性集合，start是开始标签的起始位置，end是开始标签的结束位置，tagName是开始标签的标签类型，unarySlash为空代表标签为双标签，这样开始标签所有信息都被这个对象完美描述了，下面是match的结构图 接下来，开始标签的处理结果match还需要交给handleStartTag处理，我们看看handleStartTag内部的逻辑，其实也是很清晰的 处理attrs属性，最终把标签的属性改成key:value的形式，并且标记attrs内部的属性开始和结束位置 将开始标签的信息放到stack栈中 触发start钩子函数值的注意的是value值为args[3] || args[4] || args[5],这是怎么回事呢？这是因为对于属性值的三种形式&lt;div id=&quot;app&quot;&gt; app可以是单引号，双引号，不加引号，分别对应args[3] || args[4] || args[5]1234567891011121314151617181920212223242526272829function handleStartTag(match) &#123; var tagName = match.tagName; var unarySlash = match.unarySlash; var unary = isUnaryTag$$1(tagName) || !!unarySlash; var l = match.attrs.length; var attrs = new Array(l); for (var i = 0; i &lt; l; i++) &#123; var args = match.attrs[i]; var value = args[3] || args[4] || args[5] || &#x27;&#x27;; attrs[i] = &#123; name: args[1], value &#125; if (options.outputSourceRange) &#123; attrs[i].start = args.start + args[0].match(/^\\s*/).length; attrs[i].end = args.end; &#125; &#125; // 处理双标签 if (!unary) &#123; stack.push(&#123; tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end &#125;); lastTag = tagName; &#125; if (options.start) &#123; options.start(tagName, attrs, unary, match.start, match.end); &#125;&#125; 可以看到Vue把数据做了处理之后，又把这些数据交给了start钩子处理，我们看看start钩子里面的逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 function createASTElement(tag,attrs,parent) &#123; return &#123; type: 1, tag: tag, attrsList: attrs, attrsMap: makeAttrsMap(attrs), rawAttrsMap: &#123;&#125;, parent: parent, children: [] &#125; &#125;function parse(template,options) &#123; // ...此处省略部分代码 var stack = []; var root; var currentParent; parseHTML(template, &#123; start: function start(tag, attrs, unary, start$1, end)&#123; var element = createASTElement(tag, attrs, currentParent); if (options.outputSourceRange) &#123; element.start = start$1; element.end = end; element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) &#123; cumulated[attr.name] = attr; return cumulated &#125;, &#123;&#125;); &#125; // 处理v-for v-if指令 if (!element.processed) &#123; processFor(element); processIf(element); processOnce(element); &#125; // 解析到的第一个元素 就是根节点 if (!root) &#123; root = element; &#125; // 如果是双标签 那currentParent就指定当前的ast元素，并存到stack栈中 if (!unary) &#123; currentParent = element; stack.push(element); &#125; else &#123; closeElement(element); &#125; &#125;, end: function end() &#123;&#125;, chars: function ()&#123;&#125; &#125;) return root&#125; 其实start钩子内部大致就做了三件事： 根据createASTElement生成一个ast元素，该ast元素也是用来描述开始标签，虽然match也用来描述开始标签，但是JS操作ast元素显然更方便些。 处理开始标签上面的v-if v-for v-once指令 初始化root currentParent stack的值，其中root存储模版的根节点，currentParent指定当前解析到的ast元素，stack存放解析到的所有ast元素下面是开始标签对应ast元素的结构图: 解析字符文本以上就是Vue内部解析开始标签的所有过程了，接下来我们再看看Vue内部如何解析文本的？,根据上面的分析，我们已经知道解析到文本会交给chars钩子处理，我们来看看chars钩子内部的逻辑。 1234567891011121314151617181920212223242526272829303132function parse(template,options) &#123; // ...此处省略部分代码 var stack = []; var root; var currentParent; parseHTML(template, &#123; start: function start()&#123;&#125;, end: function end() &#123;&#125;, // 解析到文本的钩子函数 chars: function (text, start, end)&#123; var children = currentParent.children; var res; var child; // 解析到有插值的文本 if (!inVPre &amp;&amp; text !== &#x27; &#x27; &amp;&amp; (res = parseText(text, delimiters))) &#123; child = &#123; type: 2, expression: res.expression, tokens: res.tokens, text: text &#125;; &#125; else if (text !== &#x27; &#x27; || !children.length || children[children.length - 1].text !== &#x27; &#x27;) &#123; // 解析到没有插值的文本 child = &#123; type: 3, text: text &#125;; &#125; &#125; &#125;) return root&#125; chars钩子内部逻辑很简单，就是区分文本是否有插值符号，有插值符号的话ast对象type标记为2，并解析插值，没有插值就当作普通文本处理ast对象type标记为3。下面是插值文本对应的ast对象 解析结束标签最后我们再看看Vue内部解析结束标签的过程，,根据上面的分析，我们已经知道解析到结束标签会交给parseEndTag函数处理，来看看parseEndTag函数内部的逻辑。大致意思是取出stack栈中的最后一项，并将最后一项的tag，start，end交给end钩子处理 12345678910111213141516171819202122232425262728293031function parseEndTag(tagName, start, end) &#123; var pos, lowerCasedTagName; if (start == null) &#123; start = index; &#125; if (end == null) &#123; end = index; &#125; // Find the closest opened tag of the same type if (tagName) &#123; lowerCasedTagName = tagName.toLowerCase(); for (pos = stack.length - 1; pos &gt;= 0; pos--) &#123; if (stack[pos].lowerCasedTag === lowerCasedTagName) &#123; break &#125; &#125; &#125; else &#123; // If no tag name is provided, clean shop pos = 0; &#125; if (pos &gt;= 0) &#123; // Close all the open elements, up the stack for (var i = stack.length - 1; i &gt;= pos; i--) &#123; if (options.end) &#123; options.end(stack[i].tag, start, end); &#125; &#125; // Remove the open elements from the stack stack.length = pos; lastTag = pos &amp;&amp; stack[pos - 1].tag; &#125; &#125;&#125; 接着看end钩子函数的处理逻辑，大致意思是取出stack栈中最后一项element，接着又使用closeElement来构建elemenet这个ast对象的父子级关系，currentParent又指定stack栈中的最后一项。需要注意的是parse函数里面的stack栈和parseHTML函数里面的stack栈不是一回事，parse函数里面的stack栈中存放的是ast对象，parseHTML函数里面的stack栈存放的是所有开始标签的信息。 1234567891011121314151617181920212223242526272829function parse(template,options) &#123; // ...此处省略部分代码 var stack = []; var root; var currentParent; parseHTML(template, &#123; start: function start()&#123;&#125;, end: function end() &#123; var element = stack[stack.length - 1]; // pop stack stack.length -= 1; currentParent = stack[stack.length - 1]; if (options.outputSourceRange) &#123; element.end = end$1; &#125; closeElement(element); &#125;, // 解析到文本的钩子函数 chars: function ()&#123;&#125; &#125;) return root&#125;// 构建ast对象的父子级关系function closeElement (element)&#123; // 此处省略若干代码 currentParent.children.push(element); element.parent = currentParent;&#125; 最终返回的root根元素就是最终的ast树。以上，就是Vue内部如何把一个html字符串转换成ast树的过程，我们看看ast树的结构,其中包含了父子级关系，if for directives等指令标记，节点自身的相关信息","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"1. Vue如何构建响应式系统?","slug":"vue01","date":"2020-11-21T11:07:30.000Z","updated":"2020-12-17T13:50:23.756Z","comments":true,"path":"2020/11/21/vue01/","link":"","permalink":"http://example.com/2020/11/21/vue01/","excerpt":"","text":"响应式系统入口vue2.x版本的响应系统入口是observe函数，先看下Vue内部的处理： observe &amp; Observer 可以看到observe函数只检测数组和普通对象，并对数组和普通对象做了不同处理 Observer类的实例会有dep属性，该属性用来指向dep订阅器对象，注意：初始化时dep订阅器对象为空。dep属性的作用是什么？我们会在Vue如何构建依赖关系时讲到。 def(value, &#39;__ob__&#39;, this)其实就是给观测的数组/普通对象添加__ob__属性，值指向Observer的实例，__ob__属性的作用是什么？我们会在Vue的更新策略时讲到。 12345678910111213141516171819202122232425262728function observe(value, asRootData) &#123; var ob; if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__; &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value); &#125; return ob&#125; var Observer = function Observer(value) &#123; this.value = value; this.dep = new Dep(value); this.vmCount = 0; def(value, &#x27;__ob__&#x27;, this); if (Array.isArray(value)) &#123; //构建数组对象的响应式系统 protoAugment(value, arrayMethods); this.observeArray(value); &#125; else &#123; //构建普通对象的响应式系统 this.walk(value); &#125; &#125;; 普通对象Object.defineProperty可以看到构建数据对象data的响应式系统很简单，就是用Object.defineProperty给data的每个key都设置get/set钩子,用户每次获取值的时候例如this.data.msg，都会触发key的get钩子，设置新值的时候例如this.data.msg=&#39;新的msg&#39;，都会触发key的set钩子从而让视图更新，不过视图更新我们会在Vue的更新策略讨论,不管怎样，普通对象的响应式系统确实是通过 Object.defineProperty这个API很轻易的构建出来了。 123456789101112131415161718192021222324252627282930313233343536373839Observer.prototype.walk = function walk(obj) &#123; var keys = Object.keys(obj); for (var i = 0; i &lt; keys.length; i++) &#123; defineReactive$$1(obj, keys[i]); &#125;&#125;;function defineReactive$$1( obj, key, val, customSetter, shallow ) &#123; var dep = new Dep(key); var childOb = !shallow &amp;&amp; observe(val); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; var value = getter ? getter.call(obj) : val; // TODO return value &#125;, set: function reactiveSetter(newVal) &#123; var value = getter ? getter.call(obj) : val; // 老值和新值相等 就终止函数 if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; if (customSetter) &#123; customSetter(); &#125; if (getter &amp;&amp; !setter) &#123; return &#125; if (setter) &#123; setter.call(obj, newVal); &#125; else &#123; val = newVal; &#125; // 劫持新设置的值 childOb = !shallow &amp;&amp; observe(newVal); dep.notify(); &#125; &#125;); &#125; 数据代理还有一个问题，平时我们都是this.msg就可以获取data中的msg了，现在这个响应式系统只能通过this.data.msg拿到data中的msg。很显然，这个响应式系统并不完善，我们看看vue源码如何实现更完善的响应式系统的？ 把数据对象data数据对象存到_data中 触发proxy函数，proxy函数的功能就是每次访问vm[key]时都会返回vm._data[key]属性以上就实现了更完善的响应式系统了。1234567891011121314151617181920212223function initData(vm) &#123; var data = vm.$options.data; data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125;; var keys = Object.keys(data); var i = keys.length; while (i--) &#123; proxy(vm, &quot;_data&quot;, key); &#125;&#125;// 数据代理function proxy(target, sourceKey, key) &#123; sharedPropertyDefinition.get = function proxyGetter() &#123; return this[sourceKey][key] &#125;; sharedPropertyDefinition.set = function proxySetter(val) &#123; this[sourceKey][key] = val; &#125;; // vm.msg --&gt; vm._data.msg Object.defineProperty(target, key, sharedPropertyDefinition);&#125; 数组对象普通对象的响应式系统已经构建完成了，我们接下来再看看数组对象是如何构建响应式系统的？ 123456789101112131415161718var Observer = function Observer(value) &#123; this.value = value; this.dep = new Dep(value); this.vmCount = 0; def(value, &#x27;__ob__&#x27;, this); if (Array.isArray(value)) &#123; protoAugment(value, arrayMethods); this.observeArray(value); &#125; else &#123; this.walk(value); &#125;&#125;;// 修改隐式原型function protoAugment(target, src) &#123; target.__proto__ = src;&#125; 可以看到，当处理数组的时候会触发protoAugment函数把数组的隐式原型__proto__指向了arrayMethods,那arrayMethods是什么呢？看下面的代码可知： arrayMethods是一个空对象，其隐式原型__proto__指向了Array.prototype，这样的话，在arrayMethods这个对象的原型链上就有了数组的所有方法了。 遍历methodsToPatch，给arrayMethods对象添加push,pop,shift,unshift,splice,sort,reverse这七个属性，值是mutator函数 123456789101112131415161718192021222324252627282930313233343536373839var arrayProto = Array.prototype;var arrayMethods = Object.create(arrayProto); var methodsToPatch = [ &#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;];methodsToPatch.forEach(function (method) &#123; // 基于原型链获取数组原型上的方法 var original = arrayProto[method]; // 给arrayMethods对象设置method属性 即arrayMethods[&#x27;push&#x27;] = mutator def(arrayMethods, method, function mutator() &#123; var args = [], len = arguments.length; while (len--) args[len] = arguments[len]; var result = original.apply(this, args); var ob = this.__ob__; var inserted; switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args; break case &#x27;splice&#x27;: inserted = args.slice(2); break &#125; if (inserted) &#123; ob.observeArray(inserted); &#125; // notify change ob.dep.notify(); return result &#125;);&#125;); 可以看到，最终的arrayMethods就是上面的结构，它是一个对象，自身有7个属性，隐式原型上有所有的数组方法，想象一下，如果我们执行this.list.push(2)，就会沿着原型链找到arrayMethods对象上的push方法执行，即mutator函数，mutator函数内部的逻辑其实就是触发视图更新。这个我们在后面章节Vue的更新策略讨论 ，不管怎样，数组对象的响应式系统确实是通过延长数组对象的原型链构建出来了。 需要注意的是，对于数组，Vue只为methodsToPatch中的7个方法构建了响应式系统，对于其他的数组方法，Vue并没有构建响应式系统。 结束以上，就是Vue如何为数组对象/普通对象构建响应式系统的过程。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"浏览器缓存策略","slug":"cache","date":"2020-11-19T15:49:23.000Z","updated":"2020-12-16T07:39:06.693Z","comments":true,"path":"2020/11/19/cache/","link":"","permalink":"http://example.com/2020/11/19/cache/","excerpt":"","text":"当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。1.目录结构如下 2.首页结构1234567891011121314151617&lt;!-- cache.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;data:image/ico;base64,aWNv&quot;&gt; &lt;title&gt;基于node学习浏览器缓存策略&lt;/title&gt; &lt;script src=&quot;/script.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是服务首页&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 3.搭建服务123456789101112// app.jsconst http = require(&#x27;http&#x27;);const fs = require(&#x27;fs&#x27;);http.createServer((request, response) =&gt; &#123; if (request.url === &#x27;/&#x27;) &#123; const readStream = fs.createStream(&#x27;./cache.html&#x27;); readStream.pipe(response) &#125;else if (/\\.js$/.test(request.url)) &#123; const readStream = fs.createReadStream(&#x27;./script.js&#x27;); readStream.pipe(response) &#125;&#125;) 4.强缓存触发浏览器强缓存策略需要后端配置特殊字段Expires/Cache-Control均可，并且返回状态码2001234567891011121314151617http.createServer((request, response) =&gt; &#123; if (request.url === &#x27;/&#x27;) &#123; const readStream = fs.createStream(&#x27;./cache.html&#x27;); readStream.pipe(response) &#125;else if (/\\.js$/.test(request.url)) &#123; // Expires字段设置的时间是固定的某个时间点 // response.writeHead(200, &#123; // &#x27;Expires&#x27;: new Date(&#x27;2020-12-30 12:00:00&#x27;), // &#125;); // Cache-Control字段设置的是相对于本次服务端返回的时间 单位s response.writeHead(200, &#123; &#x27;Cache-Control&#x27;: &#x27;max-age=200&#x27; &#125;); const readStream = fs.createReadStream(&#x27;./script.js&#x27;); readStream.pipe(response) &#125;&#125;) 第一次访问资源命中强缓存之后，浏览器就不会同样的资源发起网络请求了，浏览器会直接强制从memory(内存)/disk(硬盘)中读取资源，如下所示 5.协商缓存触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified/Etag均可，并且返回状态码30412345678910111213141516171819202122232425262728293031323334353637http.createServer((request, response) =&gt; &#123; if (request.url === &#x27;/&#x27;) &#123; const readStream = fs.createStream(&#x27;./cache.html&#x27;); readStream.pipe(response) &#125;else if (/\\.js$/.test(request.url)) &#123; // const buffer = fs.readFileSync(&#x27;./script.js&#x27;); // const fileMd5 = md5(buffer); 文件的md5值 // const noneMatch = request.headers[&#x27;if-none-match&#x27;]; 来自浏览器端传递的值 // 协商成功 状态码返回304 // if (noneMatch === fileMd5) &#123; // response.statusCode = 304; // response.end(); // return; // &#125; // 协商失败 状态码返回200 // response.writeHead(200, &#123; // &#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;, // &#x27;ETag&#x27;: fileMd5, // &#125;); const stat = fs.statSync(&#x27;./script.js&#x27;); const mtime = stat.mtime.toGMTString() const requestMtime = request.headers[&#x27;if-modified-since&#x27;]; // 协商成功 本次服务端不返回资源 让浏览器使用缓存的资源 if (mtime === requestMtime) &#123; response.statusCode = 304; //必须返回304 response.end(); return; &#125; // 协商失败 状态码返回200 response.writeHead(200, &#123; &#x27;Last-Modified&#x27;: mtime, &#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;, // 必须设置，否则下次浏览器请求会命中强缓存 &#125;); const readStream = fs.createReadStream(&#x27;./script.js&#x27;); readStream.pipe(response); &#125;&#125;) 第一次访问资源命中协商缓存之后，浏览器会在下次网络请求中用特殊字段(if-modified-since/if-no-match)携带第一次访问后端时返回的响应头信息，后端在对比前后数据之后，判断资源的内容是否更改，如果更改，就协商失败，返回最新的资源给浏览器，如果没有更改，就协商成功，不返回数据给浏览器，浏览器最终使用缓存的资源 6.强缓存和协商缓存对比6.1 强缓存优先级比协商缓存高，因为浏览器总是倾向于请求更少的资源，命中强缓存后，浏览器都不会向后端请求资源了，所以强缓存优先级比协商缓存高6.2 判断是否命中强缓存的纬度是时间，Expires是固定时间，Cache-Control是相对时间 ;判断是否命中协商缓存的纬度是资源内容是否被更改，Last-Modified是用资源的修改时间，Etag是用资源的hash值","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-11-16T16:51:19.875Z","updated":"2020-11-19T15:35:10.620Z","comments":true,"path":"2020/11/17/hello-world/","link":"","permalink":"http://example.com/2020/11/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"},{"name":"Node","slug":"Node","permalink":"http://example.com/categories/Node/"},{"name":"JS","slug":"JS","permalink":"http://example.com/categories/JS/"},{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]}