{"meta":{"title":"Hexo","subtitle":"","description":"","author":"heaven","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"4.Vue如何构建依赖关系","slug":"vue04","date":"2020-12-15T13:14:44.000Z","updated":"2020-12-15T16:43:09.927Z","comments":true,"path":"2020/12/15/vue04/","link":"","permalink":"http://example.com/2020/12/15/vue04/","excerpt":"","text":"在第三节文章中，我们知道了Vue把template编译成render函数的过程。接下来Vue内部会怎么处理呢？其实接下来Vue就会执行mountComponent函数来挂载组件，如下所示,函数内部逻辑也很清晰 触发beforeMount钩子 创建watcher的求值函数updateComponent，其中_render函数是创建虚拟dom,_update函数在首次触发是创建真实dom,再次触发是比对前后的虚拟dom 创建渲染watcher,其中最后一个参数true表示该watcher是渲染watcher 触发mounted钩子 12345678910111213141516171819function mountComponent(vm, el,hydrating) &#123; callHook(vm, &#x27;beforeMount&#x27;); var updateComponent = function () &#123; vm._update(vm._render(), hydrating); &#125;; new Watcher(vm, updateComponent, noop, &#123; before: function before() &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &#x27;beforeUpdate&#x27;); &#125; &#125; &#125;, true /* isRenderWatcher */); if (vm.$vnode == null) &#123; vm._isMounted = true; callHook(vm, &#x27;mounted&#x27;); &#125; return vm&#125; 接下来咱们看看Vue是如何定义Watcher这个类的，代码如下，对于Watcher类的参数需要详细说下： expOrFn 存储watcher的求值函数 ，对于渲染watcher，expOrFn就是updateComponent ，当然除了watcher之后，其实还会有别的两类watcher，分别为计算属性创建的lazyWatcher和为watch选项创建的自定义watcher，这两类对应的求值函数是什么后面再说。 cb 存储求值函数expOrFn执行后的回调函数，对于渲染watcher，cb就是noop空函数 options 存储watcher创建的配置参数，其中创建渲染watcher传入的配置对象有before钩子函数，创建自定义watcher时传入的配置对象有user属性为true，创建lazyWatcher时传入的配置对象有lazy属性为true。 isRenderWatcher 表示创建的watcher是否是渲染watcher，isRenderWatcher为true表示渲染watcher，并将渲染watcher放到vm._watcher中。 除了这些参数之外，还有别的处理，比如: 每次创建watcher时都会把watcher放到vm._watchers 在创建watcher时，基于lazy值判断是否执行求值函数，其中如果是lazyWatcher就不求值，不是lazyWatcher就求值。 1234567891011121314151617181920212223242526272829303132var Watcher = function Watcher( vm, expOrFn, cb, options, isRenderWatcher)&#123; this.vm = vm; if (isRenderWatcher) &#123; vm._watcher = this; &#125; vm._watchers.push(this); if (options) &#123; this.deep = !!options.deep; this.user = !!options.user; this.lazy = !!options.lazy; this.sync = !!options.sync; this.before = options.before; &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false; &#125; this.cb = cb; this.id = ++uid$2; // uid for batching this.active = true; this.dirty = this.lazy; // for lazy watchers this.deps = []; this.newDeps = []; this.depIds = new _Set(); this.newDepIds = new _Set(); this.expression = expOrFn.toString(); // parse expression for getter if (typeof expOrFn === &#x27;function&#x27;) &#123; this.getter = expOrFn; &#125; else &#123; this.getter = parsePath(expOrFn); &#125; this.value = this.lazy ? undefined : this.get();&#125; 经过上面的分析，只要不是lazyWatcher就求值，那我们在初始化渲染watcher就会触发求值函数了，接下来我们看看求值函数的逻辑：1.触发pushTarget，当前的watcher入targetStack栈，Dep.target指向栈顶的watcher2.触发求值函数getter3.触发popTarget，当前的watcher出targetStack栈，Dep.target指向栈顶的watcher4.触发cleanupDeps函数，depIds/deps存储本次newDepIds/newDeps的值，之后再清空newDepIds/newDeps 12345678910111213141516171819202122232425262728293031323334353637383940Watcher.prototype.get = function get() &#123; pushTarget(this); var value; var vm = this.vm; value = this.getter.call(vm, vm); popTarget(); this.cleanupDeps(); return value&#125;;Dep.target = null;var targetStack = [];function pushTarget(target) &#123; targetStack.push(target); Dep.target = target;&#125;function popTarget() &#123; targetStack.pop(); Dep.target = targetStack[targetStack.length - 1];&#125;Watcher.prototype.cleanupDeps = function cleanupDeps() &#123; var i = this.deps.length; while (i--) &#123; var dep = this.deps[i]; if (!this.newDepIds.has(dep.id)) &#123; dep.removeSub(this); &#125; &#125; var tmp = this.depIds; this.depIds = this.newDepIds; this.newDepIds = tmp; this.newDepIds.clear(); tmp = this.deps; this.deps = this.newDeps; this.newDeps = tmp; this.newDeps.length = 0;&#125;; 对于渲染watcher来说，getter就是updateComponent函数，而updateComponent函数的逻辑也很清晰: 触发_render函数 触发_update函数可以看到_render函数内部就是执行render，而这个render函数就是基于template模版创建的render函数，值的注意的是，执行render函数时，会将内部this指向vm._renderProxy，vm._renderProxy对象经过处理指向组件实例vm。 123456789101112var updateComponent = function () &#123; vm._update(vm._render(), hydrating);&#125;;Vue.prototype._render = function () &#123; // 此处省略若干代码 var vm = this; var ref = vm.$options; var render = ref.render; var vnode = render.call(vm._renderProxy, vm.$createElement); return vnode&#125; 假定template模版如下，则生成的render函数如下图所示： 1234&lt;div id=app class=&quot;heaven&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;button @click=&#x27;handleClick&#x27;&gt;按钮&lt;/button&gt;&lt;/div&gt; 当执行render函数时，有个with语句，执行with内部逻辑时，总是从this中取值，即取msg的值时，等价取vm.msg，因为我们之前做了数据代理的原因， 所以取vm.msg时，等价取vm._data.msg ,此时就触发了msg的get钩子函数。这时候get函数内部就会构建属性msg和watcher的依赖关系，我们看看get函数内部是怎么做的？ 判断Dep.target是否存在，之所以要有这个判断，是因为我们只要在渲染watcher/lazyWatcher/自定义watcher的求值函数触发时，才触发dep.depend函数 判断childOb是否存在，存在就执行childOb.dep.depend，childOb是什么？为什么要执行childOb.dep.depend，我们稍等再说。 1234567891011121314151617181920212223242526function defineReactive$$1( obj, key, val, customSetter,shallow) &#123; var dep = new Dep(key); var childOb = !shallow &amp;&amp; observe(val); Object.defineProperty(obj, key, &#123; get: function reactiveGetter() &#123; if (Dep.target) &#123; dep.depend(); if (childOb) &#123; childOb.dep.depend(); if (Array.isArray(value)) &#123; dependArray(value); &#125; &#125; &#125; return value &#125;, set: function reactiveSetter(newVal) &#123; if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; val = newVal; childOb = !shallow &amp;&amp; observe(newVal); dep.notify(); &#125; &#125;);&#125; 经过上面的分析，我们知道Dep.target存在的话就要执行dep.depend方法，我们看看这个函数内部做了什么？ 也是判断是否Dep.target是否存在，值得注意的是，此时Dep.target指向渲染watcher，并且执行渲染watcher的addDep方法 watcher的addDep方法内部用到两个if判断，第一个判断是为了防止在本次求值过程中重复把watcher放到dep对象中，第二个if判断是为了防止在不同的求值时刻（用户更新视图会再次求值，再次求值会再次走到addDep的逻辑中）重复把watcher放到dep对象中。 最终会触发 dep.addSub方法，把watcher放到depd对象的subs中。至此属性msg的dep对象中的subs数组收集到了渲染watcher，这就是某个属性的依赖收集过程。 123456789101112131415161718192021222324var Dep = function Dep(key) &#123; this.id = uid++; this.subs = [];&#125;;Dep.prototype.addSub = function addSub(sub) &#123; this.subs.push(sub);&#125;;Dep.prototype.depend = function depend() &#123; if (Dep.target) &#123; Dep.target.addDep(this); &#125;&#125;;Watcher.prototype.addDep = function addDep(dep) &#123; var id = dep.id; if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id); this.newDeps.push(dep); if (!this.depIds.has(id)) &#123; dep.addSub(this); &#125; &#125;&#125;;","categories":[],"tags":[]},{"title":"实现express的洋葱模型","slug":"express01","date":"2020-12-11T09:39:55.000Z","updated":"2020-12-15T11:54:47.653Z","comments":true,"path":"2020/12/11/express01/","link":"","permalink":"http://example.com/2020/12/11/express01/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"3. Vue生成ast树后，做了肾么事？","slug":"vue03","date":"2020-12-06T06:59:10.000Z","updated":"2020-12-08T11:58:21.181Z","comments":true,"path":"2020/12/06/vue03/","link":"","permalink":"http://example.com/2020/12/06/vue03/","excerpt":"","text":"Vue生成了ast语法树之后，还对这个树结构进行了静态标记，之所以给ast树打上是否是静态的标记，是因为在后面diff算法的时候，直接跳过静态的节点，可以节省diff的开销。下面我们看看是怎么给节点打静态标记的吧 1234567891011121314var ast = parse(template.trim(), options);if (options.optimize !== false) &#123; optimize(ast, options);&#125;function optimize(root, options) &#123; if (!root) &#123; return &#125; isStaticKey = genStaticKeysCached(options.staticKeys || &#x27;&#x27;); isPlatformReservedTag = options.isReservedTag || no; // 给节点打上是否是静态节点的标记 markStatic$1(root); // 给节点打上是否是静态根节点的标记 markStaticRoots(root, false);&#125; 上面的代码中，markStatic$1函数是给节点打上是否是静态节点的标记，markStaticRoots函数是给节点打上是否是静态根节点的标记，我们先看看markStatic$1函数内部的逻辑，其实核心isStatic函数，这个函数是判断节点是否是静态节点。判断的逻辑大致如下 如果是插值文本 那就不是静态节点 如果是普通文本 那就是静态节点 有跳过编译的指令pre 那就是静态节点 没有属性绑定&amp;有if for&amp;不是Vue内置标签等 那就是静态节点 在经过上面判断出这个节点是否是静态节点，如果是那就给这个节点在加上static:true标记，当然这还没结束，接着还会在遍历这个节点的子节点们，判断子节点是否是静态节点，一旦某个子节点不是静态节点，那就给这个节点打上static:false标记 1234567891011121314151617181920212223242526272829 function markStatic$1(node) &#123; node.static = isStatic(node); if (node.type === 1) &#123; for (var i = 0, l = node.children.length; i &lt; l; i++) &#123; var child = node.children[i]; markStatic$1(child); if (!child.static) &#123; node.static = false; &#125; &#125; &#125;&#125;function isStatic(node) &#123; if (node.type === 2) &#123; // expression return false &#125; if (node.type === 3) &#123; // text return true &#125; return !!(node.pre || ( !node.hasBindings &amp;&amp; // no dynamic bindings !node.if &amp;&amp; !node.for &amp;&amp; // not v-if or v-for or v-else !isBuiltInTag(node.tag) &amp;&amp; // not a built-in isPlatformReservedTag(node.tag) &amp;&amp; // not a component !isDirectChildOfTemplateFor(node) &amp;&amp; Object.keys(node).every(isStaticKey) ))&#125; 下面再看看markStaticRoots函数的逻辑,判断节点是否是静态根节点的逻辑大致如下 如果是该节点是静态节点，并且这个节点的子节点长度大于1，那这个节点就是静态根节点 不满足上述条件，则这个节点就不是静态根节点在经过上面判断出这个节点是否是静态根节点，如果是那就给这个节点在加上staticRoot:true标记，当然这还没结束，接着还会在遍历这个节点的子节点们，判断子节点是否是静态根节点，最后给子节点们打上staticRoot标记 123456789101112131415161718192021function markStaticRoots(node, isInFor) &#123; if (node.type === 1) &#123; // For a node to qualify as a static root, it should have children that // are not just static text. Otherwise the cost of hoisting out will // outweigh the benefits and it&#x27;s better off to just always render it fresh. if (node.static &amp;&amp; node.children.length &amp;&amp; !( node.children.length === 1 &amp;&amp; node.children[0].type === 3 )) &#123; node.staticRoot = true; return &#125; else &#123; node.staticRoot = false; &#125; if (node.children) &#123; for (var i = 0, l = node.children.length; i &lt; l; i++) &#123; markStaticRoots(node.children[i], isInFor || !!node.for); &#125; &#125; &#125;&#125; 最终Vue就处理好了ast树，接着会基于ast树生成代码，,这里使用到了generate函数，generate这个函数内部的逻辑大致是: genElement函数内部创建节点对应的代码存到data中 genChildren函数内部创建节点的子节点对应的代码存到children中 最终基于data和children拼接成最终的code，其中如果节点有if for once等指令，会转换成特殊的代码 如果是静态根节点，就生成代码并存到staticRenderFns中值得注意的是，我们在下面代码中可以得到结论：v-for的优先级比v-if的优先级因为generate函数内部是先处理el.for，再处理el.if的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var ast = parse(template.trim(), options);if (options.optimize !== false) &#123; optimize(ast, options);&#125;var code = generate(ast, options);function generate(ast, options ) &#123; var state = new CodegenState(options); var code = ast ? genElement(ast, state) : &#x27;_c(&quot;div&quot;)&#x27;; return &#123; render: (&quot;with(this)&#123;return &quot; + code + &quot;&#125;&quot;), staticRenderFns: state.staticRenderFns &#125;&#125;function genElement(el, state) &#123; if (el.parent) &#123; el.pre = el.pre || el.parent.pre; &#125; if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123; return genStatic(el, state) &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123; return genOnce(el, state) &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123; return genFor(el, state) &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123; return genIf(el, state) &#125; else if (el.tag === &#x27;template&#x27; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123; return genChildren(el, state) || &#x27;void 0&#x27; &#125; else if (el.tag === &#x27;slot&#x27;) &#123; return genSlot(el, state) &#125; else &#123; // component or element var code; if (el.component) &#123; code = genComponent(el.component, el, state); &#125; else &#123; var data; if (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) &#123; data = genData$2(el, state); &#125; var children = el.inlineTemplate ? null : genChildren(el, state, true); code = &quot;_c(&#x27;&quot; + (el.tag) + &quot;&#x27;&quot; + (data ? (&quot;,&quot; + data) : &#x27;&#x27;) + (children ? (&quot;,&quot; + children) : &#x27;&#x27;) + &quot;)&quot;; &#125; // module transforms for (var i = 0; i &lt; state.transforms.length; i++) &#123; code = state.transforms[i](el, code); &#125; return code &#125;&#125; 最终输出的code为下图，其中render为可执行的字符串，staticRenderFns为静态节点字符串 生成code之后，接下来的处理是在compileToFunctions函数中,大致逻辑是： 定义cache缓存对象 compile函数返回的是code对象,即compiled-&gt;code对象 基于render/staticRenderFns创建函数 返回res对象，并将key-&gt;res存到缓存对象中,这个是vue的优化策略，当第二次再次编译同样的模版时，会直接取出render/staticRenderFns，不会重复编译出render/staticRenderFns，这样在多次使用组件时，就可以极大的节省浏览器开销 123456789101112131415161718192021 function compileToFunctions( template, options, vm) &#123; var cache = Object.create(null); // 此时省略很多代码 if (cache[key]) &#123; return cache[key] &#125; // 编译模版 var compiled = compile(template, options); var res = &#123;&#125;; var fnGenErrors = []; res.render = createFunction(compiled.render, fnGenErrors); res.staticRenderFns = compiled.staticRenderFns.map(function (code) &#123; return createFunction(code, fnGenErrors) &#125;); return (cache[key] = res)&#125;function createFunction(code, errors) &#123; return new Function(code)&#125; 至此Vue编译模版终于结束了，过程是从html字符串-&gt;ast语法树-&gt;code对象-&gt;render函数。其实还有一个很重要的问题，就是Vue在模版编译的过程中，函数嵌套很严重，Vue内部为什么嵌套这么多层呢？其实","categories":[],"tags":[]},{"title":"js小技巧","slug":"js骚操作","date":"2020-12-03T10:31:01.000Z","updated":"2020-12-03T13:15:23.754Z","comments":true,"path":"2020/12/03/js骚操作/","link":"","permalink":"http://example.com/2020/12/03/js%E9%AA%9A%E6%93%8D%E4%BD%9C/","excerpt":"","text":"金额格式化 123456let num = 1000000let result = num.toLocaleString() // 1,000,000const reg = /(?=(\\B)(\\d&#123;3&#125;)+$)/glet result = num.toString().replace(reg,&#x27;,&#x27;) // 1,000,000 交换值 1234567let a = 1,b = 2b = [a,a=b][0] //a=1 b=2a = a^bb = a^ba = a^b //a=1 b=2 1","categories":[],"tags":[]},{"title":"2.  Vue如何编译模版","slug":"vue02","date":"2020-12-01T13:26:48.000Z","updated":"2020-12-15T14:57:36.528Z","comments":true,"path":"2020/12/01/vue02/","link":"","permalink":"http://example.com/2020/12/01/vue02/","excerpt":"","text":"Vue上手非常简单，因为我们可以直接编写html作为组件的模版，对比学习React还需要接触jsx语法，Vue对新手可以说是非常友好了，接下来我们看看vue是如何处理template模版的？ 1234567891011121314151617var createCompiler = createCompilerCreator( function baseCompile(template, options) &#123; // template -&gt; ast 对template的第一层抽象 var ast = parse(template.trim(), options); // 优化ast树 标注静态节点 if (options.optimize !== false) &#123; optimize(ast, options); &#125; // ast -&gt; 可执行code 对template的第二层抽象 var code = generate(ast, options); return &#123; ast: ast, render: code.render, staticRenderFns: code.staticRenderFns &#125; &#125;); 可以看到首先是template模版放到parse函数中处理，得到ast对象(abstract syntax tree)，其实ast对象是对template的第一层抽象，template模版本质上是一个html字符串，现在用ast对象来描述template模版，接下来看看html字符串如何被转换成ast对象的？假定template模版如下： 12345678910111213141516171819202122232425// html模版let template = ` &lt;div id=app v-if=&#x27;msg&#x27; v-for=&#x27;item in 3&#x27; v-once:click=&#x27;handleClick&#x27;&gt; &lt;div class=&#x27;text&#x27; title=&#x27;heaven&#x27;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;`function parse(template,options) &#123; // ...此处省略部分代码 var stack = []; var root; var currentParent; parseHTML(template, &#123; // ...此处省略部分代码 // 解析到开始标签的钩子函数 start: function start()&#123;&#125;, // 解析到结束标签的钩子函数 end: function end() &#123;&#125;, // 解析到文本的钩子函数 chars: function()&#123; &#125; &#125;) return root&#125; 可以看到真正处理template的是parseHTML这个函数，我们看看这个函数内部的逻辑是什么？其实大致有4步 定义token，这些token用来解析开始标签 标签属性 结束标签等 处理开始标签，并把处理的结果交给handleStartTag处理 处理结束标签，并把处理的结果交给parseEndTag处理 处理文本，并把文本交给chars钩子函数处理123456789101112131415161718192021222324252627282930313233343536373839404142434445// 解析属性的token id=&#x27;app&#x27;var attribute = /^\\s*([^\\s&quot;&#x27;&lt;&gt;\\/=]+)(?:\\s*(=)\\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\\s&quot;&#x27;=&lt;&gt;`]+)))?/;var ncname = &quot;[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z&quot; + (unicodeRegExp.source) + &quot;]*&quot;;var qnameCapture = &quot;((?:&quot; + ncname + &quot;\\\\:)?&quot; + ncname + &quot;)&quot;;// 解析开始标签的token &lt;div var startTagOpen = new RegExp((&quot;^&lt;&quot; + qnameCapture));// 解析开始标签结束的token /&gt; &gt;var startTagClose = /^\\s*(\\/?)&gt;/;// 解析结束标签的token &lt;/div&gt;var endTag = new RegExp((&quot;^&lt;\\\\/&quot; + qnameCapture + &quot;[^&gt;]*&gt;&quot;));function parseHTML(html, options) &#123; var stack = []; var index = 0; while (html) &#123; var textEnd = html.indexOf(&#x27;&lt;&#x27;); // ...此处省略部分代码 // 处理开始标签 var startTagMatch = parseStartTag(); if (startTagMatch) &#123; handleStartTag(startTagMatch); continue &#125; // 处理结束标签 var endTagMatch = html.match(endTag); if (endTagMatch) &#123; var curIndex = index; advance(endTagMatch[0].length); parseEndTag(endTagMatch[1], curIndex, index); continue &#125; // 处理文本 包括静态文本和插值 var text if (textEnd &gt;= 0) &#123; // ...此处省略部分代码 text = html.substring(0, textEnd); &#125; if (text) advance(text.length); if (options.chars &amp;&amp; text) &#123; options.chars(text, index - text.length, index); &#125; &#125;&#125; 1.解析开始标签接下来，我们看看parseStartTag函数是如何处理开始标签的？12345678910111213141516171819202122232425262728293031// 控制全局的index/html向前移动nfunction advance(n) &#123; index += n; html = html.substring(n);&#125;function parseStartTag() &#123; // 解析到开始标签 var start = html.match(startTagOpen); if (start) &#123; var match = &#123; tagName: start[1], attrs: [], start: index &#125;; advance(start[0].length); var end, attr; while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(dynamicArgAttribute) || html.match(attribute))) &#123; attr.start = index; advance(attr[0].length); attr.end = index; match.attrs.push(attr); &#125; if (end) &#123; match.unarySlash = end[1]; advance(end[0].length); match.end = index; return match &#125; &#125;&#125; 最终开始标签&lt;div id=&#39;app&#39;&gt;被解析成下面的结构，其中attrs里面存放开始标签的属性集合，start是开始标签的起始位置，end是开始标签的结束位置，tagName是开始标签的标签类型，unarySlash为空代表标签为双标签，这样开始标签所有信息都被这个对象完美描述了，下面是match的结构图 接下来，开始标签的处理结果match还需要交给handleStartTag处理，我们看看handleStartTag内部的逻辑，其实也是很清晰的 处理attrs属性，最终把标签的属性改成key:value的形式，并且标记attrs内部的属性开始和结束位置 将开始标签的信息放到stack栈中 触发start钩子函数值的注意的是value值为args[3] || args[4] || args[5],这是怎么回事呢？这是因为对于属性值的三种形式&lt;div id=&quot;app&quot;&gt; app可以是单引号，双引号，不加引号，分别对应args[3] || args[4] || args[5]1234567891011121314151617181920212223242526272829function handleStartTag(match) &#123; var tagName = match.tagName; var unarySlash = match.unarySlash; var unary = isUnaryTag$$1(tagName) || !!unarySlash; var l = match.attrs.length; var attrs = new Array(l); for (var i = 0; i &lt; l; i++) &#123; var args = match.attrs[i]; var value = args[3] || args[4] || args[5] || &#x27;&#x27;; attrs[i] = &#123; name: args[1], value &#125; if (options.outputSourceRange) &#123; attrs[i].start = args.start + args[0].match(/^\\s*/).length; attrs[i].end = args.end; &#125; &#125; // 处理双标签 if (!unary) &#123; stack.push(&#123; tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end &#125;); lastTag = tagName; &#125; if (options.start) &#123; options.start(tagName, attrs, unary, match.start, match.end); &#125;&#125; 可以看到Vue把数据做了处理之后，又把这些数据交给了start钩子处理，我们看看start钩子里面的逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 function createASTElement(tag,attrs,parent) &#123; return &#123; type: 1, tag: tag, attrsList: attrs, attrsMap: makeAttrsMap(attrs), rawAttrsMap: &#123;&#125;, parent: parent, children: [] &#125; &#125;function parse(template,options) &#123; // ...此处省略部分代码 var stack = []; var root; var currentParent; parseHTML(template, &#123; start: function start(tag, attrs, unary, start$1, end)&#123; var element = createASTElement(tag, attrs, currentParent); if (options.outputSourceRange) &#123; element.start = start$1; element.end = end; element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) &#123; cumulated[attr.name] = attr; return cumulated &#125;, &#123;&#125;); &#125; // 处理v-for v-if指令 if (!element.processed) &#123; processFor(element); processIf(element); processOnce(element); &#125; // 解析到的第一个元素 就是根节点 if (!root) &#123; root = element; &#125; // 如果是双标签 那currentParent就指定当前的ast元素，并存到stack栈中 if (!unary) &#123; currentParent = element; stack.push(element); &#125; else &#123; closeElement(element); &#125; &#125;, end: function end() &#123;&#125;, chars: function ()&#123;&#125; &#125;) return root&#125; 其实start钩子内部大致就做了三件事： 根据createASTElement生成一个ast元素，该ast元素也是用来描述开始标签，虽然match也用来描述开始标签，但是JS操作ast元素显然更方便些。 处理开始标签上面的v-if v-for v-once指令 初始化root currentParent stack的值，其中root存储模版的根节点，currentParent指定当前解析到的ast元素，stack存放解析到的所有ast元素下面是开始标签对应ast元素的结构图: 以上就是Vue内部解析开始标签的所有过程了，接下来我们再看看Vue内部如何解析文本的？,根据上面的分析，我们已经知道解析到文本会交给chars钩子处理，我们来看看chars钩子内部的逻辑。 2.解析文本1234567891011121314151617181920212223242526272829303132function parse(template,options) &#123; // ...此处省略部分代码 var stack = []; var root; var currentParent; parseHTML(template, &#123; start: function start()&#123;&#125;, end: function end() &#123;&#125;, // 解析到文本的钩子函数 chars: function (text, start, end)&#123; var children = currentParent.children; var res; var child; // 解析到有插值的文本 if (!inVPre &amp;&amp; text !== &#x27; &#x27; &amp;&amp; (res = parseText(text, delimiters))) &#123; child = &#123; type: 2, expression: res.expression, tokens: res.tokens, text: text &#125;; &#125; else if (text !== &#x27; &#x27; || !children.length || children[children.length - 1].text !== &#x27; &#x27;) &#123; // 解析到没有插值的文本 child = &#123; type: 3, text: text &#125;; &#125; &#125; &#125;) return root&#125; chars钩子内部逻辑很简单，就是区分文本是否有插值符号，有插值符号的话ast对象type标记为2，并解析插值，没有插值就当作普通文本处理ast对象type标记为3。下面是插值文本对应的ast对象 最后我们再看看Vue内部解析结束标签的过程，,根据上面的分析，我们已经知道解析到结束标签会交给parseEndTag函数处理，来看看parseEndTag函数内部的逻辑。大致意思是取出stack栈中的最后一项，并将最后一项的tag，start，end交给end钩子处理 12345678910111213141516171819202122232425262728293031function parseEndTag(tagName, start, end) &#123; var pos, lowerCasedTagName; if (start == null) &#123; start = index; &#125; if (end == null) &#123; end = index; &#125; // Find the closest opened tag of the same type if (tagName) &#123; lowerCasedTagName = tagName.toLowerCase(); for (pos = stack.length - 1; pos &gt;= 0; pos--) &#123; if (stack[pos].lowerCasedTag === lowerCasedTagName) &#123; break &#125; &#125; &#125; else &#123; // If no tag name is provided, clean shop pos = 0; &#125; if (pos &gt;= 0) &#123; // Close all the open elements, up the stack for (var i = stack.length - 1; i &gt;= pos; i--) &#123; if (options.end) &#123; options.end(stack[i].tag, start, end); &#125; &#125; // Remove the open elements from the stack stack.length = pos; lastTag = pos &amp;&amp; stack[pos - 1].tag; &#125; &#125;&#125; 接着看end钩子函数的处理逻辑，大致意思是取出stack栈中最后一项element，接着又使用closeElement来构建elemenet这个ast对象的父子级关系，currentParent又指定stack栈中的最后一项。需要注意的是parse函数里面的stack栈和parseHTML函数里面的stack栈不是一回事，parse函数里面的stack栈中存放的是ast对象，parseHTML函数里面的stack栈存放的是所有开始标签的信息。 1234567891011121314151617181920212223242526272829function parse(template,options) &#123; // ...此处省略部分代码 var stack = []; var root; var currentParent; parseHTML(template, &#123; start: function start()&#123;&#125;, end: function end() &#123; var element = stack[stack.length - 1]; // pop stack stack.length -= 1; currentParent = stack[stack.length - 1]; if (options.outputSourceRange) &#123; element.end = end$1; &#125; closeElement(element); &#125;, // 解析到文本的钩子函数 chars: function ()&#123;&#125; &#125;) return root&#125;// 构建ast对象的父子级关系function closeElement (element)&#123; // 此处省略若干代码 currentParent.children.push(element); element.parent = currentParent;&#125; 最终返回的root根元素就是最终的ast树。以上，就是Vue内部如何把一个html字符串转换成ast树的过程，我们看看ast树的结构,其中包含了父子级关系，if for directives等指令标记，节点自身的相关信息","categories":[],"tags":[]},{"title":"1.  Vue如何构建响应式系统","slug":"vue01","date":"2020-11-21T11:07:30.000Z","updated":"2020-12-02T03:59:04.142Z","comments":true,"path":"2020/11/21/vue01/","link":"","permalink":"http://example.com/2020/11/21/vue01/","excerpt":"","text":"vue2.x版本的响应系统是基于Object.defineProperty实现的，我们看看vue源码的具体代码 123456789101112var Observer = function Observer(value) &#123; this.value = value; this.dep = new Dep(value); this.vmCount = 0; def(value, &#x27;__ob__&#x27;, this); if (Array.isArray(value)) &#123; //构建数组对象的响应式系统 protoAugment(value, arrayMethods); this.observeArray(value); &#125; else &#123; //构建普通对象的响应式系统 this.walk(value); &#125;&#125;; 可以看到在构建响应式系统时，对普通对象和数组对象做了不同的处理，我们先看普通对象是如何构建响应式系统的？ 123456789101112131415161718192021222324252627282930313233343536373839Observer.prototype.walk = function walk(obj) &#123; var keys = Object.keys(obj); for (var i = 0; i &lt; keys.length; i++) &#123; defineReactive$$1(obj, keys[i]); &#125;&#125;;function defineReactive$$1( obj, key, val, customSetter, shallow ) &#123; var dep = new Dep(key); var childOb = !shallow &amp;&amp; observe(val); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; var value = getter ? getter.call(obj) : val; // TODO return value &#125;, set: function reactiveSetter(newVal) &#123; var value = getter ? getter.call(obj) : val; // 老值和新值相等 就终止函数 if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; if (customSetter) &#123; customSetter(); &#125; if (getter &amp;&amp; !setter) &#123; return &#125; if (setter) &#123; setter.call(obj, newVal); &#125; else &#123; val = newVal; &#125; // 劫持新设置的值 childOb = !shallow &amp;&amp; observe(newVal); dep.notify(); &#125; &#125;); &#125; 可以看到构建数据对象data的响应式系统很简单，就是给data的每个key都设置get/set钩子,用户每次获取值的时候例如this.data.msg，都会触发key的get钩子，设置新值的时候例如this.data.msg=&#39;新的msg&#39;，都会触发key的set钩子，Vue在set/get钩子里面做了很多事情，不过这都是后面章节我们才讨论的,不管怎样，普通对象的响应式系统确实是通过 Object.defineProperty这个API很轻易的构建出来了。还有一个问题，平时我们都是this.msg就可以获取data中的msg了，现在这个响应式系统只能通过this.data.msg拿到data中的msg。很显然，这个响应式系统并不完善，我们看看vue源码如何实现更完善的响应式系统的？先是把data数据对象存到_data中，proxy函数的功能就是每次访问vm[key]时都会返回vm._data[key]属性,这样就实现了完善的响应式系统 1234567891011121314151617181920212223function initData(vm) &#123; var data = vm.$options.data; data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125;; var keys = Object.keys(data); var i = keys.length; while (i--) &#123; proxy(vm, &quot;_data&quot;, key); &#125;&#125;// 数据代理function proxy(target, sourceKey, key) &#123; sharedPropertyDefinition.get = function proxyGetter() &#123; return this[sourceKey][key] &#125;; sharedPropertyDefinition.set = function proxySetter(val) &#123; this[sourceKey][key] = val; &#125;; // vm.msg --&gt; vm._data.msg Object.defineProperty(target, key, sharedPropertyDefinition);&#125; 普通对象的响应式系统已经构建完成了，我们接下来再看看数组对象是如何构建响应式系统的？ 123456789101112131415161718var Observer = function Observer(value) &#123; this.value = value; this.dep = new Dep(value); this.vmCount = 0; def(value, &#x27;__ob__&#x27;, this); if (Array.isArray(value)) &#123; protoAugment(value, arrayMethods); this.observeArray(value); &#125; else &#123; this.walk(value); &#125;&#125;;// 修改隐式原型function protoAugment(target, src) &#123; target.__proto__ = src;&#125; 可以看到，当处理数组的时候把数组的隐式原型__proto__指向了arrayMethods,那arrayMethods是什么呢？其实arrayMethods是一个普通对象，其隐式原型指定了Array.prototype,这样的话,在arrayMethods的原型链上就有了数组的所有方法了 123456789101112131415161718192021222324252627282930313233343536373839var arrayProto = Array.prototype;var arrayMethods = Object.create(arrayProto); var methodsToPatch = [ &#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;];methodsToPatch.forEach(function (method) &#123; // 基于原型链获取数组原型上的方法 var original = arrayProto[method]; // 给arrayMethods对象设置method属性 即arrayMethods[&#x27;push&#x27;] = mutator def(arrayMethods, method, function mutator() &#123; var args = [], len = arguments.length; while (len--) args[len] = arguments[len]; var result = original.apply(this, args); var ob = this.__ob__; var inserted; switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args; break case &#x27;splice&#x27;: inserted = args.slice(2); break &#125; if (inserted) &#123; ob.observeArray(inserted); &#125; // notify change ob.dep.notify(); return result &#125;); &#125;); 现在我们看看arrayMethods是什么样子,可以看到它是一个对象，自身有7个key,隐式原型上有所有的数组方法，这样的话，如果我们执行this.list.push(2)，就会沿着原型链找到arrayMethods对象上的push方法执行，即mutator，而mutator内部的逻辑有三个:1.执行Array.prototype的push方法2. 劫持添加的数据再次构建响应式系统3. ob.dep.notify()触发视图更新（后面章节会讲）需要注意的是，对于数组，Vue只为methodsToPatch中的7个方法构建了响应式系统，对于其他的数组方法，Vue并没有构建响应式系统。 以上，就是Vue如何构建响应式系统。","categories":[],"tags":[]},{"title":"浏览器缓存策略","slug":"cache","date":"2020-11-19T15:49:23.000Z","updated":"2020-12-15T12:02:25.945Z","comments":true,"path":"2020/11/19/cache/","link":"","permalink":"http://example.com/2020/11/19/cache/","excerpt":"","text":"当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。1.目录结构如下 2.首页结构1234567891011121314151617&lt;!-- cache.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;data:image/ico;base64,aWNv&quot;&gt; &lt;title&gt;基于node学习浏览器缓存策略&lt;/title&gt; &lt;script src=&quot;/script.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是服务首页&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 3.搭建服务123456789101112// app.jsconst http = require(&#x27;http&#x27;);const fs = require(&#x27;fs&#x27;);http.createServer((request, response) =&gt; &#123; if (request.url === &#x27;/&#x27;) &#123; const readStream = fs.createStream(&#x27;./cache.html&#x27;); readStream.pipe(response) &#125;else if (/\\.js$/.test(request.url)) &#123; const readStream = fs.createReadStream(&#x27;./script.js&#x27;); readStream.pipe(response) &#125;&#125;) 4.强缓存触发浏览器强缓存策略需要后端配置特殊字段Expires/Cache-Control均可，并且返回状态码2001234567891011121314151617http.createServer((request, response) =&gt; &#123; if (request.url === &#x27;/&#x27;) &#123; const readStream = fs.createStream(&#x27;./cache.html&#x27;); readStream.pipe(response) &#125;else if (/\\.js$/.test(request.url)) &#123; // Expires字段设置的时间是固定的某个时间点 // response.writeHead(200, &#123; // &#x27;Expires&#x27;: new Date(&#x27;2020-12-30 12:00:00&#x27;), // &#125;); // Cache-Control字段设置的是相对于本次服务端返回的时间 单位s response.writeHead(200, &#123; &#x27;Cache-Control&#x27;: &#x27;max-age=200&#x27; &#125;); const readStream = fs.createReadStream(&#x27;./script.js&#x27;); readStream.pipe(response) &#125;&#125;) 第一次访问资源命中强缓存之后，浏览器就不会同样的资源发起网络请求了，浏览器会直接强制从memory(内存)/disk(硬盘)中读取资源，如下所示 5.协商缓存触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified/Etag均可，并且返回状态码30412345678910111213141516171819202122232425262728293031323334353637http.createServer((request, response) =&gt; &#123; if (request.url === &#x27;/&#x27;) &#123; const readStream = fs.createStream(&#x27;./cache.html&#x27;); readStream.pipe(response) &#125;else if (/\\.js$/.test(request.url)) &#123; // const buffer = fs.readFileSync(&#x27;./script.js&#x27;); // const fileMd5 = md5(buffer); 文件的md5值 // const noneMatch = request.headers[&#x27;if-none-match&#x27;]; 来自浏览器端传递的值 // 协商成功 状态码返回304 // if (noneMatch === fileMd5) &#123; // response.statusCode = 304; // response.end(); // return; // &#125; // 协商失败 状态码返回200 // response.writeHead(200, &#123; // &#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;, // &#x27;ETag&#x27;: fileMd5, // &#125;); const stat = fs.statSync(&#x27;./script.js&#x27;); const mtime = stat.mtime.toGMTString() const requestMtime = request.headers[&#x27;if-modified-since&#x27;]; // 协商成功 本次服务端不返回资源 让浏览器使用缓存的资源 if (mtime === requestMtime) &#123; response.statusCode = 304; //必须返回304 response.end(); return; &#125; // 协商失败 状态码返回200 response.writeHead(200, &#123; &#x27;Last-Modified&#x27;: mtime, &#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;, // 必须设置，否则下次浏览器请求会命中强缓存 &#125;); const readStream = fs.createReadStream(&#x27;./script.js&#x27;); readStream.pipe(response); &#125;&#125;) 第一次访问资源命中协商缓存之后，浏览器会在下次网络请求中用特殊字段(if-modified-since/if-no-match)携带第一次访问后端时返回的响应头信息，后端在对比前后数据之后，判断资源的内容是否更改，如果更改，就协商失败，返回最新的资源给浏览器，如果没有更改，就协商成功，不返回数据给浏览器，浏览器最终使用缓存的资源 6.强缓存和协商缓存对比6.1 强缓存优先级比协商缓存高，因为浏览器总是倾向于请求更少的资源，命中强缓存后，浏览器都不会向后端请求资源了，所以强缓存优先级比协商缓存高6.2 判断是否命中强缓存的纬度是时间，Expires是固定时间，Cache-Control是相对时间 ;判断是否命中协商缓存的纬度是资源内容是否被更改，Last-Modified是用资源的修改时间，Etag是用资源的hash值","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-11-16T16:51:19.875Z","updated":"2020-11-19T15:35:10.620Z","comments":true,"path":"2020/11/17/hello-world/","link":"","permalink":"http://example.com/2020/11/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}