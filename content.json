{"meta":{"title":"Hexo","subtitle":"","description":"","author":"heaven","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"自定义打包器","slug":"minipack","date":"2021-02-06T12:03:34.000Z","updated":"2021-02-19T12:56:33.718Z","comments":true,"path":"2021/02/06/minipack/","link":"","permalink":"http://example.com/2021/02/06/minipack/","excerpt":"","text":"目录结构 createAsset 打包静态资源使用@babel/parser @babel/traverse @babel/core这些模块打包静态资源，其中作用如下: @babel/parser的作用是：将字符串转化成ast对象。 @babel/traverse的作用是：在转换ast对象的过程中，遇到import就把node.source.value放到dependencies中去，dependencies是专门存放依赖模块的相对路径，ImportDeclaration是解析到import字段就会触发的钩子函数。 @babel/core的作用是：将ast对象转换成可执行的 es5 代码。 123456789101112131415161718192021222324252627let id = 0;const fs = require(&quot;fs&quot;);const babelParser = require(&quot;@babel/parser&quot;);const &#123; transformFromAst &#125; = require(&quot;@babel/core&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;function createAsset(filename) &#123; const content = fs.readFileSync(filename, &quot;utf-8&quot;); const ast = babelParser.parse(content, &#123; sourceType: &quot;module&quot;, &#125;); const dependencies = []; traverse(ast, &#123; // 遍历所有的 import 模块，并将相对路径放入 dependencies ImportDeclaration: (&#123; node &#125;) =&gt; &#123; dependencies.push(node.source.value); &#125;, &#125;); const &#123; code &#125; = transformFromAst(ast, null, &#123; presets: [&quot;@babel/preset-env&quot;], &#125;); return &#123; code, dependencies, filename, id: id++, &#125;;&#125; createGraph 构建依赖图先打包 12345678910111213141516171819202122const config = require(&quot;./minipack.config&quot;);const entry = config.entry;const mainAsset = createAsset(entry);const graph = &#123; [entry]: mainAsset,&#125;;function createGraph(filename, asset) &#123; asset.mapping = &#123;&#125;; const dirname = path.dirname(filename); asset.dependencies.forEach((relativePath) =&gt; &#123; const absolutePath = path.resolve(dirname, relativePath); asset.mapping[relativePath] = absolutePath; if (!graph[absolutePath]) &#123; const child = createAsset(absolutePath); graph[absolutePath] = child; if (child.dependencies.length &gt; 0) &#123; createGraph(absolutePath, child); &#125; &#125; &#125;);&#125;createGraph(entry, mainAsset); bundle 打包获得依赖图之后，就可以基于依赖图打包成一个独立的文件了。 123456789101112131415161718192021222324252627282930313233function bundle(graph) &#123; let modules = &quot;&quot;; for (let filename in graph) &#123; let mod = graph[filename]; modules += `&#x27;$&#123;filename&#125;&#x27;: [ function(require, module, exports) &#123; $&#123;mod.code&#125; &#125;, $&#123;JSON.stringify(mod.mapping)&#125;, ],`; &#125; const result = ` (function(modules) &#123; function require(moduleId) &#123; const [fn, mapping] = modules[moduleId] function localRequire(name) &#123; return require(mapping[name]) &#125; const module = &#123;exports: &#123;&#125;&#125; fn(localRequire, module, module.exports) return module.exports &#125; require(&#x27;$&#123;entry&#125;&#x27;) &#125;)(&#123;$&#123;modules&#125;&#125;)`; return result;&#125;const result = bundle(graph);const dist = path.join(output.path, output.filename);fs.writeFile(dist, result, (err) =&gt; &#123; if (err) throw err; console.log(&quot;文件已经被打包&quot;);&#125;);","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"vue.config.js的常用配置","slug":"vue-config-js","date":"2021-01-11T13:21:01.000Z","updated":"2021-02-06T12:03:15.351Z","comments":true,"path":"2021/01/11/vue-config-js/","link":"","permalink":"http://example.com/2021/01/11/vue-config-js/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const path = require(&quot;path&quot;);const CompressionWebpackPlugin = require(&quot;compression-webpack-plugin&quot;);const &#123; BundleAnalyzerPlugin &#125; = require(&quot;webpack-bundle-analyzer&quot;);const isProduction = process.env.NODE_ENV === &quot;production&quot;;module.exports = &#123; productionSourceMap: isProduction ? false : true chainWebpack: config =&gt; &#123; // 定义文件夹的路径 config.resolve.alias .set(&#x27;@&#x27;, resolve(&#x27;src&#x27;)) .set(&#x27;@assets&#x27;, resolve(&#x27;src/assets&#x27;)) .set(&#x27;@components&#x27;, resolve(&#x27;src/components&#x27;)) .set(&#x27;@router&#x27;, resolve(&#x27;src/router&#x27;)) .set(&#x27;@store&#x27;, resolve(&#x27;src/store&#x27;)) .set(&#x27;@views&#x27;, resolve(&#x27;src/views&#x27;)) // 压缩图片 小于limit压缩成base64 const imagesRule = config.module.rule(&#x27;images&#x27;) imagesRule.uses.clear() imagesRule.use(&#x27;file-loader&#x27;) .loader(&#x27;url-loader&#x27;) .options(&#123; limit: 1024, fallback: &#123; loader: &#x27;file-loader&#x27; &#125; &#125;) &#125;, // webpack的配置 configureWebpack: config =&gt; &#123; // 第三方模块不放到打包文件 config.externals = &#123; jquery: &quot;jQuery&quot;, axios: &#x27;axios&#x27; &#125; // 生产环境配置 if (isProduction) &#123; // 线上去除console等信息 config.optimization.minimizer[0].options.terserOptions.compress.drop_console = true; config.optimization.minimizer[0].options.terserOptions.compress.drop_debugger = true; config.optimization.minimizer[0].options.terserOptions.compress.pure_funcs = [ &quot;console.log&quot; ]; &#125; // 开启gzip压缩 const productionGzipExtensions = /\\.(js|css|json|txt|html|ico|svg)(\\?.*)?$/i; config.plugins.push( new CompressionWebpackPlugin(&#123; filename: &quot;[path].gz[query]&quot;, algorithm: &quot;gzip&quot;, test: productionGzipExtensions, threshold: 10240, minRatio: 0.8 &#125;) ); &#125;, // 全局引入less 变量 函数 pluginOptions: &#123; &quot;style-resources-loader&quot;: &#123; preProcessor: &quot;less&quot;, patterns: [ path.resolve(__dirname, &quot;src/style/_variables.less&quot;), path.resolve(__dirname, &quot;src/style/_mixin.less&quot;) ] &#125; &#125;, // 需要gzip压缩的文件 devServer: &#123; host: &#x27;localhost&#x27;, port: 8080, // 端口号 open: false, // 配置自动启动浏览器 &#125;&#125;;","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"自定义脚手架","slug":"cli","date":"2021-01-10T12:03:24.000Z","updated":"2021-01-15T12:32:41.790Z","comments":true,"path":"2021/01/10/cli/","link":"","permalink":"http://example.com/2021/01/10/cli/","excerpt":"","text":"随着前端工程化的发展，前端领域出现了很多脚手架工具，例如vue-cli，create-react-app， create-vite-app等。这类脚手架工具可以帮我们快速搭建项目的初始结构，减少人肉操作，之前我们都是使用别人写的脚手架工具，今天我们就制作自己的脚手架工具。 commandercommander是npm上非常流程的自定义命令行工具包，我们可以通过这个包在终端上输入自己创建的指令来控制程序的执行。vue-cli，create-react-app， create-vite-app这些脚手架工具也是使用了commander,https://github.com/tj/commander.js 这个地址里有commander的详细用法，本篇文章就不详细介绍了。除了commander之外，我们还需要download-git-repo，ejs，chalk这些第三方模块。初始的项目模版如下： 对于vue-cli，这类脚手架，我们会通过vue -V来用脚手架的版本，同样的，对于我们的脚手架也需要配置一个指令来查看版本，所以我们在pageage.json中配置heaven这个bin指令，其作用就是可以在终端中全局使用heaven指令。当然只是在pageage.json中配置还不够。还需要通过npm link把 heaven指令放到/usr/local/bin 中。效果如下，至于heaven -V如何查看版本，这个就需要借助commander了。 index.js在index.js中引入了自定义模块createCommands，该模块存放了我们创建的指令 1234567891011// index.js#!/usr/bin/env nodeconst program = require(&#x27;commander&#x27;)const &#123; createCommands &#125; = require(&#x27;./lib/core/create&#x27;)// 定义版本program.version(require(&#x27;./package.json&#x27;).version);// 自定义指令createCommands()// 解析指令program.parse(process.argv); 创建指令在createCommands.js这个模块中，我们创建了三个指令： heaven create 项目名，一旦执行该指令就会触发createProject回调 heaven addC 组件名，一旦执行该指令就会触发createComponent回调 heaven addP 页面名，一旦执行该指令就会触发createPage回调 123456789101112131415161718192021222324252627// createCommands.jsconst program = require(&#x27;commander&#x27;)const &#123; createProject, createComponent, createPage &#125; = require(&#x27;./actions&#x27;)function createCommands() &#123; program .command(&#x27;create &lt;project&gt;&#x27;) .description(&#x27;clone clone a repository into a newly created directory&#x27;) .action(createProject) program .command(&#x27;addC &lt;name&gt;&#x27;) .description(&#x27;create a component&#x27;) .action(name =&gt; &#123; createComponent(name, name.toLowerCase()) &#125;) program .command(&#x27;addP &lt;name&gt;&#x27;) .description(&#x27;create a page&#x27;) .action(name =&gt; &#123; createPage(name, name.toLowerCase()) &#125;)&#125;module.exports = &#123; createCommands&#125; createProject其实heaven create 项目名这个指令就是模拟vue create 项目名这个指令，当我们执行vue create 项目名时，需要等好久，其实这些等待的时间就是在下载脚手架的初始模版，所以同样的heaven create 项目名这个指令，也需要下载初始模版。理解了这个，再看createProject内部的逻辑就很清晰了： 定义下载等待时的提示信息 下载初始模版，这时需要用download-git-repo来下载，我的项目模版放在了https://github.com/840979094/vue-temp.git 执行npm install，该指令的作用是下载好项目模版后，直接安装项目依赖 执行npm run serve，该指令的作用是安装好项目依赖后，直接运行项目 值得注意的是，npm install，npm run serve这俩指令都是运行在node的内置核心模块child_process单独开辟的子进程中。 123456789101112131415161718192021222324252627282930313233343536373839404142const &#123; promisify &#125; = require(&#x27;util&#x27;);const &#123; resolve &#125; = require(&#x27;path&#x27;)const downloadRepo = promisify(require(&#x27;download-git-repo&#x27;))const &#123; hint &#125; = require(&#x27;../utils/log&#x27;)const terminal = require(&#x27;../utils/terminal&#x27;);const &#123; ejsComplier, mkdirSync, writeFile &#125; = require(&#x27;../utils/file&#x27;)const &#123; remoteRepo &#125; = require(&#x27;../utils/constants&#x27;)async function createProject(project) &#123; // 1.下载提示 hint(&#x27;heaven_cli helps you create your project, please wait a moment~~~&#x27;) // 2.clone远程仓库的代码 await downloadRepo(remoteRepo, project, &#123; clone: true &#125;) // 3.执行终端命令npm install const npm = process.platform === &#x27;win32&#x27; ? &#x27;npm.cmd&#x27; : &#x27;npm&#x27;; await terminal.spawn(npm, [&#x27;install&#x27;], &#123; cwd: `./$&#123;project&#125;` &#125;); // 4.运行项目 await terminal.spawn(npm, [&#x27;run&#x27;, &#x27;serve&#x27;], &#123; cwd: `./$&#123;project&#125;` &#125;);&#125;// utils/log.jsconst chalk = require(&#x27;chalk&#x27;);function hint() &#123; console.log(chalk.blue(...arguments))&#125;function error() &#123; console.log(chalk.red(...arguments))&#125;// utils/terminal.jsconst &#123; spawn &#125; = require(&#x27;child_process&#x27;);const spawnCommand = (...args) =&gt; &#123; return new Promise((resovle, reject) =&gt; &#123; const childProcess = spawn(...args); childProcess.stdout.pipe(process.stdout); childProcess.stderr.pipe(process.stderr); childProcess.on(&#x27;close&#x27;, resovle) &#125;)&#125;// utils/constant.js 项目模版地址const remoteRepo = &quot;direct:https://github.com/840979094/vue-temp.git&quot;; createComponent一般情况下，在创建组件时，我们会有两个手动操作： 新建组件文件夹 新建组件对应的单文件组件而heaven addC 组件名这个指令就能够自动执行这两步操作，假定终端执行heaven addC helloworld指令，我们来看看createComponent内部的逻辑： 创建src/components/helloworld文件夹 使用ejs来编译component.ejs模版，并注入变量 将编译好的结果，写入到src/components/helloworld/helloworld.vue中这样，当我们执行heaven addC helloworld，就会自动创建组件文件夹&amp;单文件组件了。 123456789101112131415161718192021222324252627282930// 创建组件async function createComponent(name, dest) &#123; const dirname = resolve(process.cwd(), &quot;src/components&quot;, dest) mkdirSync(dirname) const templatePath = resolve(__dirname, &#x27;../template/component.ejs&#x27;) const result = await ejsComplier(templatePath, &#123; name &#125;) writeFile(resolve(dirname, `$&#123;name&#125;.vue`), result)&#125;// file.jsconst ejsComplier = function (path, data) &#123; return new Promise((resolve, reject) =&gt; &#123; ejs.renderFile(path, data, function (err, result) &#123; err ? reject(err) : resolve(result) &#125;) &#125;)&#125;const mkdirSync = (dirname) =&gt; &#123; if (fs.existsSync(dirname)) &#123; return true &#125; else &#123; // 不存在,判断父亲文件夹是否存在？ if (mkdirSync(path.dirname(dirname))) &#123; //父级文件夹存在 那就创建子文件夹 fs.mkdirSync(dirname) return true &#125; &#125;&#125; 上面用到的component.ejs模版如下，我们这里用的是ts模版，当然你也可以使用js模版。 createPage一般情况下，在创建页面时，我们会有三个手动操作： 新建页面文件夹 新建页面对应的单文件组件 在router.js中把创建的页面添加到路由配置表中而heaven addP 页面名这个指令就能够自动执行这三步操作，假定终端执行heaven addP home指令，我们来看看createPage内部的逻辑： 创建src/pages/home文件夹 使用ejs来编译component.ejs模版，并注入变量 将编译好的结果，写入到src/page/home/home.vue中 使用ejs来编译router.ejs模版，并注入变量 将编译好的结果，写入到src/router/home.js中 这样，当我们执行heaven addP home，就会自动创建页面文件夹&amp;单文件组件，并且把创建的页面自动添加到路由配置表中。 1234567891011121314async function createPage(name, dest) &#123; // 创建页面对应的文件夹和单文件组件 const pageDirname = resolve(process.cwd(), &quot;src/pages&quot;, dest) mkdirSync(pageDirname) const pagePath = resolve(__dirname, &#x27;../template/component.ejs&#x27;) const pageResult = await ejsComplier(pagePath, &#123; name &#125;) writeFile(resolve(pageDirname, `$&#123;name&#125;.vue`), pageResult) // 把创建的页面 自动添加到路由表中 const routerDirname = resolve(process.cwd(), &quot;src/router&quot;) const routerPath = resolve(__dirname, &#x27;../template/router.ejs&#x27;) const routerResult = await ejsComplier(routerPath, &#123; name &#125;) writeFile(resolve(routerDirname, `$&#123;name&#125;.js`), routerResult)&#125; 上面用到的router.ejs模版如下: 发布到npm这样，其实我们的脚手架基本就可以工作了，接着我们把脚手架发布到npm上，这样谁都可以下载这个脚手架了。 https://www.npmjs.com/login 注册npm账号 终端输入npm login登录npm账号 终端输入npm publish发布 结果如下所示： 项目模版结构如果发布到npm成功，就可以npm i heaven_cli -g让同事下载你的脚手架了。当然这个脚手架使用的项目模版放在了https://github.com/840979094/vue-temp.git，我们再看看这个模版的结构，其中模版的路由配置代码如下: 初始路由配置表routes为空 require.context递归读取router目录下所有的js/ts文件，加载对应的模块并添加到routes中，之所以要把路由分模块管理，是因为随着项目变得越来也大，如果不分模块管理，routes会非常臃肿，不利于项目当维护。require.context的具体用法见https://cn.vuejs.org/v2/guide/components-registration.html#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C 123456789101112131415161718192021222324import Vue from &#x27;vue&#x27;import VueRouter, &#123; RouteConfig &#125; from &#x27;vue-router&#x27;import &#x27;./home&#x27;Vue.use(VueRouter)let routes: RouteConfig[] = []// 自动注入路由记录到routes中const requireCxt = require.context(&quot;./&quot;, true, /.(js|ts)$/)requireCxt.keys().forEach(filename =&gt; &#123; // 如果不是./index 那就处理 if (filename.indexOf(&quot;./index&quot;) !== 0) &#123; const routesModule = requireCxt(filename) routes = [routesModule.default, ...routes] &#125;&#125;)const router = new VueRouter(&#123; mode: &#x27;history&#x27;, base: process.env.BASE_URL, routes&#125;)export default router","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"axios在脚手架中的使用","slug":"axios","date":"2021-01-08T06:24:14.000Z","updated":"2021-01-09T15:28:46.613Z","comments":true,"path":"2021/01/08/axios/","link":"","permalink":"http://example.com/2021/01/08/axios/","excerpt":"","text":"axios是基于ajax封装的promise式请求库，在脚手架中通常会使用axios作为http请求库。通常可以使用以下功能。 拦截请求和响应 自动刷新token 取消请求 拦截请求和响应一般会在请求拦截器中添加loading动画，在响应拦截器中隐藏loading动画和跳转错误页面 1234567891011121314axios.interceptors.request.use((config) =&gt; &#123; Toast.loading(&#x27;加载中...&#x27;) return config&#125;, err =&gt; &#123; return Promise.reject(err)&#125;)axios.interceptors.response.use((response) =&gt; &#123; Toast.hide() return response.data&#125;, err =&gt; &#123; my.redirectTo(&#123; url: &#x27;/pages/error/error&#x27; &#125;) return Promise.reject(err)&#125;) 自动刷新token一般情况下会请求token来记录用户的登录状态，但是token会有过期时间，这时候我们可以在响应拦截器中。 判断token是否过期了（一般后端会返回过期的状态码，假定返回的状态码是ret_code=5007）。 如果token过期了，再次调用请求token的接口即可，请求token后再次调用axios请求业务接口的数据值得注意的是，因为response.config记录着请求的config，所以再次调用axios时传递的url data params method都是业务接口对应的参数。 1234567891011121314151617// ret_code 5007 token超时axios.interceptors.response.use(response =&gt; &#123; const &#123; ret_code &#125; = response.data if (ret_code === 200) &#123; return response.data &#125; else if ( ret_code === 5007 ) &#123; // token超时那就获取token 之后再调用业务接口 return getToken().then(_ =&gt; axios(&#123; url:response.config.url , method: response.config.method, data: response.config.data , params: response.config.params, &#125;)) &#125; &#125;, error =&gt; &#123; return Promise.reject(error)&#125;) 取消请求我们经常会遇到下面的情况，在user页面会请求很多接口，此时请求还在pengding状态，如果这时候我们再次切换home页面，势必会请求新的接口，但是user页面还在pengding状态的接口势必还会继续请求，因为我们没有取消这些请求。理想状态下，我们在切换home页面时，应该要取消user页面还在pengding状态的接口，这样可以减少服务器的压力，也可以释放浏览器网络线程的资源。 取消请求的流程如下: 在请求拦截器中创建请求的cancel函数，并存储到config和cancelTokens中 因为在用户切换home页面时，有些接口可能已经有返回了，所以在响应拦截器中要找到已经返回接口对应的cancel函数，并从```cancelTokens``删除， 在用户切换home页面时，在前置钩子beforeEach中，执行cancelTokens里所有的cancel函数执行，就可以取消所有还在pending状态的接口。 123456789101112131415161718192021222324252627282930313233const CancelToken = axios.CancelToken;let cancel = nulllet cancelTokens = []axios.interceptors.request.use(config =&gt; &#123; config.cancelToken = new CancelToken(c =&gt; cancel = c) config.cancel = cancel cancelTokens.push(cancel) return config&#125;, err =&gt; &#123; return Promise.reject(err)&#125;)axios.interceptors.response.use(response =&gt; &#123; const index = cancelTokens.indexOf(response.config.cancel) cancelTokens.splice(index, 1) return response.data&#125;, err =&gt; &#123;// 用户取消 if (axios.isCancel(err)) &#123; return new Promise(() =&gt; &#123; &#125;) &#125; else &#123;// 请求错误 return Promise.reject(err) &#125;&#125;)// 清空cancelTokensrouter.beforeEach((to, from, next) =&gt; &#123; while (cancelTokens.length) &#123; let currentCancel = cancelTokens.pop() currentCancel() &#125; next()&#125;) 上述代码实现的效果如下： 优化try/catch这一点其实和axios本身没有关系，只是对 async函数写法的优化。 一般情况下async函数内部是无法捕获失败的promise,如果await后面是个失败的promise，就会阻塞await下面代码的执行，见场景1。 在await后面的promise包一层try/catch,这样失败的promise就会被catch捕获，这样就不会影响下面代码的执行了，见场景2，这样虽然可以解决问题，但是却多了一层代码嵌套，让代码看上去不是很优雅。 定义工具函数promiseWrapper，并且接受一个promise作为参数，，promiseWrapper函数返回一个promise，其状态总是成功的。其值根据传入promise的状态决定。原则上和node一致，都是错误优先原则。所以以后我们可以把接口都用promiseWrapper包裹，这样就避免了使用try/catch，使得代码更优雅。 12345678910111213141516171819202122232425// 场景1 无法捕获错误 会影响下面代码的执行async function case1() &#123; const res = await Promise.reject(1) console.log(res, 111)&#125;// 场景2 catch可以捕获错误 不会影响下面代码的执行async function case2() &#123; try &#123; const res = await Promise.reject(1) &#125; catch (error) &#123; console.log(error) &#125;&#125;// 场景3 function promiseWrapper(p) &#123; return p.then(res =&gt; [undefined, res]) .catch(err =&gt; [err, undefined])&#125;async function case3() &#123; const [err, res] = await promiseWrapper(Promise.reject(1)) console.log(err, res)&#125;","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"JS面试题","slug":"面试题","date":"2020-12-28T04:58:41.000Z","updated":"2021-01-18T03:00:19.269Z","comments":true,"path":"2020/12/28/面试题/","link":"","permalink":"http://example.com/2020/12/28/%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"JS手写篇call、apply、bind 实现1234567891011121314151617181920212223Function.prototype.myCall = function (obj, ...args) &#123; obj.__proto__.fn = this obj.fn(...args) delete obj.__proto__.fn&#125;Function.prototype.myApply = function (obj, args) &#123; obj.__proto__.fn = this if (Array.isArray(args)) &#123; obj.fn(...args) &#125; else &#123; throw `$&#123;args&#125; is not array` &#125; delete obj.__proto__.fn&#125;Function.prototype.myBind = function (obj, ...outerArgs) &#123; obj.__proto__.fn = this return function (...innerArgs) &#123; obj.fn(...outerArgs, ...innerArgs) delete obj.__proto__.fn &#125;&#125; 模拟new操作符12345function myNew(Fn, ...args) &#123; let obj = Object.create(Fn.prototype) Fn.call(obj, ...args) return obj&#125; 实现防抖和节流函数1234567891011121314151617181920// 防抖:控制函数执行的频率，在规定时间内，只有最后一次触发有效function debounce(fn, delay = 250) &#123; var timer = 0 return function (...args) &#123; clearTimeout(timer) timer = setTimeout(fn.bind(this, ...args), delay) &#125;&#125;// 节流:控制函数执行的频率，在规定时间内，只有第一次触发有效function throttle(fn, delay = 250) &#123; var start = 0 return function (...args) &#123; var now = new Date() if (now - start &gt;= delay) &#123; fn.call(this, ...args) start = now &#125; &#125;&#125; 实现instanceof1234567function myInstanceOf(tem, Fn) &#123; if (typeof tem !== &#x27;object&#x27; || tem === null) return false while (tem = tem.__proto__) &#123; if (tem === Fn.prototype) return true &#125; return false&#125; 实现Object.create12345Object.myCreate = function (tem) &#123; var obj = &#123;&#125; obj.__proto__ = tem return obj&#125; 实现深拷贝12345678910111213function deepClone(obj) &#123; var tem = Array.isArray(obj) ? [] : &#123;&#125; for (var key in obj) &#123; if (typeof obj[key] !== &#x27;object&#x27; || obj[key] === null) &#123; tem[key] = obj[key] &#125; else &#123; tem[key] = arguments.callee(obj[key]) &#125; &#125; return tem&#125;let obj = &#123;name:&#x27;heaven&#x27;&#125;let deepObj = deepClone(&#123;name:&#x27;heaven&#x27;&#125;) 数组高级方法实现123456789101112131415161718192021222324252627282930313233343536373839404142Array.prototype.myFilter = function (fn) &#123; var arr = [] for (var i = 0; i &lt; this.length; i++) &#123; if (fn(this[i], i, this)) &#123; arr.push(this[i]) &#125; &#125; return arr&#125;Array.prototype.myEvery = function (fn) &#123; for (var i = 0; i &lt; this.length; i++) &#123; if (!fn(this[i], i, this)) &#123; return false &#125; &#125; return true&#125;Array.prototype.mySome = function (fn) &#123; for (var i = 0; i &lt; this.length; i++) &#123; if (fn(this[i], i, this)) &#123; return true &#125; &#125; return false&#125;// 待优化Array.prototype.myReduce = function (fn, initial) &#123; var tem = [null, 0, false, &#x27;&#x27;, NaN] if (initial || tem.includes(initial)) &#123; for (var i = 0; i &lt; this.length; i++) &#123; var res = fn(i === 0 ? initial : res, this[i], i) &#125; &#125; else &#123; for (var i = 1; i &lt; this.length; i++) &#123; var res = fn(i === 1 ? this[i - 1] : res, this[i], i) &#125; &#125; return res&#125; 实现promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104class MyPromise &#123; constructor(exectue) &#123; if (typeof exectue !== &#x27;function&#x27;) throw `$&#123;exectue&#125; is not a function` this.status = &#x27;pending&#x27; this.result = undefined this.tasks = [] function resolve(res) &#123; if (this.status !== &quot;pending&quot;) return this.status = &#x27;resolved&#x27; this.result = res queueMicrotask(() =&gt; &#123; let item = null while (item = this.tasks.shift()) item.res() &#125;) &#125; function reject(err) &#123; if (this.status !== &quot;pending&quot;) return this.status = &#x27;rejected&#x27; this.result = err queueMicrotask(() =&gt; &#123; let item = null while (item = this.tasks.shift()) item.rej() &#125;) &#125; exectue(resolve.bind(this), reject.bind(this)) &#125; then(resCb, rejCb) &#123; return new MyPromise((res, rej) =&gt; &#123; this.tasks.push(&#123; res () &#123; resCb &amp;&amp; handle(resCb) &#125;, rej () &#123; rejCb &amp;&amp; handle(rejCb) &#125; &#125;) // then返回的promise状态 只由回调函数的返回值决定 let handle = callback =&gt; &#123; let result = callback(this.result) if (result instanceof MyPromise) &#123; result.then(res, rej) &#125; else &#123; res(result) &#125; &#125; &#125;) &#125; catch(rejCb) &#123; return this.then(undefined, rejCb) &#125; finally(cb) &#123; return this.then(cb, cb) &#125; // 返回最先有结果的promise 失败/成功都可以 static race(promises) &#123; return new MyPromise(function (resolve, reject) &#123; promises.forEach(p =&gt; p.then(resolve, reject)) &#125;) &#125; // 返回最先成功的promise static any(promises) &#123; return new MyPromise(function (resolve, reject) &#123; promises.forEach(p =&gt; p.then(resolve, undefined)) &#125;) &#125; // 所有都成功 才返回成功的promise 一个失败就返回失败的promise 写法待优化 static all(promises) &#123; let arr = [] let idx = 0 return new MyPromise(function (resolve, reject) &#123; promises.forEach((p, index) =&gt; &#123; p.then(res =&gt; &#123; arr[index] = res if (++idx === promises.length) resolve(arr) &#125;, reject) &#125;) &#125;) &#125; // 必然返回成功的promise 写法待优化 static allSettled(promises) &#123; let arr = [] let idx = 0 return new MyPromise(function (resolve, reject) &#123; promises.forEach((p, index) =&gt; &#123; p.then(res =&gt; &#123; arr[index] = &#123; status: p.status, value: res &#125; if (++idx === promises.length) resolve(arr) &#125;, err =&gt; &#123; arr[index] = &#123; status: p.status, reason: err &#125; if (++idx === promises.length) resolve(arr) &#125;) &#125;) &#125;) &#125;&#125; 实现async/await123456789101112131415161718192021222324function myAsync(generator) &#123; const gen = generator(); const handle = res =&gt; &#123; let &#123; value, done &#125; = res // generator函数结束 需要包装成promise if (done) return Promise.resolve(value) value = value instanceof Promise ? value : Promise.resolve(value) return value .then(result =&gt; handle(gen.next(result))) .catch(e =&gt; gen.throw(e)); &#125;; return handle(gen.next());&#125;function* test() &#123; const a = yield Promise.resolve(1); const b = yield Promise.resolve(a + 10); const d = yield &#x27;2131232&#x27; const c = yield Promise.resolve(b + 100); console.log(a, b, c, d); return &#x27;12312&#x27;&#125;myAsync(test); JS基础篇运算符优先级运算符优先级可参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence 1234var a = &#123; n: 1 &#125; //a-&gt;地址1var b = a //b-&gt;地址1a.x = a = &#123; n: 2 &#125; //地址1.x = a-&gt;地址2console.log(a.x) //地址2.x var a = 1 + 2该式中有= +两个运算符，运算结果为3，说明+的优先级高于=a.x = a = &#123; n: 2 &#125;该式中有. = =三个运算符，其中.运算符优先级高于= 12345678910111213141516function foo() &#123; getName = function () &#123; console.log(1); &#125;; return this;&#125;foo.getName = function () &#123; console.log(2); &#125;;foo.prototype.getName = function () &#123; console.log(3); &#125;;var getName = function () &#123; console.log(4); &#125;;function getName() &#123; console.log(5); &#125;foo.getName();getName();foo().getName();getName();new foo.getName(); new foo().getName(); new new foo().getName(); 宏任务&amp;微任务以下代码的输入顺序? 1234567891011121314151617181920212223242526272829303132Promise.resolve() .then(() =&gt; &#123; console.log(&#x27;回调1&#x27;) Promise.resolve() .then(() =&gt; &#123; console.log(&#x27;回调2&#x27;) return &#x27;then1&#x27; &#125;).then(() =&gt; &#123; console.log(&#x27;回调3&#x27;) &#125;).then(() =&gt; &#123; console.log(&quot;回调4&quot;) &#125;); return &#x27;then&#x27; &#125;) .then(() =&gt; &#123; console.log(&quot;回调5&quot;) Promise.resolve() .then(() =&gt; &#123; console.log(&quot;回调6&quot;) Promise.resolve() .then(() =&gt; &#123; console.log(&quot;回调7&quot;) &#125;).then(() =&gt; &#123; console.log(&quot;回调8&quot;) &#125;) &#125;).then(() =&gt; &#123; console.log(&quot;回调9&quot;) &#125;) &#125;).then(() =&gt; &#123; console.log(&quot;回调10&quot;) &#125;)console.log(&#x27;同步代码&#x27;) 解析如下:","categories":[{"name":"面试题","slug":"面试题","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"vite实现原理","slug":"vite实现原理","date":"2020-12-25T04:50:55.000Z","updated":"2021-02-19T07:42:35.145Z","comments":true,"path":"2020/12/25/vite实现原理/","link":"","permalink":"http://example.com/2020/12/25/vite%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"ESModule 的特点网络请求ESModule 是js在浏览器端的模块化规范，其实在该规范下，浏览器会自动向依赖的模块发起请求，代码如下： type=module表示该脚本支持ESModule规范. 依赖两个模块a,b，因为脚本依赖这两个模块，所以浏览器必然会发送网络请求，如下图所示： 123&lt;script type=&quot;module&quot;&gt; import &#123;a&#125; from &#x27;./a.js&#x27; import &#123;b&#125; from &#x27;./b.js&#x27;&lt;/script&gt; 异步加载当然，除了会发送网络请求之外，ESModule还可以让某个模块异步加载(按需加载)，代码如下，具体如下图所示。 1234567&lt;button id=&#x27;btn&#x27;&gt;按钮&lt;/button&gt;&lt;script type=&quot;module&quot;&gt;let btn = document.getElementById(&#x27;btn&#x27;)btn.addEventListener(&#x27;click&#x27;, function () &#123; import(&#x27;./a.js&#x27;).then(console.log)&#125;)&lt;/script&gt; vite &amp; create-vite-app尤大专门为Vue3配套了vite这个打包工具，如果要使用vite来创建项目，需要安装create-vite-app这个脚手架，如何使用这个脚手架创建项目，可以参考这个文章https://juejin.cn/post/6910014283707318279 里面有详细的步骤。通过脚手架创建的目录结构如下图： 其中，dev/build指令是用vite做开发/生产环境的打包。server指令是我们自己配置的指令，如果通过该指令，可以对项目进行开发环境的打包，那我们的目标就实现了。当然这是后面要做的事情了，接下来先看看index.html和main.js index.html 可以看到在index.html中script脚本启动了ESModule模块化规范，入口文件是main.js main.js 可以看到在main.js中，加载了三个模块，分别是vue App.vue index.css，所以浏览器必然会对这三个模块发起网络请求，接下来vite会怎么处理呢，这个就需要了解vite的实现原理了。 vite 原理其实vite的原理就是基于浏览器在加载模块时会发起网络请求来实现的，我们可以试着仿写下，大致流程如下： 用express启动 web 服务器，我们的端口启动在 3006 后端拦截所有浏览器请求的模块，并返回加载的模块对应的资源，其中包括 index.html/main.js/第三方模块/单文件组件/css 文件 拦截首页，返回index.html 在index.html中加载了main.js,所以我们也拦截该请求，值得注意的是，vite并不是原样返回main.js，而是会对main.js中的第三方模块例如vue加上 /modules/，所以我们也需要做vite类似的处理，handleImport就是这个作用。 123456789101112131415161718192021222324252627282930313233343536373839const express = require(&quot;express&quot;);const app = express();const fs = require(&quot;fs&quot;);const &#123; resolve &#125; = require(&quot;path&quot;);// 拦截首页 返回index.htmlapp.get(&quot;/&quot;, function (req, res) &#123; const pathname = resolve(__dirname, &quot;./index.html&quot;); fs.readFile(pathname, &quot;utf-8&quot;, function (err, data) &#123; if (err) return; // 没有会报错，这个可以自行测试 data = data.replace( &quot;&lt;script&quot;, ` &lt;script&gt; process = &#123; env:&#123;&#125; &#125; &lt;/script&gt; &lt;script ` ); res.send(data); &#125;);&#125;);// 拦截首页 返回main.jsapp.get(/main.js/, function (req, res) &#123; const pathname = resolve(__dirname, `.$&#123;req.url&#125;`); res.header(&quot;Content-Type&quot;, &quot;application/x-javascript&quot;); fs.readFile(pathname, &quot;utf-8&quot;, function (err, data) &#123; if (err) return; res.send(handleImport(data)); &#125;);&#125;);function handleImport(source) &#123; const reg = /(from\\s+[&#x27;&quot;])(?![\\.\\/])/g; return source.replace(reg, ($0, $1) =&gt; `$&#123;$1&#125;/@modules/`);&#125; 拦截第三方模块因为main.js依赖了vue这个第三方模块，所以浏览器必然会发起网络请求，我们也拦截第三方模块，并返回第三方模块对应的资源。值得注意的是第三方模块需要从node_modules读取并返回。读取顺序如下，找到文件夹vue,package.json中的module字段对应的资源路径就是浏览器要加载的vue源码。 1234567891011121314151617// 解析第三方模块app.get(/^\\/@modules/, function (req, res) &#123; // vue模块所在文件夹 const prefix = resolve( __dirname, `./node_modules/`, req.url.replace(/\\/@modules\\//, &quot;&quot;) ); const module = require(resolve(prefix, &quot;package.json&quot;)).module; // 浏览器加载的vue源码 const pathname = resolve(prefix, module); res.header(&quot;Content-Type&quot;, &quot;application/x-javascript&quot;); fs.readFile(pathname, &quot;utf-8&quot;, function (err, data) &#123; if (err) return; res.send(handleImport(data)); &#125;);&#125;); 拦截单文件组件在main.js还依赖了App.vue这个单文件组件，所以浏览器必然会发起网络请求，我们也要拦截该模块，并返回对应的资源，值得注意的是， 对于App.vue，vite会用@vue/compiler-sfc包来解析单文件组件并返回数据，返回数据再次依赖了/src/App.vue?type=template(见 if) 当浏览器处理返回的数据时，会再次发起网络请求/src/App.vue?type=template,所以我们还需要拦截这个请求(见 else)，再使用@vue/compiler-dom包来把组件的模版template转成render函数。 123456789101112131415161718192021222324252627282930313233const compilersfc = require(&quot;@vue/compiler-sfc&quot;); // 解析单文件组件const compilerDom = require(&quot;@vue/compiler-dom&quot;); // template --&gt;render// 解析单文件组件app.get(/\\.vue/, function (req, res) &#123; const &#123; type &#125; = req.query; const url = req.url.split(&quot;?&quot;)[0]; res.header(&quot;Content-Type&quot;, &quot;application/x-javascript&quot;); const pathname = resolve(__dirname, `.$&#123;url&#125;`); fs.readFile(pathname, &quot;utf-8&quot;, function (err, data) &#123; if (err) return; // 解析单文件组件 const &#123; descriptor &#125; = compilersfc.parse(data); if (!type) &#123; const content = handleImport( descriptor.script.content.replace( &quot;export default &quot;, &quot;const __script = &quot; ) ); res.send(` $&#123;content&#125; import &#123;render as __render&#125; from &#x27;$&#123;url&#125;?type=template&#x27; __script.render = __render export default __script `); &#125; else if (type === &quot;template&quot;) &#123; const &#123; content &#125; = descriptor.template; // 编译template模版 转成render函数 const render = compilerDom.compile(content, &#123; mode: &quot;module&quot; &#125;).code; res.send(handleImport(render)); &#125; &#125;);&#125;); 拦截 css 文件在main.js还依赖了index.css这个 css 文件，所以浏览器必然会发起网络请求，我们也要拦截该模块，并返回对应的资源,处理也比较简单，创建style标签即可。 12345678910111213app.get(/\\.css/, function (req, res, next) &#123; const pathname = resolve(__dirname, `.$&#123;req.url&#125;`); res.header(&quot;Content-Type&quot;, &quot;application/x-javascript&quot;); fs.readFile(pathname, function (err, data) &#123; if (err) return; res.send(` let link = document.createElement(&#x27;style&#x27;) link.innerHTML = &#x27;$&#123;data.toString().replace(/\\n/g, &quot;&quot;)&#125;&#x27; link.setAttribute(&#x27;type&#x27;,&#x27;text/css&#x27;) document.head.appendChild(link) `); &#125;);&#125;); 至此，我们已经实现的vite已经可以处理第三方模块/单文件组件/css 文件了，基本上可以满足使用了，我们运行server指令的结果如下：","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"7. Vue的组件系统","slug":"vue07","date":"2020-12-20T13:21:09.000Z","updated":"2021-01-08T06:13:22.424Z","comments":true,"path":"2020/12/20/vue07/","link":"","permalink":"http://example.com/2020/12/20/vue07/","excerpt":"","text":"之前我们讨论的模版都是没有使用组件的，不过我们在开发中，经常会在模版中使用组件的，接下来我们看看在模版中使用组件，Vue内部是如何处理的？假定模版如下所示：在模版中使用了全局组件global-component，局部组件local-component。 1234 &lt;div id=&#x27;app&#x27;&gt; &lt;global-component&gt;&lt;/global-component&gt; &lt;local-component&gt;&lt;/local-component&gt;&lt;/div&gt; 12345678910111213141516171819 Vue.component(&#x27;global-component&#x27;, &#123; data: function () &#123; return &#123; count: 0, msg: &quot;全局组件&quot; &#125; &#125;, template: &#x27;&lt;button v-on:click=&quot;count++&quot;&gt;&#123;&#123;msg&#125;&#125;count:&#123;&#123; count &#125;&#125;&lt;/button&gt;&#x27;&#125;)const LocalComponent = &#123; data: function () &#123; return &#123; count: 0, msg: &quot;局部组件&quot; &#125; &#125;, template: &#x27;&lt;button v-on:click=&quot;count++&quot;&gt;&#123;&#123;msg&#125;&#125;count:&#123;&#123; count &#125;&#125;&lt;/button&gt;&#x27;&#125; 编译组件在模版中里引入了两个组件之后，Vue内部依旧会走模版转render函数的流程，如下所示，下面三张图分别对应： 模版转成AST树 AST树转可执行代码 可执行代码转render函数 其实，不管在模版里面有没有组件，转成render函数的流程都是一样的。如果模版里面有组件的话，也会把组件当作普通的html标签处理。 挂载组件当把模版转成render函数之后，依旧会执行mountComponent函数走挂载组件的流程，接着是创建渲染watcher，并且触发渲染watcher的求值函数updateComponent，updateComponent的逻辑如下： vm._render()创建虚拟dom，并收集依赖 vm._update()基于虚拟dom创建真实dom 区分原生标签/组件对于上面的render函数，会使用_c(&#39;global-component&#39;)来创建组件的虚拟dom，我们看看Vue内部是如何创建组件的虚拟dom？可以看到，在_createElement内部分别处理了原生html标签和自定义组件，其中使用new VNode()创建html标签的虚拟dom，使用createComponent创建组件的虚拟dom。 123456789101112131415161718192021222324252627282930313233343536function _createElement(context,tag,data,children,normalizationType) &#123; if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children); &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children); &#125; var vnode; if (typeof tag === &#x27;string&#x27;) &#123; var Ctor; if (config.isReservedTag(tag)) &#123; // platform built-in elements vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ); &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, &#x27;components&#x27;, tag))) &#123; // component vnode = createComponent(Ctor, data, context, children, tag); &#125; &#125; return vnode&#125;function resolveAsset(options,type,id,warnMissing) &#123; var assets = options[type]; if (hasOwn(assets, id)) &#123; return assets[id] &#125; var camelizedId = camelize(id); if (hasOwn(assets, camelizedId)) &#123; return assets[camelizedId] &#125; var PascalCaseId = capitalize(camelizedId); if (hasOwn(assets, PascalCaseId)) &#123; return assets[PascalCaseId] &#125; var res = assets[id] || assets[camelizedId] || assets[PascalCaseId]; return res&#125; 上面有两个关键的变量Ctor，resolveAsset，Ctor是resolveAsset的返回值。当执行resolveAsset时，传入的参数分别是context.$options, components, global-component，函数的处理逻辑如下： assets存放options[&#39;components&#39;]的值。 如果assets私有属性上有global-component,那就返回 如果assets原型链上有global-component,那就返回 值得注意的是，global-component是全局组件，所以会保存在assets的原型链上,local-component是局部组件，所以会保存在assets的私有属性上，如下图所示：其中KeepAlive Transtion TransitionGroup都是Vue内置的全局组件 创建组件的虚拟dom根据上图可以看到，传入全局组件global-component返回的Ctor是组件的构造函数VueComponent，传入局部组件local-component返回的Ctor是配置对象。接着就把Ctor传入createComponent函数执行，createComponent函数里的处理如下： baseCtor指向Vue 如果是局部组件，就把Ctor这个配置对象传入Vue.extend，并返回组件的构造函数VueComponent。 如果是函数组件，就使用createFunctionalComponent来创建函数组件 执行installComponentHooks函数往data对象上挂载四个钩子函数，分别是init prepatch insert destroy 执行new VNode创建组件的虚拟dom，值得注意的是，创建组件的虚拟dom，会把组件的配置对象当作第七个参数传入并存到组件虚拟dom的componentOptions中，这是创建html的虚拟dom是没有的。 12345678910111213141516171819202122232425262728293031323334353637function createComponent( Ctor, data, context,children,tag)&#123; var baseCtor = context.$options._base; if (isObject(Ctor)) &#123; Ctor = baseCtor.extend(Ctor); &#125; data = data || &#123;&#125;; if (isTrue(Ctor.options.functional)) &#123; return createFunctionalComponent(Ctor, propsData, data, context, children) &#125; installComponentHooks(data); var name = Ctor.options.name || tag; var vnode = new VNode( (&quot;vue-component-&quot; + Ctor.cid + (name ? &quot;-&quot; + name : &#x27;&#x27;)), data, undefined, undefined, undefined, context, &#123; Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children &#125; ); return vnode&#125;function installComponentHooks(data) &#123; var hooks = data.hook || (data.hook = &#123;&#125;); for (var i = 0; i &lt; hooksToMerge.length; i++) &#123; var key = hooksToMerge[i]; var existing = hooks[key]; var toMerge = componentVNodeHooks[key]; if (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) &#123; hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge; &#125; &#125;&#125;var componentVNodeHooks = &#123; init: function init() &#123;&#125;, prepatch: function prepatch() &#123;&#125;, insert: function insert() &#123;&#125;, destroy: function destroy() &#123;&#125;&#125; 最终组件的虚拟dom如下： Vue.extend建立继承关系值得注意的是Vue和VueComponent都是构造函数，其中Vue是根组件的构造函数，VueComponent是组件的构造函数，并且VueComponent继承了Vue，这两者的继承关系就是通过Ctor = Vue.extend(Ctor)实现的，我们看看Vue.extend内部的代码： cachedCtors对象用来缓存组件构造函数VueComponent 执行Sub.prototype = Object.create(Super.prototype)，通过原型链继承，是的Sub.prototype的原型链上有Super.prototype的所有方法。这样组件的实例对象就有Vue.prototype的所有方法了。 123456789101112131415161718Vue.extend = function (extendOptions) &#123; // 此处省略若干代码 var Super = this; var SuperId = Super.cid; var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;); if (cachedCtors[SuperId]) &#123; return cachedCtors[SuperId] &#125; var Sub = function VueComponent(options) &#123; this._init(options); &#125;; Sub.prototype = Object.create(Super.prototype); Sub.prototype.constructor = Sub; cachedCtors[SuperId] = Sub; return Sub&#125;; 创建组件的真实dom以上就是创建全局组件global-component对应的虚拟dom的过程。当然创建局部组件local-component的虚拟dom也是一样的，在创建好虚拟dom之后，就要把虚拟dom传入到vm._update中去处理了。 当首次挂载组件时，必然会走到_update函数里的第一个if判断中，并走到createElm函数来创建真实dom。 123456789101112131415161718192021 Vue.prototype._update = function (vnode, hydrating) &#123; var vm = this; var prevEl = vm.$el; var prevVnode = vm._vnode; vm._vnode = vnode; if (!prevVnode) &#123; vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */); &#125; else &#123; vm.$el = vm.__patch__(prevVnode, vnode); &#125;&#125;function patch(oldVnode, vnode, hydrating, removeOnly) &#123; // 此处省略若干代码 var isRealElement = isDef(oldVnode.nodeType); if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly); &#125; else &#123; createElm( vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm,nodeOps.nextSibling(oldElm) ); &#125;&#125; 接下来看看createElm内部是如何处理的？其逻辑如下： 把根节点交给createComponent处理，处理的结果为false 再把根节点及其子节点交给createChildren函数处理，其实就是遍历根节点的子节点，再次交给createElm函数去处理 根节点的子节点分别是global-component，local-component的虚拟dom，createElm内部的createComponent先处理global-component的虚拟dom 在createComponent函数中，取出组件的init钩子执行来初始化组件。 1234567891011121314151617181920212223242526function createElm( vnode,insertedVnodeQueue,parentElm,refElm) &#123; // 此处省略若干代码 if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123; return &#125; var data = vnode.data; var children = vnode.children; var tag = vnode.tag; createChildren(vnode, children, insertedVnodeQueue);&#125;function createChildren(vnode, children, insertedVnodeQueue) &#123; // 此处省略若干代码 for (var i = 0; i &lt; children.length; ++i) &#123; createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i); &#125;&#125;function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) &#123; var i = vnode.data; if (isDef(i)) &#123; if (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123; i(vnode, false); &#125; &#125;&#125; 接下来，我们看看init函数里是如何初始化组件的，流程如下： 如果组件的虚拟domvnode上有componentInstance keepAlive，并且组件没有被销毁，就判定组件需要被缓存 如果组件不是缓存的组件，那就执行createComponentInstanceForVnode来初始化组件. 2.1 createComponentInstanceForVnode函数里中vnode.componentOptions.Ctor指向组件的构造函数VueComponent 2.2 创建组件实例的过程，也会为组件的数据对象data构建响应式系统，编译组件模版最终生成render函数等，流程和根组件一致。 执行child.$mount来挂载组件，因为VueComponent和Vue的继承关系已经通过Vue.extend建立了，所以child上有$mount方法。 3.1 组件挂载的过程，也会创建渲染watcher lazyWatcher 自定义watcher等，并建立属性和watcher的依赖关系，流程和根组件一致。12345678910111213141516171819202122232425var componentVNodeHooks = &#123; init: function init(vnode, hydrating) &#123; if ( vnode.componentInstance &amp;&amp; !vnode.componentInstance._isDestroyed &amp;&amp; vnode.data.keepAlive ) &#123; var mountedNode = vnode; // work around flow componentVNodeHooks.prepatch(mountedNode, mountedNode); &#125; else &#123; var child = vnode.componentInstance = createComponentInstanceForVnode(vnode,activeInstance); child.$mount(hydrating ? vnode.elm : undefined, hydrating); &#125; &#125;&#125;function createComponentInstanceForVnode( vnode,parent) &#123; // 此处省略若干代码 var options = &#123; _isComponent: true, _parentVnode: vnode, parent: parent &#125;; return new vnode.componentOptions.Ctor(options)&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"6. Vue的diff算法","slug":"vue06","date":"2020-12-19T07:03:14.000Z","updated":"2020-12-22T10:30:33.580Z","comments":true,"path":"2020/12/19/vue06/","link":"","permalink":"http://example.com/2020/12/19/vue06/","excerpt":"","text":"上一节我们已经知道在触发更新后，渲染watcher会重新触发求值函数，求值函数内部先要vm._render()生成新值对应的虚拟dom，并把结果交给vm._update处理，接下来我们看看vm._update内部的实现逻辑？ prevVnode存储上次更新时的虚拟dom vm._vnode存储本次更新时的虚拟dom 如果prevVnode没有值，即首次挂载组件，则创建真实dom 如果prevVnode有值，即非首次挂载组件，那就把更新前后的虚拟dom传入vm.__patch__函数中去比较。 显然组件更新时，应该走进else语句。 123456789101112131415161718updateComponent = function () &#123; vm._update(vm._render(), hydrating);&#125;;Vue.prototype._update = function (vnode, hydrating) &#123; // 此处省略若干代码 var vm = this; var prevEl = vm.$el; var prevVnode = vm._vnode; vm._vnode = vnode; if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */); &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode); &#125;&#125;; diff算法的入口函数vm.__patch__是Vue的diff算法入口，我们看看内部是如何处理的？ 判断当前虚拟dom是否是静态节点，如果是静态节点，那就不再进行比较了。 把新老虚拟dom，放到cbs.update数组中各个函数去比较，其中cbs.update数组中各函数的作用是比较虚拟dom的属性 把新老虚拟dom,放到updateChildren函数中去比较，比较出差异，最终更新视图 123456789101112131415161718function patchVnode( oldVnode,vnode) &#123; // 此处省略若干代码 if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) &#123; vnode.componentInstance = oldVnode.componentInstance; return &#125; var data = vnode.data; var oldCh = oldVnode.children; var ch = vnode.children; if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123; for (i = 0; i &lt; cbs.update.length; ++i) &#123; cbs.update[i](oldVnode, vnode); &#125; &#125; if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; if (oldCh !== ch) &#123; updateChildren(elm, oldCh, ch) &#125; &#125;&#125; 比较虚拟dom的data上面说到的cbs.update的结构以及假定本次生成的虚拟dom如下，其中： updateAttrs是用来比对attrs的差异并更新的 updateclass是用来比对class的差异并更新的 updateDomListeners是用来比对绑定事件的差异并更新的 updateDOMProps是用来比对 updateStyle是用来比对样式的差异并更新的 update是用来比对ref的差异并更新的 updateDirectives是用来比对自定义指令的差异并更新的具体详情见:https://cn.vuejs.org/v2/guide/render-function.html归根结底，cbs.update内部的函数其实就是用来找到虚拟dom上的所有属性并更新的，不过上面的比较方式是有弊端的，如果我本次没有更新这些虚拟dom上的属性，Vue内部还是会比较dom上的全部属性(全量比较)。其实当我们没有更新虚拟dom上的属性时，最好的做法就是不比较，只有在更新某些属性的时候，我们再比较这些更新的属性。这样做可以节省无谓的比较次数。当然Vue2.x采用的是全量比较，在Vue3中就给需要更新的属性加上flag，只更新有flag的属性值。这也是Vue3的性能比Vue2好的一个原因。 比较虚拟dom的children如果说上面的cbs.update函数是用来比较虚拟dom属性的差异，那updateChildren就是用来比较虚拟dom的子节点差异的，我们接下来看看updateChildren的内部实现： 定义四个指针，其中oldStartIdx,oldEndIdx指向更新前虚拟dom(老虚拟dom)的首尾索引，newStartIdx,newEndIdx指向更新后(新虚拟dom)的首尾索引。 再定义四个指针，其中oldStartVnode,oldEndVnode指向更新前虚拟dom的首尾节点，newStartVnode,newEndVnode指向更新后(新虚拟dom)的首尾节点。 启动while循环，前两个判断是处理越界情况的并不是重点，重要的是后面四个else if判断，分别是： 判断老dom的头和新dom中的头是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动oldStartIdx,newStartIdx,oldStartVnode,newStartVnode指针。 判断老dom的尾和新dom中的尾是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动oldEndIdx,newEndIdx,oldEndVnode,newEndVnode指针。 判断老dom的头和新dom中的尾是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动oldStartIdx,newEndIdx,oldStartVnode,newEndVnode指针。 判断老dom的尾和新dom中的头是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动oldEndIdx,newStartIdx,oldEndVnode,newStartVnode指针。 如果上面四个判断都没走进去，那就基于本次添加的新dom创建真实dom，并添加到页面上。归根结底上面的四个判断，其实就是老头对新头，老尾对新尾，老头对新尾，老尾对新头的比较，这样比较的好处是尽可能多的复用老的虚拟dom。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; var oldStartIdx = 0; var newStartIdx = 0; var oldEndIdx = oldCh.length - 1; var oldStartVnode = oldCh[0]; var oldEndVnode = oldCh[oldEndIdx]; var newEndIdx = newCh.length - 1; var newStartVnode = newCh[0]; var newEndVnode = newCh[newEndIdx]; var oldKeyToIdx, idxInOld, vnodeToMove, refElm; while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left &#125; else if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx]; &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx); oldStartVnode = oldCh[++oldStartIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx); oldEndVnode = oldCh[--oldEndIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx); canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx); canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm); oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else &#123; if (isUndef(oldKeyToIdx)) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); &#125; idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx); if (isUndef(idxInOld)) &#123; // New element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx); &#125; else &#123; vnodeToMove = oldCh[idxInOld]; if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx); oldCh[idxInOld] = undefined; canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm); &#125; else &#123; // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx); &#125; &#125; newStartVnode = newCh[++newStartIdx]; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm; addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue); &#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx); &#125;&#125; sameVNode上面的updateChildren函数中用到sameVNode来判断是否是同一个虚拟dom，我们看看内部是如何判断的？ key值必须相同，在没有给虚拟dom添加key的情况下，key都是undefined，所以在没有手动添加key的情况下a.key===b.key成立，都是undefined。 tag值必须相同，即虚拟dom对应的标签名必须一样。 对应input标签，type值必须相同。 满足以上条件，才会判定是同一个虚拟dom。才会有走到同一个虚拟dom的patch逻辑中。 12345678910111213141516function sameVnode(a, b) &#123; return ( a.key === b.key &amp;&amp; ( ( a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) ) || ( isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error) ) ) )&#125; v-for的key我们是不建议在列表循环时，用索引来动态绑定key值的，为什么呢，可以看下面的情况: 对比老dom的头和新dom的头，发现key都是0,则判定是同一个虚拟dom，比较出差异，由1-&gt;3 ，更新dom，之后移动指针 重复第一步， 比对老dom的头和新dom的头，发现key都是1,则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针 重复第一步， 比对老dom的头和新dom的头，发现key都是2,则判定是同一个虚拟dom，比较出差异，由3-&gt;1 ，更新dom 根据以上分析，用索引来动态绑定key值会有两次dom操作。 让我们换个方式，用数组内部来动态绑定key： 对比老dom的头和新dom的头，发现key不同，老头key：1,新头key：3，则判定不是同一个虚拟dom。 对比老dom的头和新dom的尾，发现key都是1，则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针 重复第一步， 比对老dom的头和新dom的头，发现key不同，老头key：2,新头key：3，则判定不是同一个虚拟dom。 对比老dom的头和新dom的尾，发现key都是2，则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针 重复第一步， 比对老dom的头和新dom的头，发现key都是3,则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针 根据以上分析，用数组内部来动态绑定key值没有进行dom操作。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"5. Vue的更新策略","slug":"vue05","date":"2020-12-16T17:00:34.000Z","updated":"2020-12-22T05:22:39.078Z","comments":true,"path":"2020/12/17/vue05/","link":"","permalink":"http://example.com/2020/12/17/vue05/","excerpt":"","text":"在上篇文章中，我们已经讲到Vue内部如何进行依赖收集的，咱们先假定模版如下： 1234567&lt;div id=&#x27;app&#x27;&gt; &lt;button @click=&#x27;handleClick&#x27;&gt;按钮&lt;/button&gt; &lt;div v-for=&#x27;item in list&#x27;&gt;&#123;&#123;item&#125;&#125; &lt;/div&gt; &lt;p&gt;&#123;&#123;obj&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;splitMsg&#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122let vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &#x27;我是数据&#x27;, list: [1, 2, 3], obj: &#123; name: &#x27;heaven&#x27; &#125; &#125;, computed: &#123; splitMsg() &#123; return this.msg.split(&#x27;&#x27;) &#125; &#125;, methods:&#123; handleClick()&#123; this.msg = &#x27;我是修改的数据&#x27;; this.lish.push(4) this.obj.name = &#x27;啦啦啦&#x27; &#125; &#125;&#125; 最终模版转成的render函数如上所示，依赖收集的结果如下: list对应的订阅器对象dep中subs=[渲染watcher] obj对应的订阅器对象dep中subs=[渲染watcher] splitMsg是计算属性，所以msg对应的订阅器对象dep中subs=[lazyWatcher,渲染watcher] name对应的订阅器对象dep中subs=[渲染watcher]并且因为childOb.dep.depend的原因，obj和list这俩引用数据的dep订阅器对象的sub也会存储watcher，并且subs=[渲染watcher] 渲染watcher的依赖图最终渲染watcher收集的dep如下 lazyWatcher的依赖图最终lazyWatcher收集的dep如下 视图更新我们知道Vue内部为普通对象/数组构建了响应式系统，想要视图更新共有两种： 给对象属性赋值，触发set钩子 执行数组变异方法，触发mutator函数 12345678let vm = new Vue(&#123; methods:&#123; handleClick()&#123; this.msg = &#x27;我是修改的数据&#x27;; this.lish.push(4) &#125; &#125;&#125;) 修改对象属性上面代码this.msg = &#39;我是修改的数据&#39;会触发下面的set钩子函数，dep.notify()就是触发视图更新的关键代码，视图更新的逻辑如下： 取出subs数组中所有的watcher，并触发watcher的update方法。对于msg来说，subs数组的watcher只有一个渲染watcher update内部是基于watcher的种类做不同的处理，对于渲染watcher直接放到queueWatcher函数中处理，对于lazyWatcher，把dirty置true，表示lazyWatcher并没有求值。queueWatcher函数内部拿到watcher会怎么处理，我们稍等再说，值得注意的是，此时视图还没有更新呢。1234567891011121314151617181920212223242526set: function reactiveSetter(newVal) &#123; if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; val = newVal; childOb = !shallow &amp;&amp; observe(newVal); dep.notify();&#125;Dep.prototype.notify = function notify() &#123; var subs = this.subs.slice(); for (var i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update(); &#125;&#125;;Watcher.prototype.update = function update() &#123; if (this.lazy) &#123; this.dirty = true; &#125; else if (this.sync) &#123; this.run(); &#125; else &#123; queueWatcher(this); &#125;&#125;; 数组变异方法接下来我们执行数组的变异方法this.lish.push(4)来触发mutator函数，大致逻辑是： original.apply执行数组原型的push方法 对push/unshift/splice这三个方法，对添加的到list数组的新数据进行观测 ob.dep.notify()触发视图更新，值得注意的是ob指向this.__ob__，mutator函数内部this指向list数组，在观测list数组时，就已经通过def(value, &#39;__ob__&#39;, this)给list数组添加__ob__属性了。所以this.__ob__指向的就是list数组对应的观测对象，一旦执行ob.dep.notify()，就会取出list数组对应的dep订阅器对象里subs所有的watcher，对于list数组来说，subs数组只有一个渲染watcher，接着再执行watcher.update，最后是把渲染watcher放到queueWatcher函数中处理。123456789101112131415161718192021222324methodsToPatch.forEach(function (method) &#123; var original = arrayProto[method]; def(arrayMethods, method, function mutator() &#123; var args = [], len = arguments.length; while (len--) args[len] = arguments[len]; var result = original.apply(this, args); var ob = this.__ob__; var inserted; switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args; break case &#x27;splice&#x27;: inserted = args.slice(2); break &#125; if (inserted) &#123; ob.observeArray(inserted); &#125; ob.dep.notify(); return result &#125;);&#125;); vm.$set如果要让视图中的obj更新，只要this.obj.name=&#39;啦啦啦&#39;即可，其更新视图的流程和上面分析的this.msg=&#39;我是修改的数据&#39;一致，当然我们修改的obj的name属性，因为在构建响应式系统时，已经给name属性添加get和set，自然可以触发视图更新了，假定我们this.obj.age=28这样是否可以触发视图更新呢，根据Vue的使用经验，其实这样是不会触发视图更新的，如果就是希望this.obj.age=28来触发视图更新，可以使用vm.$set这个API来触发视图更新，如下所示： 123456789let vm = new Vue(&#123; methods:&#123; handleClick()&#123; this.obj.name = &#x27;啦啦啦&#x27; //可以触发视图更新，因为构建响应式系统时已经添加set this.obj.age = 28 //不可以触发视图更新，因为构建响应式系统时，并没有添加set vm.$set(this.obj,&#x27;age&#x27;,28) &#125; &#125;&#125;) 接下来，我们看看vm.$set是如何实现的？ 取出ob，这里ob指向this.obj这个对象的Observe实例 使用defineReactive$$1函数给ob.value的age属性构建响应式系统，这里ob.value指向this.obj ob.dep.notify()触发更新，也是把渲染watcher放到queueWatcher函数中处理，因为childOb.dep.depend的原因，所以这里ob.dep的subs中已经存储了渲染watcher。1234567Vue.prototype.$set = function set(target, key, val) &#123; // 此处省略若干代码 var ob = (target).__ob__; defineReactive$$1(ob.value, key, val); ob.dep.notify(); return val&#125; 异步更新queueWatcher上面我们讨论了三种触发视图更新的方式，不过我们只讨论到把watcher交给queueWatcher中处理，在这之前其实视图并没有更新，也就是说真正视图更新的逻辑是放在queueWatcher去做的，我们看看queueWatcher内部的代码逻辑： has存储不同的watcher.id 定义开关flushing，只要flushing=false那就把watcher放到queue数组中,其实flushSchedulerQueue没执行，flushing就一直为false 定义开关waiting，只要waiting=false那就触发nextTick(flushSchedulerQueue),并立马把waiting置true，防止再次触发nextTick(flushSchedulerQueue)1234567891011121314151617181920var has = &#123;&#125;;var queue = [];var waiting = false;var flushing = false;function queueWatcher(watcher) &#123; // 此处省略若干代码 var id = watcher.id; if (has[id] == null) &#123; has[id] = true; if (!flushing) &#123; queue.push(watcher); &#125; // queue the flush if (!waiting) &#123; waiting = true; nextTick(flushSchedulerQueue); &#125; &#125;&#125; nextTicknextTick的作用是收集本次传入的cb回调函数，并立马触发timerFunc，处理方式如下： callbacks存放传入的cb回调函数，例如上面的nextTick(flushSchedulerQueue)就是把flushSchedulerQueue放入到callbacks中，其实当用户手动触发this.$nextTick(回调函数)，也会将回调函数放入到callbacks中 定义开关pending，只要pending=false那就触发timerFunc(),并立马把pending置true，防止再次触发timerFunc()123456789101112131415161718var callbacks = [];var pending = false;function nextTick(cb, ctx) &#123; var _resolve; callbacks.push(function () &#123; if (cb) &#123; cb.call(ctx); &#125; &#125;); if (!pending) &#123; pending = true; timerFunc(); &#125;&#125;// 手动触发this.$nextTick(回调函数)的逻辑Vue.prototype.$nextTick = function (fn) &#123; return nextTick(fn, this)&#125;; timerFunctimerFunc的作用异步处理flushCallbacks，其中flushCallbacks存放的全是nextTick函数中callbacks收集的cb回调函数，例如flushSchedulerQueue，自定义回调等 12345678910111213141516if (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; // 此处省略若干代码 var p = Promise.resolve(); timerFunc = function () &#123; p.then(flushCallbacks); &#125;; &#125;function flushCallbacks() &#123; pending = false; var copies = callbacks.slice(0); callbacks.length = 0; for (var i = 0; i &lt; copies.length; i++) &#123; copies[i](); &#125;&#125; flushSchedulerQueue终于走到flushSchedulerQueue函数了，这里才是真正视图更新的地方，先看看内部的逻辑： queue数组升序排列 判断before存在，其实只有渲染watcher创建时有配置before，所以对于渲染watcher需要触发before配置，即组件的beforeUpdate钩子函数 取出queue中的每个watcher，并执行watcher.run，在这个情况，queue数组中只有一个渲染watcher，可以看到watcher.run中就执行了get触发求值函数了，因为template中用到了list/obj/splitMsg三个值，所以求值函数会求出list/obj/splitMsg最新的值 123456789101112131415161718192021222324252627282930313233343536function flushSchedulerQueue() &#123; currentFlushTimestamp = getNow(); flushing = true; var watcher, id; queue.sort(function (a, b) &#123; return a.id - b.id; &#125;); for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index]; if (watcher.before) &#123; watcher.before(); &#125; id = watcher.id; has[id] = null; watcher.run(); &#125; callUpdatedHooks(updatedQueue);&#125;// 重置任务状态function resetSchedulerState() &#123; queue.length = 0; has = &#123;&#125;; waiting = flushing = false;&#125;Watcher.prototype.run = function run() &#123; if (this.active) &#123; var value = this.get(); if ( value !== this.value || isObject(value) || this.deep) &#123; var oldValue = this.value; this.value = value; if (this.user) &#123; this.cb.call(this.vm, value, oldValue); &#125; &#125; &#125;&#125;; 以上就是Vue的更新策略，其实就是将所有的watcher都放到queue数组中，并异步执行watcher.run从而让视图更新，当然我们知道触发求值函数一定可以算出新值，即list/obj/splitMsg，那算出新值之后是直接把新值作为内容直接渲染到dom结构中嘛？这样其实并不合理，假如我们没有更新list,那算出的list就和更新之前的list是一样的。这种情况，其实没有必要把没变化的list作为内容直接渲染到dom结构中。即在算出新值时，我们需要和更新前的值比较，新值和老值一样，就不进行dom操作，新值和老值不一样，就更新dom，这就涉及到解析来我们要讲的Vue内部的diff算法了。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"4. Vue首次挂载，发生了肾么事?","slug":"vue04","date":"2020-12-15T13:14:44.000Z","updated":"2020-12-28T04:58:24.322Z","comments":true,"path":"2020/12/15/vue04/","link":"","permalink":"http://example.com/2020/12/15/vue04/","excerpt":"","text":"挂载组件的入口在第三节文章中，我们知道了Vue把template编译成render函数的过程。接下来Vue内部会怎么处理呢？其实接下来Vue就会执行mountComponent函数来挂载组件，如下所示： 触发beforeMount钩子 创建watcher的求值函数updateComponent，其中_render函数是创建虚拟dom,_update函数在首次触发时会基于创建的虚拟dom来生成真实dom 创建渲染watcher,其中最后一个参数true表示该watcher是渲染watcher 触发mounted钩子 12345678910111213141516171819function mountComponent(vm, el,hydrating) &#123; callHook(vm, &#x27;beforeMount&#x27;); var updateComponent = function () &#123; vm._update(vm._render(), hydrating); &#125;; new Watcher(vm, updateComponent, noop, &#123; before: function before() &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &#x27;beforeUpdate&#x27;); &#125; &#125; &#125;, true /* isRenderWatcher */); if (vm.$vnode == null) &#123; vm._isMounted = true; callHook(vm, &#x27;mounted&#x27;); &#125; return vm&#125; 创建渲染watcher接下来咱们看看Vue是如何定义Watcher这个类的，对于Watcher类的参数需要详细说下： expOrFn存储watcher的求值函数 ，对于渲染watcher，expOrFn就是updateComponent ，当然除了渲染watcher之后，其实还会有别的两类watcher，分别是为计算属性创建的lazyWatcher和为watch选项创建的自定义watcher，这两类对应的求值函数都是用户自定义传入的。 cb存储求值函数执行后的回调函数，对于渲染watcher，cb就是noop空函数 options存储watcher创建的配置参数，其中创建渲染watcher传入的配置对象有before钩子函数，创建自定义watcher时传入的配置对象有user属性为true，创建lazyWatcher时传入的配置对象有lazy属性为true。 isRenderWatcher 表示创建的watcher是否是渲染watcher，isRenderWatcher为true表示渲染watcher，并将渲染watcher放到vm._watcher中。 除了这些参数之外，还有别的处理，比如: 每次创建watcher时都会把watcher放到vm._watchers 在创建watcher时，基于lazy值判断是否执行求值函数，其中如果是lazyWatcher就不立马求值，不是lazyWatcher就立马求值。 1234567891011121314151617181920212223242526272829303132var Watcher = function Watcher( vm, expOrFn, cb, options, isRenderWatcher)&#123; this.vm = vm; if (isRenderWatcher) &#123; vm._watcher = this; &#125; vm._watchers.push(this); if (options) &#123; this.deep = !!options.deep; this.user = !!options.user; this.lazy = !!options.lazy; this.sync = !!options.sync; this.before = options.before; &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false; &#125; this.cb = cb; this.id = ++uid$2; // uid for batching this.active = true; this.dirty = this.lazy; // for lazy watchers this.deps = []; this.newDeps = []; this.depIds = new _Set(); this.newDepIds = new _Set(); this.expression = expOrFn.toString(); // parse expression for getter if (typeof expOrFn === &#x27;function&#x27;) &#123; this.getter = expOrFn; &#125; else &#123; this.getter = parsePath(expOrFn); &#125; this.value = this.lazy ? undefined : this.get();&#125; watche.run经过上面的分析，只要不是lazyWatcher就求值，那我们在初始化渲染watcher就会触发求值函数了，接下来我们看看run函数的逻辑：1.触发pushTarget，当前的watcher入targetStack栈，Dep.target指向栈顶的watcher2.触发求值函数getter3.触发popTarget，当前的watcher出targetStack栈，Dep.target指向栈顶的watcher4.触发cleanupDeps函数，depIds/deps存储本次newDepIds/newDeps的值，之后再清空newDepIds/newDeps 12345678910111213141516171819202122232425262728293031323334353637383940Watcher.prototype.get = function get() &#123; pushTarget(this); var value; var vm = this.vm; value = this.getter.call(vm, vm); popTarget(); this.cleanupDeps(); return value&#125;;Dep.target = null;var targetStack = [];function pushTarget(target) &#123; targetStack.push(target); Dep.target = target;&#125;function popTarget() &#123; targetStack.pop(); Dep.target = targetStack[targetStack.length - 1];&#125;Watcher.prototype.cleanupDeps = function cleanupDeps() &#123; var i = this.deps.length; while (i--) &#123; var dep = this.deps[i]; if (!this.newDepIds.has(dep.id)) &#123; dep.removeSub(this); &#125; &#125; var tmp = this.depIds; this.depIds = this.newDepIds; this.newDepIds = tmp; this.newDepIds.clear(); tmp = this.deps; this.deps = this.newDeps; this.newDeps = tmp; this.newDeps.length = 0;&#125;; 渲染watcher求值对于渲染watcher来说，求值函数getter就是updateComponent，而updateComponent函数的逻辑也很清晰: 触发_render函数 触发_update函数可以看到_render函数内部就是执行生成的render函数，而这个render函数就是基于template模版创建的render函数，值的注意的是，执行render函数时，会将内部this指向vm._renderProxy，vm._renderProxy对象经过处理指向组件实例vm。 123456789101112var updateComponent = function () &#123; vm._update(vm._render(), hydrating);&#125;;Vue.prototype._render = function () &#123; // 此处省略若干代码 var vm = this; var ref = vm.$options; var render = ref.render; var vnode = render.call(vm._renderProxy, vm.$createElement); return vnode&#125; 假定template模版如下，则生成的render函数如下图所示： 1234&lt;div id=app class=&quot;heaven&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;button @click=&#x27;handleClick&#x27;&gt;按钮&lt;/button&gt;&lt;/div&gt; 渲染watcher收集依赖当执行render函数时，有个with语句，执行with内部逻辑时，总是从this中取值，即取msg的值时，等价取vm.msg，因为我们之前做了数据代理的原因， 所以取vm.msg时，等价取vm._data.msg ,此时就触发了msg的get钩子函数。这时候get函数内部就会构建属性msg和watcher的依赖关系，我们看看get函数内部是怎么做的？ 判断Dep.target是否存在，之所以要有这个判断，是因为我们只要在渲染watcher/lazyWatcher/自定义watcher的求值函数触发时，才触发dep.depend函数 判断childOb是否存在，存在就执行childOb.dep.depend，childOb是什么？为什么要执行childOb.dep.depend，我们会在Vue的更新策略再说。 1234567891011121314151617181920212223242526function defineReactive$$1( obj, key, val, customSetter,shallow) &#123; var dep = new Dep(key); var childOb = !shallow &amp;&amp; observe(val); Object.defineProperty(obj, key, &#123; get: function reactiveGetter() &#123; if (Dep.target) &#123; dep.depend(); if (childOb) &#123; childOb.dep.depend(); if (Array.isArray(value)) &#123; dependArray(value); &#125; &#125; &#125; return value &#125;, set: function reactiveSetter(newVal) &#123; if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; val = newVal; childOb = !shallow &amp;&amp; observe(newVal); dep.notify(); &#125; &#125;);&#125; 经过上面的分析，我们知道Dep.target存在的话就要执行dep.depend方法，我们看看这个函数内部做了什么？ 判断Dep.target是否存在，值得注意的是，此时Dep.target指向渲染watcher，并且执行渲染watcher的addDep方法 watcher的addDep方法内部用到两个if判断，第一个判断是为了防止在本次求值过程中重复把watcher放到dep对象中，第二个if判断是为了防止在不同的求值时刻（用户更新视图会再次求值，再次求值会再次走到addDep的逻辑中）重复把watcher放到dep对象中。 最终会触发dep.addSub方法，把watcher放到depd对象的subs中。至此属性msg的dep对象中的subs数组收集到了渲染watcher，这就是msg属性的依赖收集过程。 123456789101112131415161718192021222324var Dep = function Dep(key) &#123; this.id = uid++; this.subs = [];&#125;;Dep.prototype.addSub = function addSub(sub) &#123; this.subs.push(sub);&#125;;Dep.prototype.depend = function depend() &#123; if (Dep.target) &#123; Dep.target.addDep(this); &#125;&#125;;Watcher.prototype.addDep = function addDep(dep) &#123; var id = dep.id; if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id); this.newDeps.push(dep); if (!this.depIds.has(id)) &#123; dep.addSub(this); &#125; &#125;&#125;; childOb.dep.depend的作用上面留了一个疑问，在get钩子中为什么要判断childObj?要明确这一点，我们先要知道childObj是什么？根据上面代码可知，childObj是observe函数的返回值，先看看observe函数是什么？其实observe函数就是第一节说到的Vue响应式系统的入口，observe函数返回的是个观测后的对象。 123456789101112131415161718192021222324252627282930function observe(value, asRootData) &#123; var ob; if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__; &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value); &#125; return ob&#125;var Observer = function Observer(value) &#123; this.value = value; this.dep = new Dep(value); this.vmCount = 0; def(value, &#x27;__ob__&#x27;, this); if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods); &#125; this.observeArray(value); &#125; else &#123; this.walk(value); &#125;&#125;; 如果观测的数据是value=[1,2,3,4],那么observe函数返回的结果如下： 所以childObj就是类似上面的数据结构，之所以在get的钩子函数中还要在判断childObj是否存在，其实就是为了当childObj存在时，再把当前的watcher添加到childObj.dep.subs数组中，为什么要把watcher放到subs数组中？咱们在下一节Vue的更新策略中会讲到。 上面讲到的是渲染watcher的创建和收集依赖的过程，接下来再说一下lazyWatcher的创建和收集依赖的过程,假定模版如下所示 123&lt;div id=app class=&quot;heaven&quot;&gt; &#123;&#123;splitMsg&#125;&#125;&lt;/div&gt; 1234567891011let vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &#x27;我是数据&#x27;, &#125;, computed: &#123; splitMsg() &#123; return this.msg.split(&#x27;&#x27;) &#125; &#125;&#125; 创建lazyWatcher其实对于computed选项里的每个计算属性，Vue内部都会为其生成一个lazyWatcher，我们看下Vue内部的处理，大致逻辑如下： 遍历computed选项，为每个计算属性都创建一个watcher，这里传递的求值函数是用户自己配置的属性的get 触发defineComputed函数，给计算属性添加get/set，即vm.filterMsg就会触发get钩子函数值得注意的是，computedWatcherOptions的lazy值为true，用来标记是一个lazyWatcher，而且lazyWatcher上有个dirty表示lazyWatcher是否已经求值了，lazyWatcher初始时是不会求值的，所以dirty为true。 12345678910111213141516171819202122232425262728293031323334353637383940414243var computedWatcherOptions = &#123; lazy: true &#125;;function initComputed(vm, computed) &#123; var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR var isSSR = isServerRendering(); for (var key in computed) &#123; var userDef = computed[key]; var getter = typeof userDef === &#x27;function&#x27; ? userDef : userDef.get; if (!isSSR) &#123; // create internal watcher for the computed property. watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions ); &#125; defineComputed(vm, key, userDef); &#125;&#125;function defineComputed(target, key,userDef) &#123; // 此处省略若干代码 sharedPropertyDefinition.get = createComputedGetter(key) sharedPropertyDefinition.set = noop; Object.defineProperty(target, key, sharedPropertyDefinition);&#125;function createComputedGetter(key) &#123; return function computedGetter() &#123; var watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]; if (watcher) &#123; if (watcher.dirty) &#123; watcher.evaluate(); &#125; if (Dep.target) &#123; watcher.depend(); &#125; return watcher.value &#125; &#125;&#125; lazyWatcher收集依赖当然，在创建watcher时，一旦lazy是true，就不会在立马执行求值函数，那么lazyWatcher是在什么时刻求值的呢？其实也是在render函数中执行时才求值的，上面的模版最终编译的render函数如下，当执行this.filterMsg时，就会触发get函数，而get钩子函数的逻辑: 从_computedWatchers中取出lazyWatcher 判断dirty，如果值为true，就表示此刻lazyWatcher还没有求值，就触发evaluate函数 在evaluate函数函数里面,就会触发求值函数了，之后会把dirty置false，表示lazyWatcher已经求值完成，在lazyWatcher求值时，需要注意下面几点： 因为lazyWatcher是在render函数执行时遇到计算属性的基础上求值的，所以在lazyWatcher求值之前，targetStack=[渲染watcher],在lazyWatcher求值之后，targetStack=[渲染watcher,lazyWatcher] 此刻Dep.target指向lazyWatcher lazyWatcher的求值函数是用户自定义的，在这里应该是 splitMsg() &#123; return this.msg.split(&#39;&#39;) &#125;,可想而知，一旦执行该函数，就会执行this.msg，这时就会触发msg的get钩子函数进行依赖收集，把lazyWatcher添加到msg的dep(属性订阅器)的subs中（步骤和收集渲染watcher一致）。 执行popTarget函数，lazyWatcher从targetStack弹出，此刻Dep.target指向渲染watcher 求值结束后，判断Dep.target是否存在，此刻是存在的，再把Dep.target即渲染watcher添加到msg的dep(属性订阅器)的subs中,最终msg的dep(属性订阅器)的subs=[lazyWatcher,渲染watcher] 至此属性msg的dep对象中的subs数组收集到了lazyWatcher和渲染watcher，这就是某个计算属性的依赖收集过程。 1234567891011121314Watcher.prototype.evaluate = function evaluate() &#123; this.value = this.get(); this.dirty = false;&#125;;Watcher.prototype.get = function get() &#123; pushTarget(this); var value; var vm = this.vm; value = this.getter.call(vm, vm); popTarget(); this.cleanupDeps(); return value&#125;; 创建虚拟dom根据上面的分析，我们知道在触发vm._render函数时，会收集依赖，其实vm._render函数还有另外一个作用：创建虚拟dom，这就要说到生成的render函数里用到的辅助函数_c了，它是用来创建虚拟的元素节点，我们看看函数内部的逻辑： 执行createElement函数，作用是参数重载，用来确保data存节点的属性，children存子节点 执行_createElement函数，该函数作用有三： 2.1 处理传入的children子节点， 2.2 处理原生html标签如div,p，并使用 new VNode()来创建标签对应的虚拟dom 2.3 处理自定义组件，并使用createComponent来创建组件对应的虚拟dom(后面讲Vue组件系统时会讲到) 123456789101112131415161718192021222324252627282930313233343536vm._c = function (a, b, c, d) &#123; return createElement(vm, a, b, c, d, false); &#125;;// 参数重载 保证data存属性 children存子节点的顺序function createElement(context,tag,data,children,normalizationType,alwaysNormalize ) &#123; if (Array.isArray(data) || isPrimitive(data)) &#123; normalizationType = children; children = data; data = undefined; &#125; if (isTrue(alwaysNormalize)) &#123; normalizationType = ALWAYS_NORMALIZE; &#125; return _createElement(context, tag, data, children, normalizationType)&#125;function _createElement(context,tag,data,children,normalizationType) &#123; if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children); &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children); &#125; var vnode; if (typeof tag === &#x27;string&#x27;) &#123; var Ctor; if (config.isReservedTag(tag)) &#123; // platform built-in elements vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ); &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, &#x27;components&#x27;, tag))) &#123; // component vnode = createComponent(Ctor, data, context, children, tag); &#125; &#125; return vnode&#125; 当Vue内部创建好虚拟dom后，就会把虚拟dom交给vm._update处理，我们看看这个函数内部的逻辑： prevEl存储组件的挂载点(真实dom) prevVnode存储上次生成的虚拟dom，对于首次触发_update函数来说，prevVnode为undefined vm._vnode存储本次生成的虚拟dom 显然首次触发_update函数时，会走进if，从而触发vm.__patch__函数并传入vm.$el和vnode 12345678910111213Vue.prototype._update = function (vnode, hydrating) &#123; var vm = this; var prevEl = vm.$el; var prevVnode = vm._vnode; vm._vnode = vnode; if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */); &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode); &#125;&#125;; 创建真实domvm.patch接下来，我们看看vm.__patch__函数的实现： 判断oldVnode是不是真实的dom节点，如果是真实节点，那就说明是因为首次挂载组件触发patch函数的，那就使用createElm来创建真实dom 如果不是元素节点，那就说明是因为组件更新触发patch函数的，那就使用patchVnode来比对更新前后的虚拟dom。对于首次触发patch函数时，因为oldVnode是真实节点，所以会走进else语句，最终触发createElm函数。1234567891011121314151617181920function patch(oldVnode, vnode)&#123; var isRealElement = isDef(oldVnode.nodeType); if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; // patch existing root node patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly); &#125; else &#123; if (isRealElement) &#123; oldVnode = emptyNodeAt(oldVnode); var oldElm = oldVnode.elm; var parentElm = nodeOps.parentNode(oldElm); // create new node createElm( vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ); &#125;&#125; createElmVue内部是使用createElm函数来根据虚拟dom创建真实dom的，我们看看内部的处理: 如果虚拟dom里有组件，那就创建组件(这里没有组件，后面在讲Vue组件系统会讲到) 把vnode及其子节点children放到createChildren函数中处理，生成子节点对应的真实dom。 最终把生成的子节点插入到父节点parentElm中 1234567891011121314151617181920212223242526272829function createElm( vnode,insertedVnodeQueue,parentElm,refElm )&#123; if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123; return &#125; var data = vnode.data; var children = vnode.children; var tag = vnode.tag; if (isDef(tag)) &#123; vnode.elm = nodeOps.createElement(tag, vnode); createChildren(vnode, children ); insert(parentElm, vnode.elm, refElm); &#125;else if (isTrue(vnode.isComment)) &#123; vnode.elm = nodeOps.createComment(vnode.text); insert(parentElm, vnode.elm, refElm); &#125; else &#123; vnode.elm = nodeOps.createTextNode(vnode.text); insert(parentElm, vnode.elm, refElm); &#125;&#125;function createChildren(vnode, children, insertedVnodeQueue) &#123; if (Array.isArray(children)) &#123; checkDuplicateKeys(children); for (var i = 0; i &lt; children.length; ++i) &#123; createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i); &#125; &#125;&#125; 以上，就是Vue内部从挂载组件到生成真实dom的全部过程。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"实现express的洋葱模型","slug":"express01","date":"2020-12-11T09:39:55.000Z","updated":"2020-12-17T05:09:26.993Z","comments":true,"path":"2020/12/11/express01/","link":"","permalink":"http://example.com/2020/12/11/express01/","excerpt":"","text":"Layer.jsexpress.js123456789let express = (function () &#123; var instance = null return function () &#123; if (!instance) &#123; instance = new CreateApplication() &#125; return instance &#125;&#125;)() CreateApplication.js1234567891011121314151617181920212223const http = require(&#x27;http&#x27;)class CreateApplication &#123; constructor() &#123; this._router = new Router() &#125; get(path, ...handlers) &#123; this._router.get(path, handlers) &#125; post(path, ...handlers) &#123; this._router.post(path, handlers) &#125; use(path, ...handlers) &#123; this._router.use(path, handlers) &#125; listen(...args) &#123; function done(req, res) &#123; res.end(`Cannot $&#123;req.method&#125; $&#123;req.url&#125;`) &#125; http.createServer((req, res) =&gt; &#123; this._router.handle(req, res, done) &#125;).listen(...args) &#125;&#125; Router.js12345678910111213141516171819202122232425262728293031323334353637const url = require(&#x27;url&#x27;)class Router &#123; constructor() &#123; this.stacks = [] &#125; get(path, handlers) &#123; const layer = new Layer(path, &#x27;get&#x27;, handlers) this.stacks.push(layer) &#125; post(path, handlers) &#123; const layer = new Layer(path, &#x27;post&#x27;, handlers) this.stacks.push(layer) &#125; use(path, handlers) &#123; const layer = new Layer(path, &#x27;use&#x27;, handlers) this.stacks.push(layer) &#125; handle(req, res, done) &#123; const &#123; pathname &#125; = url.parse(req.url) let idx = 0 let next = () =&gt; &#123; if (idx &gt;= this.stacks.length) return done(req, res) let layer = this.stacks[idx++] const &#123; method &#125; = layer if ( pathname === layer.path &amp;&amp; (method === req.method.toLowerCase() || method === &#x27;use&#x27;) ) &#123; layer.dispatch(req, res, next)//触发内层 &#125; else &#123; next() //触发外层 &#125; &#125; next() &#125;&#125; Layer.js1234567891011121314151617class Layer &#123; constructor(path, method, handlers) &#123; this.stacks = [] this.method = method this.path = path this.stacks.push(...handlers) &#125; dispatch(req, res, out) &#123; let idx = 0; let next = () =&gt; &#123; if (idx &gt;= this.stacks.length) return out() let handler = this.stacks[idx++] handler(req, res, next) &#125; next() &#125;&#125;","categories":[{"name":"Node","slug":"Node","permalink":"http://example.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"}]},{"title":"3. Vue生成ast树后，发生了肾么事？","slug":"vue03","date":"2020-12-06T06:59:10.000Z","updated":"2021-02-19T07:28:28.991Z","comments":true,"path":"2020/12/06/vue03/","link":"","permalink":"http://example.com/2020/12/06/vue03/","excerpt":"","text":"Vue 生成了 ast 语法树之后，还对这个树结构进行了静态标记，之所以给 ast 树打上是否是静态的标记，是因为在后面 diff 算法的时候，直接跳过静态的节点，可以节省 diff 的开销。下面我们看看是怎么给节点打静态标记的吧 12345678910111213141516var ast = parse(template.trim(), options);if (options.optimize !== false) &#123; optimize(ast, options);&#125;function optimize(root, options) &#123; if (!root) &#123; return; &#125; isStaticKey = genStaticKeysCached(options.staticKeys || &quot;&quot;); isPlatformReservedTag = options.isReservedTag || no; // 给节点打上是否是静态节点的标记 markStatic$1(root); // 给节点打上是否是静态根节点的标记 markStaticRoots(root, false);&#125; 上面的代码中，markStatic$1 函数是给节点打上是否是静态节点的标记，markStaticRoots 函数是给节点打上是否是静态根节点的标记，我们先看看 markStatic$1 函数内部的逻辑，其实核心 isStatic 函数，这个函数是判断节点是否是静态节点。判断的逻辑大致如下 如果是插值文本 那就不是静态节点 如果是普通文本 那就是静态节点 有跳过编译的指令 pre 那就是静态节点 没有属性绑定&amp;有 if for&amp;不是 Vue 内置标签等 那就是静态节点 在经过上面判断出这个节点是否是静态节点，如果是那就给这个节点在加上static:true标记，当然这还没结束，接着还会在遍历这个节点的子节点们，判断子节点是否是静态节点，一旦某个子节点不是静态节点，那就给这个节点打上static:false标记 123456789101112131415161718192021222324252627282930313233function markStatic$1(node) &#123; node.static = isStatic(node); if (node.type === 1) &#123; for (var i = 0, l = node.children.length; i &lt; l; i++) &#123; var child = node.children[i]; markStatic$1(child); if (!child.static) &#123; node.static = false; &#125; &#125; &#125;&#125;function isStatic(node) &#123; if (node.type === 2) &#123; // expression return false; &#125; if (node.type === 3) &#123; // text return true; &#125; return !!( node.pre || (!node.hasBindings &amp;&amp; // no dynamic bindings !node.if &amp;&amp; !node.for &amp;&amp; // not v-if or v-for or v-else !isBuiltInTag(node.tag) &amp;&amp; // not a built-in isPlatformReservedTag(node.tag) &amp;&amp; // not a component !isDirectChildOfTemplateFor(node) &amp;&amp; Object.keys(node).every(isStaticKey)) );&#125; 下面再看看 markStaticRoots 函数的逻辑,判断节点是否是静态根节点的逻辑大致如下 如果是该节点是静态节点，并且这个节点的子节点长度大于 1，那这个节点就是静态根节点 不满足上述条件，则这个节点就不是静态根节点在经过上面判断出这个节点是否是静态根节点，如果是那就给这个节点在加上staticRoot:true标记，当然这还没结束，接着还会在遍历这个节点的子节点们，判断子节点是否是静态根节点，最后给子节点们打上 staticRoot 标记 12345678910111213141516171819202122function markStaticRoots(node, isInFor) &#123; if (node.type === 1) &#123; // For a node to qualify as a static root, it should have children that // are not just static text. Otherwise the cost of hoisting out will // outweigh the benefits and it&#x27;s better off to just always render it fresh. if ( node.static &amp;&amp; node.children.length &amp;&amp; !(node.children.length === 1 &amp;&amp; node.children[0].type === 3) ) &#123; node.staticRoot = true; return; &#125; else &#123; node.staticRoot = false; &#125; if (node.children) &#123; for (var i = 0, l = node.children.length; i &lt; l; i++) &#123; markStaticRoots(node.children[i], isInFor || !!node.for); &#125; &#125; &#125;&#125; 最终 Vue 就处理好了 ast 树，接着会基于 ast 树生成代码，,这里使用到了 generate 函数，generate 这个函数内部的逻辑大致是: genElement 函数内部创建节点对应的代码存到 data 中 genChildren 函数内部创建节点的子节点对应的代码存到 children 中 最终基于 data 和 children 拼接成最终的 code，其中如果节点有 if for once 等指令，会转换成特殊的代码 如果是静态根节点，就生成代码并存到 staticRenderFns 中值得注意的是，我们在下面代码中可以得到结论：v-for 的优先级比 v-if 的优先级因为 generate 函数内部是先处理 el.for，再处理 el.if 的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var ast = parse(template.trim(), options);if (options.optimize !== false) &#123; optimize(ast, options);&#125;var code = generate(ast, options);function generate(ast, options) &#123; var state = new CodegenState(options); var code = ast ? genElement(ast, state) : &#x27;_c(&quot;div&quot;)&#x27;; return &#123; render: &quot;with(this)&#123;return &quot; + code + &quot;&#125;&quot;, staticRenderFns: state.staticRenderFns, &#125;;&#125;function genElement(el, state) &#123; if (el.parent) &#123; el.pre = el.pre || el.parent.pre; &#125; if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123; return genStatic(el, state); &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123; return genOnce(el, state); &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123; return genFor(el, state); &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123; return genIf(el, state); &#125; else if (el.tag === &quot;template&quot; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123; return genChildren(el, state) || &quot;void 0&quot;; &#125; else if (el.tag === &quot;slot&quot;) &#123; return genSlot(el, state); &#125; else &#123; // component or element var code; if (el.component) &#123; code = genComponent(el.component, el, state); &#125; else &#123; var data; if (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) &#123; data = genData$2(el, state); &#125; var children = el.inlineTemplate ? null : genChildren(el, state, true); code = &quot;_c(&#x27;&quot; + el.tag + &quot;&#x27;&quot; + (data ? &quot;,&quot; + data : &quot;&quot;) + (children ? &quot;,&quot; + children : &quot;&quot;) + &quot;)&quot;; &#125; // module transforms for (var i = 0; i &lt; state.transforms.length; i++) &#123; code = state.transforms[i](el, code); &#125; return code; &#125;&#125; 最终输出的 code 为下图，其中 render 为可执行的字符串，staticRenderFns 为静态节点字符串 生成 code 之后，接下来的处理是在 compileToFunctions 函数中,大致逻辑是： 定义 cache 缓存对象 compile 函数返回的是 code 对象,即 compiled-&gt;code 对象 基于 render/staticRenderFns 创建函数 返回 res 对象，并将 key-&gt;res 存到缓存对象中,这个是 vue 的优化策略，当第二次再次编译同样的模版时，会直接取出 render/staticRenderFns，不会重复编译出 render/staticRenderFns，这样在多次使用组件时，就可以极大的节省浏览器开销 123456789101112131415161718192021function compileToFunctions(template, options, vm) &#123; var cache = Object.create(null); // 此时省略很多代码 if (cache[key]) &#123; return cache[key]; &#125; // 编译模版 var compiled = compile(template, options); var res = &#123;&#125;; var fnGenErrors = []; res.render = createFunction(compiled.render, fnGenErrors); res.staticRenderFns = compiled.staticRenderFns.map(function (code) &#123; return createFunction(code, fnGenErrors); &#125;); return (cache[key] = res);&#125;function createFunction(code, errors) &#123; return new Function(code);&#125; 至此 Vue 编译模版终于结束了，过程是从 html 字符串-&gt;ast 语法树-&gt;code 对象-&gt;render 函数。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"js小技巧","slug":"js骚操作","date":"2020-12-03T10:31:01.000Z","updated":"2021-02-19T07:28:57.231Z","comments":true,"path":"2020/12/03/js骚操作/","link":"","permalink":"http://example.com/2020/12/03/js%E9%AA%9A%E6%93%8D%E4%BD%9C/","excerpt":"","text":"金额格式化12345678let num = 1000000;// 方法1:let result = num.toLocaleString(); // 1,000,000// 方法2:const reg = /(?=(\\B)(\\d&#123;3&#125;)+$)/g;let result = num.toString().replace(reg, &quot;,&quot;); // 1,000,000 交换值12345678910let a = 1, b = 2;// 方法1:b = [a, (a = b)][0]; //a=1 b=2// 方法2a = a ^ b;b = a ^ b;a = a ^ b; //a=1 b=2 暂无标题key 为假值，则没有该属性，key 为真值，则添加该属性 12345let x = undefined;let objX = &#123; ...(x &amp;&amp; &#123; x &#125;) &#125;; // &#123;&#125;let y = 1;let objY = &#123; ...(y &amp;&amp; &#123; y &#125;) &#125;; // &#123;y:1&#125; proxy 构建响应式系统1234567891011121314151617181920212223242526function isObject(origin) &#123; return typeof origin === &quot;object&quot; &amp;&amp; typeof origin !== null;&#125;function myReact(obj) &#123; return new Proxy(obj, &#123; get(origin, key, receiver) &#123; console.log(&quot;依赖收集&quot;); const res = Reflect.get(origin, key, receiver); return isObject(res) ? myReact(res) : res; &#125;, set(origin, key, value, receiver) &#123; console.log(&quot;视图更新&quot;); return Reflect.set(origin, key, value, receiver); &#125;, &#125;);&#125;const person = &#123; name: &quot;heaven&quot;, age: 28, hobby: [&quot;cycle&quot;, &quot;eat&quot;], friend: &#123; name: &quot;666&quot;, age: 28 &#125;,&#125;;const res = myReact(person);res.hobby.push(&quot;run&quot;); 统计页面停留时间12345678910let start = new Date();document.addEventListener(&quot;visibilitychange&quot;, function () &#123; if (document.hidden) &#123; var now = new Date(); console.log(&quot;用户离开页面了&quot;, `用户停留$&#123;(now - start) / 1000&#125;s`); &#125; else &#123; start = new Date(); console.log(&quot;用户进入页面了&quot;); &#125;&#125;); 监视 dom 元素进入可视区可应用于懒加载，监视图片进入视区，就去加载图片。 1234567let dom = document.getElementById(&quot;dom&quot;);const observer = new IntersectionObserver((entries) =&gt; &#123; entries.forEach((entry) =&gt; &#123; console.log(`$&#123;entry.isIntersecting ? &quot;进入视区&quot; : &quot;离开视区&quot;&#125;`); &#125;);&#125;);observer.observe(dom);","categories":[{"name":"JS","slug":"JS","permalink":"http://example.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"2. Vue如何编译模版?","slug":"vue02","date":"2020-12-01T13:26:48.000Z","updated":"2020-12-19T04:23:21.613Z","comments":true,"path":"2020/12/01/vue02/","link":"","permalink":"http://example.com/2020/12/01/vue02/","excerpt":"","text":"Vue上手非常简单，因为我们可以直接编写html作为组件的模版，对比学习React还需要接触jsx语法，Vue对新手可以说是非常友好了，接下来我们看看vue是如何处理template模版的？ Vue编译器入口1234567891011121314151617var createCompiler = createCompilerCreator( function baseCompile(template, options) &#123; // template -&gt; ast 对template的第一层抽象 var ast = parse(template.trim(), options); // 优化ast树 标注静态节点 if (options.optimize !== false) &#123; optimize(ast, options); &#125; // ast -&gt; 可执行code 对template的第二层抽象 var code = generate(ast, options); return &#123; ast: ast, render: code.render, staticRenderFns: code.staticRenderFns &#125; &#125;); 可以看到首先是template模版放到parse函数中处理，得到ast对象(abstract syntax tree)，其实ast对象是对template的第一层抽象，template模版本质上是一个html字符串，现在用ast对象来描述template模版，接下来看看html字符串如何被转换成ast对象的？假定template模版如下： 12345678910111213141516171819202122232425// html模版let template = ` &lt;div id=app v-if=&#x27;msg&#x27; v-for=&#x27;item in 3&#x27; v-once:click=&#x27;handleClick&#x27;&gt; &lt;div class=&#x27;text&#x27; title=&#x27;heaven&#x27;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;`function parse(template,options) &#123; // ...此处省略部分代码 var stack = []; var root; var currentParent; parseHTML(template, &#123; // ...此处省略部分代码 // 解析到开始标签的钩子函数 start: function start()&#123;&#125;, // 解析到结束标签的钩子函数 end: function end() &#123;&#125;, // 解析到文本的钩子函数 chars: function()&#123; &#125; &#125;) return root&#125; parseHTML 编译模版可以看到真正处理template的是parseHTML这个函数，我们看看这个函数内部的逻辑是什么？其实大致有4步 定义token，这些token用来解析开始标签 标签属性 结束标签等 处理开始标签，并把处理的结果交给handleStartTag处理 处理结束标签，并把处理的结果交给parseEndTag处理 处理文本，并把文本交给chars钩子函数处理123456789101112131415161718192021222324252627282930313233343536373839404142434445// 解析属性的token id=&#x27;app&#x27;var attribute = /^\\s*([^\\s&quot;&#x27;&lt;&gt;\\/=]+)(?:\\s*(=)\\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\\s&quot;&#x27;=&lt;&gt;`]+)))?/;var ncname = &quot;[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z&quot; + (unicodeRegExp.source) + &quot;]*&quot;;var qnameCapture = &quot;((?:&quot; + ncname + &quot;\\\\:)?&quot; + ncname + &quot;)&quot;;// 解析开始标签的token &lt;div var startTagOpen = new RegExp((&quot;^&lt;&quot; + qnameCapture));// 解析开始标签结束的token /&gt; &gt;var startTagClose = /^\\s*(\\/?)&gt;/;// 解析结束标签的token &lt;/div&gt;var endTag = new RegExp((&quot;^&lt;\\\\/&quot; + qnameCapture + &quot;[^&gt;]*&gt;&quot;));function parseHTML(html, options) &#123; var stack = []; var index = 0; while (html) &#123; var textEnd = html.indexOf(&#x27;&lt;&#x27;); // ...此处省略部分代码 // 处理开始标签 var startTagMatch = parseStartTag(); if (startTagMatch) &#123; handleStartTag(startTagMatch); continue &#125; // 处理结束标签 var endTagMatch = html.match(endTag); if (endTagMatch) &#123; var curIndex = index; advance(endTagMatch[0].length); parseEndTag(endTagMatch[1], curIndex, index); continue &#125; // 处理文本 包括静态文本和插值 var text if (textEnd &gt;= 0) &#123; // ...此处省略部分代码 text = html.substring(0, textEnd); &#125; if (text) advance(text.length); if (options.chars &amp;&amp; text) &#123; options.chars(text, index - text.length, index); &#125; &#125;&#125; 解析开始标签接下来，我们看看parseStartTag函数是如何处理开始标签的？12345678910111213141516171819202122232425262728293031// 控制全局的index/html向前移动nfunction advance(n) &#123; index += n; html = html.substring(n);&#125;function parseStartTag() &#123; // 解析到开始标签 var start = html.match(startTagOpen); if (start) &#123; var match = &#123; tagName: start[1], attrs: [], start: index &#125;; advance(start[0].length); var end, attr; while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(dynamicArgAttribute) || html.match(attribute))) &#123; attr.start = index; advance(attr[0].length); attr.end = index; match.attrs.push(attr); &#125; if (end) &#123; match.unarySlash = end[1]; advance(end[0].length); match.end = index; return match &#125; &#125;&#125; 最终开始标签&lt;div id=&#39;app&#39;&gt;被解析成下面的结构，其中attrs里面存放开始标签的属性集合，start是开始标签的起始位置，end是开始标签的结束位置，tagName是开始标签的标签类型，unarySlash为空代表标签为双标签，这样开始标签所有信息都被这个对象完美描述了，下面是match的结构图 接下来，开始标签的处理结果match还需要交给handleStartTag处理，我们看看handleStartTag内部的逻辑，其实也是很清晰的 处理attrs属性，最终把标签的属性改成key:value的形式，并且标记attrs内部的属性开始和结束位置 将开始标签的信息放到stack栈中 触发start钩子函数值的注意的是value值为args[3] || args[4] || args[5],这是怎么回事呢？这是因为对于属性值的三种形式&lt;div id=&quot;app&quot;&gt; app可以是单引号，双引号，不加引号，分别对应args[3] || args[4] || args[5]1234567891011121314151617181920212223242526272829function handleStartTag(match) &#123; var tagName = match.tagName; var unarySlash = match.unarySlash; var unary = isUnaryTag$$1(tagName) || !!unarySlash; var l = match.attrs.length; var attrs = new Array(l); for (var i = 0; i &lt; l; i++) &#123; var args = match.attrs[i]; var value = args[3] || args[4] || args[5] || &#x27;&#x27;; attrs[i] = &#123; name: args[1], value &#125; if (options.outputSourceRange) &#123; attrs[i].start = args.start + args[0].match(/^\\s*/).length; attrs[i].end = args.end; &#125; &#125; // 处理双标签 if (!unary) &#123; stack.push(&#123; tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end &#125;); lastTag = tagName; &#125; if (options.start) &#123; options.start(tagName, attrs, unary, match.start, match.end); &#125;&#125; 可以看到Vue把数据做了处理之后，又把这些数据交给了start钩子处理，我们看看start钩子里面的逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 function createASTElement(tag,attrs,parent) &#123; return &#123; type: 1, tag: tag, attrsList: attrs, attrsMap: makeAttrsMap(attrs), rawAttrsMap: &#123;&#125;, parent: parent, children: [] &#125; &#125;function parse(template,options) &#123; // ...此处省略部分代码 var stack = []; var root; var currentParent; parseHTML(template, &#123; start: function start(tag, attrs, unary, start$1, end)&#123; var element = createASTElement(tag, attrs, currentParent); if (options.outputSourceRange) &#123; element.start = start$1; element.end = end; element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) &#123; cumulated[attr.name] = attr; return cumulated &#125;, &#123;&#125;); &#125; // 处理v-for v-if指令 if (!element.processed) &#123; processFor(element); processIf(element); processOnce(element); &#125; // 解析到的第一个元素 就是根节点 if (!root) &#123; root = element; &#125; // 如果是双标签 那currentParent就指定当前的ast元素，并存到stack栈中 if (!unary) &#123; currentParent = element; stack.push(element); &#125; else &#123; closeElement(element); &#125; &#125;, end: function end() &#123;&#125;, chars: function ()&#123;&#125; &#125;) return root&#125; 其实start钩子内部大致就做了三件事： 根据createASTElement生成一个ast元素，该ast元素也是用来描述开始标签，虽然match也用来描述开始标签，但是JS操作ast元素显然更方便些。 处理开始标签上面的v-if v-for v-once指令 初始化root currentParent stack的值，其中root存储模版的根节点，currentParent指定当前解析到的ast元素，stack存放解析到的所有ast元素下面是开始标签对应ast元素的结构图: 解析字符文本以上就是Vue内部解析开始标签的所有过程了，接下来我们再看看Vue内部如何解析文本的？,根据上面的分析，我们已经知道解析到文本会交给chars钩子处理，我们来看看chars钩子内部的逻辑。 1234567891011121314151617181920212223242526272829303132function parse(template,options) &#123; // ...此处省略部分代码 var stack = []; var root; var currentParent; parseHTML(template, &#123; start: function start()&#123;&#125;, end: function end() &#123;&#125;, // 解析到文本的钩子函数 chars: function (text, start, end)&#123; var children = currentParent.children; var res; var child; // 解析到有插值的文本 if (!inVPre &amp;&amp; text !== &#x27; &#x27; &amp;&amp; (res = parseText(text, delimiters))) &#123; child = &#123; type: 2, expression: res.expression, tokens: res.tokens, text: text &#125;; &#125; else if (text !== &#x27; &#x27; || !children.length || children[children.length - 1].text !== &#x27; &#x27;) &#123; // 解析到没有插值的文本 child = &#123; type: 3, text: text &#125;; &#125; &#125; &#125;) return root&#125; chars钩子内部逻辑很简单，就是区分文本是否有插值符号，有插值符号的话ast对象type标记为2，并解析插值，没有插值就当作普通文本处理ast对象type标记为3。下面是插值文本对应的ast对象 解析结束标签最后我们再看看Vue内部解析结束标签的过程，,根据上面的分析，我们已经知道解析到结束标签会交给parseEndTag函数处理，来看看parseEndTag函数内部的逻辑。大致意思是取出stack栈中的最后一项，并将最后一项的tag，start，end交给end钩子处理 12345678910111213141516171819202122232425262728293031function parseEndTag(tagName, start, end) &#123; var pos, lowerCasedTagName; if (start == null) &#123; start = index; &#125; if (end == null) &#123; end = index; &#125; // Find the closest opened tag of the same type if (tagName) &#123; lowerCasedTagName = tagName.toLowerCase(); for (pos = stack.length - 1; pos &gt;= 0; pos--) &#123; if (stack[pos].lowerCasedTag === lowerCasedTagName) &#123; break &#125; &#125; &#125; else &#123; // If no tag name is provided, clean shop pos = 0; &#125; if (pos &gt;= 0) &#123; // Close all the open elements, up the stack for (var i = stack.length - 1; i &gt;= pos; i--) &#123; if (options.end) &#123; options.end(stack[i].tag, start, end); &#125; &#125; // Remove the open elements from the stack stack.length = pos; lastTag = pos &amp;&amp; stack[pos - 1].tag; &#125; &#125;&#125; 接着看end钩子函数的处理逻辑，大致意思是取出stack栈中最后一项element，接着又使用closeElement来构建elemenet这个ast对象的父子级关系，currentParent又指定stack栈中的最后一项。需要注意的是parse函数里面的stack栈和parseHTML函数里面的stack栈不是一回事，parse函数里面的stack栈中存放的是ast对象，parseHTML函数里面的stack栈存放的是所有开始标签的信息。 1234567891011121314151617181920212223242526272829function parse(template,options) &#123; // ...此处省略部分代码 var stack = []; var root; var currentParent; parseHTML(template, &#123; start: function start()&#123;&#125;, end: function end() &#123; var element = stack[stack.length - 1]; // pop stack stack.length -= 1; currentParent = stack[stack.length - 1]; if (options.outputSourceRange) &#123; element.end = end$1; &#125; closeElement(element); &#125;, // 解析到文本的钩子函数 chars: function ()&#123;&#125; &#125;) return root&#125;// 构建ast对象的父子级关系function closeElement (element)&#123; // 此处省略若干代码 currentParent.children.push(element); element.parent = currentParent;&#125; 最终返回的root根元素就是最终的ast树。以上，就是Vue内部如何把一个html字符串转换成ast树的过程，我们看看ast树的结构,其中包含了父子级关系，if for directives等指令标记，节点自身的相关信息","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"1. Vue如何构建响应式系统?","slug":"vue01","date":"2020-11-21T11:07:30.000Z","updated":"2020-12-17T13:50:23.756Z","comments":true,"path":"2020/11/21/vue01/","link":"","permalink":"http://example.com/2020/11/21/vue01/","excerpt":"","text":"响应式系统入口vue2.x版本的响应系统入口是observe函数，先看下Vue内部的处理： observe &amp; Observer 可以看到observe函数只检测数组和普通对象，并对数组和普通对象做了不同处理 Observer类的实例会有dep属性，该属性用来指向dep订阅器对象，注意：初始化时dep订阅器对象为空。dep属性的作用是什么？我们会在Vue如何构建依赖关系时讲到。 def(value, &#39;__ob__&#39;, this)其实就是给观测的数组/普通对象添加__ob__属性，值指向Observer的实例，__ob__属性的作用是什么？我们会在Vue的更新策略时讲到。 12345678910111213141516171819202122232425262728function observe(value, asRootData) &#123; var ob; if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__; &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value); &#125; return ob&#125; var Observer = function Observer(value) &#123; this.value = value; this.dep = new Dep(value); this.vmCount = 0; def(value, &#x27;__ob__&#x27;, this); if (Array.isArray(value)) &#123; //构建数组对象的响应式系统 protoAugment(value, arrayMethods); this.observeArray(value); &#125; else &#123; //构建普通对象的响应式系统 this.walk(value); &#125; &#125;; 普通对象Object.defineProperty可以看到构建数据对象data的响应式系统很简单，就是用Object.defineProperty给data的每个key都设置get/set钩子,用户每次获取值的时候例如this.data.msg，都会触发key的get钩子，设置新值的时候例如this.data.msg=&#39;新的msg&#39;，都会触发key的set钩子从而让视图更新，不过视图更新我们会在Vue的更新策略讨论,不管怎样，普通对象的响应式系统确实是通过 Object.defineProperty这个API很轻易的构建出来了。 123456789101112131415161718192021222324252627282930313233343536373839Observer.prototype.walk = function walk(obj) &#123; var keys = Object.keys(obj); for (var i = 0; i &lt; keys.length; i++) &#123; defineReactive$$1(obj, keys[i]); &#125;&#125;;function defineReactive$$1( obj, key, val, customSetter, shallow ) &#123; var dep = new Dep(key); var childOb = !shallow &amp;&amp; observe(val); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; var value = getter ? getter.call(obj) : val; // TODO return value &#125;, set: function reactiveSetter(newVal) &#123; var value = getter ? getter.call(obj) : val; // 老值和新值相等 就终止函数 if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; if (customSetter) &#123; customSetter(); &#125; if (getter &amp;&amp; !setter) &#123; return &#125; if (setter) &#123; setter.call(obj, newVal); &#125; else &#123; val = newVal; &#125; // 劫持新设置的值 childOb = !shallow &amp;&amp; observe(newVal); dep.notify(); &#125; &#125;); &#125; 数据代理还有一个问题，平时我们都是this.msg就可以获取data中的msg了，现在这个响应式系统只能通过this.data.msg拿到data中的msg。很显然，这个响应式系统并不完善，我们看看vue源码如何实现更完善的响应式系统的？ 把数据对象data数据对象存到_data中 触发proxy函数，proxy函数的功能就是每次访问vm[key]时都会返回vm._data[key]属性以上就实现了更完善的响应式系统了。1234567891011121314151617181920212223function initData(vm) &#123; var data = vm.$options.data; data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125;; var keys = Object.keys(data); var i = keys.length; while (i--) &#123; proxy(vm, &quot;_data&quot;, key); &#125;&#125;// 数据代理function proxy(target, sourceKey, key) &#123; sharedPropertyDefinition.get = function proxyGetter() &#123; return this[sourceKey][key] &#125;; sharedPropertyDefinition.set = function proxySetter(val) &#123; this[sourceKey][key] = val; &#125;; // vm.msg --&gt; vm._data.msg Object.defineProperty(target, key, sharedPropertyDefinition);&#125; 数组对象普通对象的响应式系统已经构建完成了，我们接下来再看看数组对象是如何构建响应式系统的？ 123456789101112131415161718var Observer = function Observer(value) &#123; this.value = value; this.dep = new Dep(value); this.vmCount = 0; def(value, &#x27;__ob__&#x27;, this); if (Array.isArray(value)) &#123; protoAugment(value, arrayMethods); this.observeArray(value); &#125; else &#123; this.walk(value); &#125;&#125;;// 修改隐式原型function protoAugment(target, src) &#123; target.__proto__ = src;&#125; 可以看到，当处理数组的时候会触发protoAugment函数把数组的隐式原型__proto__指向了arrayMethods,那arrayMethods是什么呢？看下面的代码可知： arrayMethods是一个空对象，其隐式原型__proto__指向了Array.prototype，这样的话，在arrayMethods这个对象的原型链上就有了数组的所有方法了。 遍历methodsToPatch，给arrayMethods对象添加push,pop,shift,unshift,splice,sort,reverse这七个属性，值是mutator函数 123456789101112131415161718192021222324252627282930313233343536373839var arrayProto = Array.prototype;var arrayMethods = Object.create(arrayProto); var methodsToPatch = [ &#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;];methodsToPatch.forEach(function (method) &#123; // 基于原型链获取数组原型上的方法 var original = arrayProto[method]; // 给arrayMethods对象设置method属性 即arrayMethods[&#x27;push&#x27;] = mutator def(arrayMethods, method, function mutator() &#123; var args = [], len = arguments.length; while (len--) args[len] = arguments[len]; var result = original.apply(this, args); var ob = this.__ob__; var inserted; switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args; break case &#x27;splice&#x27;: inserted = args.slice(2); break &#125; if (inserted) &#123; ob.observeArray(inserted); &#125; // notify change ob.dep.notify(); return result &#125;);&#125;); 可以看到，最终的arrayMethods就是上面的结构，它是一个对象，自身有7个属性，隐式原型上有所有的数组方法，想象一下，如果我们执行this.list.push(2)，就会沿着原型链找到arrayMethods对象上的push方法执行，即mutator函数，mutator函数内部的逻辑其实就是触发视图更新。这个我们在后面章节Vue的更新策略讨论 ，不管怎样，数组对象的响应式系统确实是通过延长数组对象的原型链构建出来了。 需要注意的是，对于数组，Vue只为methodsToPatch中的7个方法构建了响应式系统，对于其他的数组方法，Vue并没有构建响应式系统。 结束以上，就是Vue如何为数组对象/普通对象构建响应式系统的过程。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"浏览器缓存策略","slug":"cache","date":"2020-11-19T15:49:23.000Z","updated":"2020-12-28T04:58:04.574Z","comments":true,"path":"2020/11/19/cache/","link":"","permalink":"http://example.com/2020/11/19/cache/","excerpt":"","text":"当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。1.目录结构如下 2.首页结构1234567891011121314151617&lt;!-- cache.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;data:image/ico;base64,aWNv&quot;&gt; &lt;title&gt;基于node学习浏览器缓存策略&lt;/title&gt; &lt;script src=&quot;/script.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是服务首页&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 3.搭建服务123456789101112// app.jsconst http = require(&#x27;http&#x27;);const fs = require(&#x27;fs&#x27;);http.createServer((request, response) =&gt; &#123; if (request.url === &#x27;/&#x27;) &#123; const readStream = fs.createStream(&#x27;./cache.html&#x27;); readStream.pipe(response) &#125;else if (/\\.js$/.test(request.url)) &#123; const readStream = fs.createReadStream(&#x27;./script.js&#x27;); readStream.pipe(response) &#125;&#125;) 4.强缓存触发浏览器强缓存策略需要后端配置特殊字段Expires/Cache-Control均可，并且返回状态码2001234567891011121314151617http.createServer((request, response) =&gt; &#123; if (request.url === &#x27;/&#x27;) &#123; const readStream = fs.createStream(&#x27;./cache.html&#x27;); readStream.pipe(response) &#125;else if (/\\.js$/.test(request.url)) &#123; // Expires字段设置的时间是固定的某个时间点 // response.writeHead(200, &#123; // &#x27;Expires&#x27;: new Date(&#x27;2020-12-30 12:00:00&#x27;), // &#125;); // Cache-Control字段设置的是相对于本次服务端返回的时间 单位s response.writeHead(200, &#123; &#x27;Cache-Control&#x27;: &#x27;max-age=200&#x27; &#125;); const readStream = fs.createReadStream(&#x27;./script.js&#x27;); readStream.pipe(response) &#125;&#125;) 第一次访问资源命中强缓存之后，浏览器就不会同样的资源发起网络请求了，浏览器会直接强制从memory(内存)/disk(硬盘)中读取资源，如下所示 5.协商缓存触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified/Etag均可，并且返回状态码30412345678910111213141516171819202122232425262728293031323334353637http.createServer((request, response) =&gt; &#123; if (request.url === &#x27;/&#x27;) &#123; const readStream = fs.createStream(&#x27;./cache.html&#x27;); readStream.pipe(response) &#125;else if (/\\.js$/.test(request.url)) &#123; // const buffer = fs.readFileSync(&#x27;./script.js&#x27;); // const fileMd5 = md5(buffer); 文件的md5值 // const noneMatch = request.headers[&#x27;if-none-match&#x27;]; 来自浏览器端传递的值 // 协商成功 状态码返回304 // if (noneMatch === fileMd5) &#123; // response.statusCode = 304; // response.end(); // return; // &#125; // 协商失败 状态码返回200 // response.writeHead(200, &#123; // &#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;, // &#x27;ETag&#x27;: fileMd5, // &#125;); const stat = fs.statSync(&#x27;./script.js&#x27;); const mtime = stat.mtime.toGMTString() const requestMtime = request.headers[&#x27;if-modified-since&#x27;]; // 协商成功 本次服务端不返回资源 让浏览器使用缓存的资源 if (mtime === requestMtime) &#123; response.statusCode = 304; //必须返回304 response.end(); return; &#125; // 协商失败 状态码返回200 response.writeHead(200, &#123; &#x27;Last-Modified&#x27;: mtime, &#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;, // 必须设置，否则下次浏览器请求会命中强缓存 &#125;); const readStream = fs.createReadStream(&#x27;./script.js&#x27;); readStream.pipe(response); &#125;&#125;) 第一次访问资源命中协商缓存之后，浏览器会在下次网络请求中用特殊字段(if-modified-since/if-no-match)携带第一次访问后端时返回的响应头信息，后端在对比前后数据之后，判断资源的内容是否更改，如果更改，就协商失败，返回最新的资源给浏览器，如果没有更改，就协商成功，不返回数据给浏览器，浏览器最终使用缓存的资源 6.强缓存和协商缓存对比6.1 强缓存优先级比协商缓存高，因为浏览器总是倾向于请求更少的资源，命中强缓存后，浏览器都不会向后端请求资源了，所以强缓存优先级比协商缓存高6.2 判断是否命中强缓存的纬度是时间，Expires是固定时间，Cache-Control是相对时间 ;判断是否命中协商缓存的纬度是资源内容是否被更改，Last-Modified是用资源的修改时间，Etag是用资源的hash值","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-11-16T16:51:19.875Z","updated":"2020-11-19T15:35:10.620Z","comments":true,"path":"2020/11/17/hello-world/","link":"","permalink":"http://example.com/2020/11/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"面试题","slug":"面试题","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"},{"name":"Node","slug":"Node","permalink":"http://example.com/categories/Node/"},{"name":"JS","slug":"JS","permalink":"http://example.com/categories/JS/"},{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]}