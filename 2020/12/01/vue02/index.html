<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> 2. Vue如何编译模版? · Hexo</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="2. Vue如何编译模版? - heaven"><meta name="keywords"><meta name="author" content="heaven"><link rel="short icon" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/favicon.ico"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="Hexo"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/live/" target="_self" data-hover="生活" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="/categories/read/" target="_self" data-hover="读书" class="nav-list-link">读书</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">2. Vue如何编译模版?</h1><div class="post-info">2020-12-01<p class="visit"><i data-identity="2020/12/01/vue02/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><p>Vue上手非常简单，因为我们可以直接编写html作为组件的模版，对比学习React还需要接触<code>jsx</code>语法，Vue对新手可以说是非常友好了，接下来我们看看vue是如何处理template模版的？</p>
<h2 id="Vue编译器入口"><a href="#Vue编译器入口" class="headerlink" title="Vue编译器入口"></a>Vue编译器入口</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createCompiler = createCompilerCreator(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span>(<span class="params">template, options</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// template -&gt; ast   对template的第一层抽象</span></span><br><span class="line">        <span class="keyword">var</span> ast = parse(template.trim(), options);</span><br><span class="line">        <span class="comment">// 优化ast树 标注静态节点</span></span><br><span class="line">        <span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">            optimize(ast, options);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ast -&gt; 可执行code  对template的第二层抽象</span></span><br><span class="line">        <span class="keyword">var</span> code = generate(ast, options);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ast: ast,</span><br><span class="line">            render: code.render,</span><br><span class="line">            staticRenderFns: code.staticRenderFns</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>可以看到首先是template模版放到parse函数中处理，得到ast对象(abstract syntax tree)，其实ast对象是对template的第一层抽象，template模版本质上是一个html字符串，现在用ast对象来描述template模版，接下来看看html字符串如何被转换成ast对象的？假定template模版如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html模版</span></span><br><span class="line"><span class="keyword">let</span> template = <span class="string">`</span></span><br><span class="line"><span class="string">     &lt;div id=app v-if=&#x27;msg&#x27; v-for=&#x27;item in 3&#x27; v-once:click=&#x27;handleClick&#x27;&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&#x27;text&#x27; title=&#x27;heaven&#x27;&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">        <span class="comment">// 解析到开始标签的钩子函数</span></span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        <span class="comment">//  解析到结束标签的钩子函数</span></span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        <span class="comment">// 解析到文本的钩子函数</span></span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="parseHTML-编译模版"><a href="#parseHTML-编译模版" class="headerlink" title="parseHTML 编译模版"></a>parseHTML 编译模版</h2><p>可以看到真正处理template的是parseHTML这个函数，我们看看这个函数内部的逻辑是什么？其实大致有4步</p>
<ol>
<li>定义token，这些token用来解析开始标签 标签属性 结束标签等</li>
<li>处理开始标签，并把处理的结果交给handleStartTag处理</li>
<li>处理结束标签，并把处理的结果交给parseEndTag处理</li>
<li>处理文本，并把文本交给chars钩子函数处理<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  解析属性的token id=&#x27;app&#x27;</span></span><br><span class="line"><span class="keyword">var</span> attribute = <span class="regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span>;</span><br><span class="line"><span class="keyword">var</span> ncname = <span class="string">&quot;[a-zA-Z_][\\-\\.0-9_a-zA-Z&quot;</span> + (unicodeRegExp.source) + <span class="string">&quot;]*&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> qnameCapture = <span class="string">&quot;((?:&quot;</span> + ncname + <span class="string">&quot;\\:)?&quot;</span> + ncname + <span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="comment">// 解析开始标签的token &lt;div </span></span><br><span class="line"><span class="keyword">var</span> startTagOpen = <span class="keyword">new</span> <span class="built_in">RegExp</span>((<span class="string">&quot;^&lt;&quot;</span> + qnameCapture));</span><br><span class="line"><span class="comment">// 解析开始标签结束的token /&gt;  &gt;</span></span><br><span class="line"><span class="keyword">var</span> startTagClose = <span class="regexp">/^\s*(\/?)&gt;/</span>;</span><br><span class="line"><span class="comment">// 解析结束标签的token &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> endTag = <span class="keyword">new</span> <span class="built_in">RegExp</span>((<span class="string">&quot;^&lt;\\/&quot;</span> + qnameCapture + <span class="string">&quot;[^&gt;]*&gt;&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseHTML</span>(<span class="params">html, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (html) &#123;</span><br><span class="line">        <span class="keyword">var</span> textEnd = html.indexOf(<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">        <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">        <span class="comment">// 处理开始标签</span></span><br><span class="line">        <span class="keyword">var</span> startTagMatch = parseStartTag();</span><br><span class="line">        <span class="keyword">if</span> (startTagMatch) &#123;</span><br><span class="line">            handleStartTag(startTagMatch);</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理结束标签</span></span><br><span class="line">        <span class="keyword">var</span> endTagMatch = html.match(endTag);</span><br><span class="line">        <span class="keyword">if</span> (endTagMatch) &#123;</span><br><span class="line">            <span class="keyword">var</span> curIndex = index;</span><br><span class="line">            advance(endTagMatch[<span class="number">0</span>].length);</span><br><span class="line">            parseEndTag(endTagMatch[<span class="number">1</span>], curIndex, index);</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理文本 包括静态文本和插值</span></span><br><span class="line">        <span class="keyword">var</span> text </span><br><span class="line">        <span class="keyword">if</span> (textEnd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">            text = html.substring(<span class="number">0</span>, textEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (text) advance(text.length);</span><br><span class="line">        <span class="keyword">if</span> (options.chars &amp;&amp; text) &#123;</span><br><span class="line">            options.chars(text, index - text.length, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解析开始标签"><a href="#解析开始标签" class="headerlink" title="解析开始标签"></a>解析开始标签</h2>接下来，我们看看parseStartTag函数是如何处理开始标签的？<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制全局的index/html向前移动n</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">advance</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    index += n;</span><br><span class="line">    html = html.substring(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseStartTag</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 解析到开始标签</span></span><br><span class="line">    <span class="keyword">var</span> start = html.match(startTagOpen);</span><br><span class="line">    <span class="keyword">if</span> (start) &#123;</span><br><span class="line">        <span class="keyword">var</span> match = &#123;</span><br><span class="line">            tagName: start[<span class="number">1</span>], </span><br><span class="line">            attrs: [],</span><br><span class="line">            start: index</span><br><span class="line">        &#125;;</span><br><span class="line">        advance(start[<span class="number">0</span>].length);</span><br><span class="line">        <span class="keyword">var</span> end, attr;</span><br><span class="line">        <span class="keyword">while</span> (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(dynamicArgAttribute) || html.match(attribute))) &#123;</span><br><span class="line">            attr.start = index;</span><br><span class="line">            advance(attr[<span class="number">0</span>].length);</span><br><span class="line">            attr.end = index;</span><br><span class="line">            match.attrs.push(attr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end) &#123;</span><br><span class="line">            match.unarySlash = end[<span class="number">1</span>];</span><br><span class="line">            advance(end[<span class="number">0</span>].length);</span><br><span class="line">            match.end = index;</span><br><span class="line">            <span class="keyword">return</span> match</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
最终开始标签<code>&lt;div id=&#39;app&#39;&gt;</code>被解析成下面的结构，其中attrs里面存放开始标签的属性集合，start是开始标签的起始位置，end是开始标签的结束位置，tagName是开始标签的标签类型，unarySlash为空代表标签为双标签，这样开始标签所有信息都被这个对象完美描述了，下面是match的结构图<img src="/images/start.png" width="300px" >

</li>
</ol>
<p>接下来，开始标签的处理结果match还需要交给handleStartTag处理，我们看看handleStartTag内部的逻辑，其实也是很清晰的</p>
<ol>
<li>处理attrs属性，最终把标签的属性改成key:value的形式，并且标记attrs内部的属性开始和结束位置</li>
<li>将开始标签的信息放到stack栈中</li>
<li>触发start钩子函数<br>值的注意的是value值为<code>args[3] || args[4] || args[5]</code>,这是怎么回事呢？<br>这是因为对于属性值的三种形式<code>&lt;div id=&quot;app&quot;&gt;</code> app可以是单引号，双引号，不加引号，分别对应<code>args[3] || args[4] || args[5]</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStartTag</span>(<span class="params">match</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> tagName = match.tagName;</span><br><span class="line">      <span class="keyword">var</span> unarySlash = match.unarySlash;</span><br><span class="line">      <span class="keyword">var</span> unary = isUnaryTag$$1(tagName) || !!unarySlash;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> l = match.attrs.length;</span><br><span class="line">      <span class="keyword">var</span> attrs = <span class="keyword">new</span> <span class="built_in">Array</span>(l);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> args = match.attrs[i];</span><br><span class="line">        <span class="keyword">var</span> value = args[<span class="number">3</span>] || args[<span class="number">4</span>] || args[<span class="number">5</span>] || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        attrs[i] = &#123;</span><br><span class="line">          name: args[<span class="number">1</span>],</span><br><span class="line">          value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (options.outputSourceRange) &#123;</span><br><span class="line">          attrs[i].start = args.start + args[<span class="number">0</span>].match(<span class="regexp">/^\s*/</span>).length;</span><br><span class="line">          attrs[i].end = args.end;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理双标签</span></span><br><span class="line">      <span class="keyword">if</span> (!unary) &#123;</span><br><span class="line">        stack.push(&#123; <span class="attr">tag</span>: tagName, <span class="attr">lowerCasedTag</span>: tagName.toLowerCase(), <span class="attr">attrs</span>: attrs, <span class="attr">start</span>: match.start, <span class="attr">end</span>: match.end &#125;);</span><br><span class="line">        lastTag = tagName;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (options.start) &#123;</span><br><span class="line">        options.start(tagName, attrs, unary, match.start, match.end);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到Vue把数据做了处理之后，又把这些数据交给了start钩子处理，我们看看start钩子里面的逻辑<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createASTElement</span>(<span class="params">tag,attrs,parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="number">1</span>,</span><br><span class="line">      tag: tag,</span><br><span class="line">      attrsList: attrs,</span><br><span class="line">      attrsMap: makeAttrsMap(attrs),</span><br><span class="line">      rawAttrsMap: &#123;&#125;,</span><br><span class="line">      parent: parent,</span><br><span class="line">      children: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">tag, attrs, unary, start$<span class="number">1</span>, end</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> element = createASTElement(tag, attrs, currentParent);</span><br><span class="line">            <span class="keyword">if</span> (options.outputSourceRange) &#123;</span><br><span class="line">                element.start = start$<span class="number">1</span>;</span><br><span class="line">                element.end = end;</span><br><span class="line">                element.rawAttrsMap = element.attrsList.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">cumulated, attr</span>) </span>&#123;</span><br><span class="line">                    cumulated[attr.name] = attr;</span><br><span class="line">                    <span class="keyword">return</span> cumulated</span><br><span class="line">                &#125;, &#123;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理v-for v-if指令</span></span><br><span class="line">            <span class="keyword">if</span> (!element.processed) &#123;</span><br><span class="line">                processFor(element);  </span><br><span class="line">                processIf(element);</span><br><span class="line">                processOnce(element);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解析到的第一个元素 就是根节点</span></span><br><span class="line">            <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">                root = element;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  如果是双标签 那currentParent就指定当前的ast元素，并存到stack栈中</span></span><br><span class="line">            <span class="keyword">if</span> (!unary) &#123;</span><br><span class="line">                currentParent = element;</span><br><span class="line">                stack.push(element);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                closeElement(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其实start钩子内部大致就做了三件事：</li>
<li>根据createASTElement生成一个ast元素，该ast元素也是用来描述开始标签，虽然match也用来描述开始标签，但是JS操作ast元素显然更方便些。</li>
<li>处理开始标签上面的v-if v-for v-once指令 </li>
<li>初始化root currentParent stack的值，其中root存储模版的根节点，currentParent指定当前解析到的ast元素，stack存放解析到的所有ast元素<br>下面是开始标签对应ast元素的结构图:</li>
</ol>
<img src="/images/ast.png" width="600px" >

<h2 id="解析字符文本"><a href="#解析字符文本" class="headerlink" title="解析字符文本"></a>解析字符文本</h2><p>以上就是Vue内部解析开始标签的所有过程了，接下来我们再看看Vue内部如何解析文本的？,根据上面的分析，我们已经知道解析到文本会交给chars钩子处理，我们来看看chars钩子内部的逻辑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        <span class="comment">// 解析到文本的钩子函数</span></span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span> (<span class="params">text, start, end</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> children = currentParent.children;</span><br><span class="line">            <span class="keyword">var</span> res;</span><br><span class="line">            <span class="keyword">var</span> child;</span><br><span class="line">            <span class="comment">//   解析到有插值的文本</span></span><br><span class="line">            <span class="keyword">if</span> (!inVPre &amp;&amp; text !== <span class="string">&#x27; &#x27;</span> &amp;&amp; (res = parseText(text, delimiters))) &#123;</span><br><span class="line">                child = &#123;</span><br><span class="line">                    type: <span class="number">2</span>,</span><br><span class="line">                    expression: res.expression,</span><br><span class="line">                    tokens: res.tokens,</span><br><span class="line">                    text: text</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (text !== <span class="string">&#x27; &#x27;</span> || !children.length || children[children.length - <span class="number">1</span>].text !== <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析到没有插值的文本</span></span><br><span class="line">                child = &#123;</span><br><span class="line">                    type: <span class="number">3</span>,</span><br><span class="line">                    text: text</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chars钩子内部逻辑很简单，就是区分文本是否有插值符号，有插值符号的话ast对象type标记为2，并解析插值，没有插值就当作普通文本处理ast对象type标记为3。下面是插值文本对应的ast对象</p>
<img src="/images/char.png" width="300px" >

<h2 id="解析结束标签"><a href="#解析结束标签" class="headerlink" title="解析结束标签"></a>解析结束标签</h2><p>最后我们再看看Vue内部解析结束标签的过程，,根据上面的分析，我们已经知道解析到结束标签会交给parseEndTag函数处理，来看看parseEndTag函数内部的逻辑。大致意思是取出stack栈中的最后一项，并将最后一项的tag，start，end交给end钩子处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseEndTag</span>(<span class="params">tagName, start, end</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> pos, lowerCasedTagName;</span><br><span class="line">      <span class="keyword">if</span> (start == <span class="literal">null</span>) &#123; start = index; &#125;</span><br><span class="line">      <span class="keyword">if</span> (end == <span class="literal">null</span>) &#123; end = index; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Find the closest opened tag of the same type</span></span><br><span class="line">      <span class="keyword">if</span> (tagName) &#123;</span><br><span class="line">        lowerCasedTagName = tagName.toLowerCase();</span><br><span class="line">        <span class="keyword">for</span> (pos = stack.length - <span class="number">1</span>; pos &gt;= <span class="number">0</span>; pos--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If no tag name is provided, clean shop</span></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Close all the open elements, up the stack</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = stack.length - <span class="number">1</span>; i &gt;= pos; i--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (options.end) &#123;</span><br><span class="line">            options.end(stack[i].tag, start, end);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Remove the open elements from the stack</span></span><br><span class="line">        stack.length = pos;</span><br><span class="line">        lastTag = pos &amp;&amp; stack[pos - <span class="number">1</span>].tag;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看end钩子函数的处理逻辑，大致意思是取出stack栈中最后一项element，接着又使用closeElement来构建elemenet这个ast对象的父子级关系，currentParent又指定stack栈中的最后一项。<br>需要注意的是parse函数里面的stack栈和parseHTML函数里面的stack栈不是一回事，parse函数里面的stack栈中存放的是ast对象，parseHTML函数里面的stack栈存放的是所有开始标签的信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> element = stack[stack.length - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// pop stack</span></span><br><span class="line">            stack.length -= <span class="number">1</span>;</span><br><span class="line">            currentParent = stack[stack.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (options.outputSourceRange) &#123;</span><br><span class="line">                element.end = end$<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            closeElement(element);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 解析到文本的钩子函数</span></span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建ast对象的父子级关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeElement</span> (<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    currentParent.children.push(element);</span><br><span class="line">    element.parent = currentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终返回的root根元素就是最终的ast树。以上，就是Vue内部如何把一个html字符串转换成ast树的过程，我们看看ast树的结构,其中包含了父子级关系，if for directives等指令标记，节点自身的相关信息</p>
<img src="/images/asttree.png" width="600px" >


</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2020/12/03/js%E9%AA%9A%E6%93%8D%E4%BD%9C/" title="js小技巧" class="prev">PREV</a><a href="/2020/11/21/vue01/" title="1. Vue如何构建响应式系统?" class="next">NEXT</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2021 <a target="_blank">heaven</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz", "FdzS5SOPHdhYQoEUngQ8K2QW");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>