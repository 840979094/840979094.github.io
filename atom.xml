<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-24T15:15:21.592Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>heaven</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>7. Vue的组件系统</title>
    <link href="http://example.com/2020/12/20/vue07/"/>
    <id>http://example.com/2020/12/20/vue07/</id>
    <published>2020-12-20T13:21:09.000Z</published>
    <updated>2020-12-24T15:15:21.592Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们讨论的模版都是没有使用组件的，不过我们在开发中，经常会在模版中使用组件的，接下来我们看看在模版中使用组件，Vue内部是如何处理的？<br>假定模版如下所示：在模版中使用了全局组件<code>global-component</code>，局部组件<code>local-component</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">global-component</span>&gt;</span><span class="tag">&lt;/<span class="name">global-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">local-component</span>&gt;</span><span class="tag">&lt;/<span class="name">local-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> Vue.component(<span class="string">&#x27;global-component&#x27;</span>, &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count: <span class="number">0</span>,</span><br><span class="line">            msg: <span class="string">&quot;全局组件&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;&#123;&#123;msg&#125;&#125;count:&#123;&#123; count &#125;&#125;&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LocalComponent = &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count: <span class="number">0</span>,</span><br><span class="line">            msg: <span class="string">&quot;局部组件&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;&#123;&#123;msg&#125;&#125;count:&#123;&#123; count &#125;&#125;&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译组件"><a href="#编译组件" class="headerlink" title="编译组件"></a>编译组件</h2><p>在模版中里引入了两个组件之后，Vue内部依旧会走模版转render函数的流程，如下所示，下面三张图分别对应：</p><ol><li>模版转成AST树</li><li>AST树转可执行代码</li><li>可执行代码转render函数</li></ol><p>其实，不管在模版里面有没有组件，转成render函数的流程都是一样的。如果模版里面有组件的话，也会把组件当作普通的html标签处理。</p><img src="/images/component.png"><img src="/images/comcode.png"><img src="/images/comrender.png"><h2 id="挂载组件"><a href="#挂载组件" class="headerlink" title="挂载组件"></a>挂载组件</h2><p>当把模版转成render函数之后，依旧会执行<code>mountComponent</code>函数走挂载组件的流程，接着是创建渲染watcher，并且触发<code>渲染watcher</code>的求值函数<code>updateComponent</code>，updateComponent的逻辑如下：</p><ol><li><code>vm._render()</code>创建虚拟dom，并收集依赖</li><li><code>vm._update()</code>基于虚拟dom创建真实dom</li></ol><h3 id="区分原生标签-组件"><a href="#区分原生标签-组件" class="headerlink" title="区分原生标签/组件"></a>区分原生标签/组件</h3><p>对于上面的<code>render</code>函数，会使用<code>_c(&#39;global-component&#39;)</code>来创建组件的虚拟dom，我们看看Vue内部是如何创建组件的虚拟dom？<br>可以看到，在<code>_createElement</code>内部分别处理了原生html标签和自定义组件，其中使用<code>new VNode()</code>创建html标签的虚拟dom，使用<code>createComponent</code>创建组件的虚拟dom。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createElement</span>(<span class="params">context,tag,data,children,normalizationType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">      children = normalizeChildren(children);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">      children = simpleNormalizeChildren(children);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> vnode;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> Ctor;</span><br><span class="line">        <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">            <span class="comment">// platform built-in elements</span></span><br><span class="line">            vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">            config.parsePlatformTagName(tag), data, children,</span><br><span class="line">            <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">            <span class="comment">// component</span></span><br><span class="line">            vnode = createComponent(Ctor, data, context, children, tag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAsset</span>(<span class="params">options,type,id,warnMissing</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> assets = options[type];</span><br><span class="line">    <span class="keyword">if</span> (hasOwn(assets, id)) &#123; <span class="keyword">return</span> assets[id] &#125;</span><br><span class="line">    <span class="keyword">var</span> camelizedId = camelize(id);</span><br><span class="line">    <span class="keyword">if</span> (hasOwn(assets, camelizedId)) &#123; <span class="keyword">return</span> assets[camelizedId] &#125;</span><br><span class="line">    <span class="keyword">var</span> PascalCaseId = capitalize(camelizedId);</span><br><span class="line">    <span class="keyword">if</span> (hasOwn(assets, PascalCaseId)) &#123; <span class="keyword">return</span> assets[PascalCaseId] &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res = assets[id] || assets[camelizedId] || assets[PascalCaseId];</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面有两个关键的变量<code>Ctor，resolveAsset</code>，<code>Ctor</code>是<code>resolveAsset</code>的返回值。当执行<code>resolveAsset</code>时，传入的参数分别是<code>context.$options, components, global-component</code>，函数的处理逻辑如下：</p><ol><li><code>assets</code>存放<code>options[&#39;components&#39;]</code>的值。</li><li>如果<code>assets</code>私有属性上有<code>global-component</code>,那就返回</li><li>如果<code>assets</code>原型链上有<code>global-component</code>,那就返回</li></ol><p>值得注意的是，<code>global-component</code>是全局组件，所以会保存在<code>assets</code>的原型链上,<code>local-component</code>是局部组件，所以会保存在<code>assets</code>的私有属性上，如下图所示：<br>其中<code>KeepAlive Transtion TransitionGroup</code>都是Vue内置的全局组件</p><img src="/images/assets.png" width='400px'><h3 id="创建组件的虚拟dom"><a href="#创建组件的虚拟dom" class="headerlink" title="创建组件的虚拟dom"></a>创建组件的虚拟dom</h3><p>根据上图可以看到，传入全局组件<code>global-component</code>返回的<code>Ctor</code>是组件的构造函数<code>VueComponent</code>，传入局部组件<code>local-component</code>返回的<code>Ctor</code>是配置对象。接着就把<code>Ctor</code>传入<code>createComponent</code>函数执行，<code>createComponent</code>函数里的处理如下：</p><ol><li><code>baseCtor</code>指向<code>Vue</code></li><li>如果是局部组件，就把<code>Ctor</code>这个配置对象传入<code>Vue.extend</code>，并返回组件的构造函数<code>VueComponent</code>。</li><li>如果是函数组件，就使用<code>createFunctionalComponent</code>来创建函数组件</li><li>执行<code>installComponentHooks</code>函数往<code>data</code>对象上挂载四个钩子函数，分别是<code>init prepatch insert destroy</code></li><li>执行<code>new VNode</code>创建组件的虚拟dom，值得注意的是，创建组件的虚拟dom，会把组件的配置对象当作第七个参数传入并存到组件虚拟dom的<code>componentOptions</code>中，这是创建html的虚拟dom是没有的。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>(<span class="params"> Ctor, data, context,children,tag</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> baseCtor = context.$options._base;</span><br><span class="line">    <span class="keyword">if</span> (isObject(Ctor)) &#123;</span><br><span class="line">      Ctor = baseCtor.extend(Ctor);</span><br><span class="line">    &#125;</span><br><span class="line">    data = data || &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (isTrue(Ctor.options.functional)) &#123;</span><br><span class="line">      <span class="keyword">return</span> createFunctionalComponent(Ctor, propsData, data, context, children)</span><br><span class="line">    &#125;</span><br><span class="line">    installComponentHooks(data);</span><br><span class="line">    <span class="keyword">var</span> name = Ctor.options.name || tag;</span><br><span class="line">    <span class="keyword">var</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">      (<span class="string">&quot;vue-component-&quot;</span> + Ctor.cid + (name ? <span class="string">&quot;-&quot;</span> + name : <span class="string">&#x27;&#x27;</span>)),</span><br><span class="line">      data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">      &#123; <span class="attr">Ctor</span>: Ctor, <span class="attr">propsData</span>: propsData, <span class="attr">listeners</span>: listeners, <span class="attr">tag</span>: tag, <span class="attr">children</span>: children &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installComponentHooks</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hooks = data.hook || (data.hook = &#123;&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; hooksToMerge.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> key = hooksToMerge[i];</span><br><span class="line">        <span class="keyword">var</span> existing = hooks[key];</span><br><span class="line">        <span class="keyword">var</span> toMerge = componentVNodeHooks[key];</span><br><span class="line">        <span class="keyword">if</span> (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) &#123;</span><br><span class="line">            hooks[key] = existing ? mergeHook$<span class="number">1</span>(toMerge, existing) : toMerge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> componentVNodeHooks = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    prepatch: <span class="function"><span class="keyword">function</span> <span class="title">prepatch</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    insert: <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    destroy: <span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终组件的虚拟dom如下：<br><img src="/images/comVnode.png"></p><h3 id="Vue-extend建立继承关系"><a href="#Vue-extend建立继承关系" class="headerlink" title="Vue.extend建立继承关系"></a>Vue.extend建立继承关系</h3><p>值得注意的是<code>Vue</code>和<code>VueComponent</code>都是构造函数，其中<code>Vue</code>是根组件的构造函数，<code>VueComponent</code>是组件的构造函数，并且<code>VueComponent</code>继承了<code>Vue</code>，这两者的继承关系就是通过<code>Ctor = Vue.extend(Ctor)</code>实现的，我们看看<code>Vue.extend</code>内部的代码：</p><ol><li><code>cachedCtors</code>对象用来缓存组件构造函数<code>VueComponent</code></li><li>执行<code>Sub.prototype = Object.create(Super.prototype)</code>，通过原型链继承，是的<code>Sub.prototype</code>的原型链上有<code>Super.prototype</code>的所有方法。这样组件的实例对象就有<code>Vue.prototype</code>的所有方法了。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">var</span> Super = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> SuperId = Super.cid;</span><br><span class="line">    <span class="keyword">var</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;);</span><br><span class="line">    <span class="keyword">if</span> (cachedCtors[SuperId]) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedCtors[SuperId]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>._init(options);</span><br><span class="line">    &#125;;</span><br><span class="line">    Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">    Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line">    cachedCtors[SuperId] = Sub;</span><br><span class="line">    <span class="keyword">return</span> Sub</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建组件的真实dom"><a href="#创建组件的真实dom" class="headerlink" title="创建组件的真实dom"></a>创建组件的真实dom</h3><p>以上就是创建全局组件<code>global-component</code>对应的虚拟dom的过程。当然创建局部组件<code>local-component</code>的虚拟dom也是一样的，在创建好虚拟dom之后，就要把虚拟dom传入到<code>vm._update</code>中去处理了。</p><p>当首次挂载组件时，必然会走到<code>_update</code>函数里的第一个if判断中，并走到createElm函数来创建真实dom。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode, hydrating</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> prevEl = vm.$el;</span><br><span class="line">    <span class="keyword">var</span> prevVnode = vm._vnode;</span><br><span class="line">    vm._vnode = vnode;</span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vm.$el = vm.__patch__(prevVnode, vnode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">var</span> isRealElement = isDef(oldVnode.nodeType);</span><br><span class="line">    <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createElm( vnode, insertedVnodeQueue, oldElm._leaveCb ? <span class="literal">null</span> : parentElm,nodeOps.nextSibling(oldElm) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看createElm内部是如何处理的？其逻辑如下：</p><ol><li>把根节点交给<code>createComponent</code>处理，处理的结果为false</li><li>再把根节点及其子节点交给<code>createChildren</code>函数处理，其实就是遍历根节点的子节点，再次交给<code>createElm</code>函数去处理</li><li>根节点的子节点分别是<code>global-component，local-component</code>的虚拟dom，<code>createElm</code>内部的<code>createComponent</code>先处理<code>global-component</code>的虚拟dom</li><li>在<code>createComponent</code>函数中，取出组件的<code>init</code>钩子执行来初始化组件。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span>(<span class="params"> vnode,insertedVnodeQueue,parentElm,refElm</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> data = vnode.data;</span><br><span class="line">    <span class="keyword">var</span> children = vnode.children;</span><br><span class="line">    <span class="keyword">var</span> tag = vnode.tag;</span><br><span class="line">    createChildren(vnode, children, insertedVnodeQueue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createChildren</span>(<span class="params">vnode, children, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">        createElm(children[i], insertedVnodeQueue, vnode.elm, <span class="literal">null</span>, <span class="literal">true</span>, children, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>(<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = vnode.data;</span><br><span class="line">    <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;</span><br><span class="line">            i(vnode, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们看看<code>init</code>函数里是如何初始化组件的，流程如下：</p><ol><li>如果组件的虚拟dom<code>vnode</code>上有<code>componentInstance keepAlive</code>，并且组件没有被销毁，就判定组件需要被缓存</li><li>如果组件不是缓存的组件，那就执行<code>createComponentInstanceForVnode</code>来初始化组件.<br> 2.1 <code>createComponentInstanceForVnode</code>函数里中<code>vnode.componentOptions.Ctor</code>指向组件的构造函数<code>VueComponent</code><br> 2.2 创建组件实例的过程，也会为组件的数据对象<code>data</code>构建响应式系统，编译组件模版最终生成<code>render</code>函数等，流程和根组件一致。</li><li>执行<code>child.$mount</code>来挂载组件，因为<code>VueComponent</code>和<code>Vue</code>的继承关系已经通过<code>Vue.extend</code>建立了，所以<code>child</code>上有<code>$mount</code>方法。<br> 3.1 组件挂载的过程，也会创建<code>渲染watcher lazyWatcher 自定义watcher</code>等，并建立属性和<code>watcher</code>的依赖关系，流程和根组件一致。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> componentVNodeHooks = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">vnode, hydrating</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            vnode.componentInstance &amp;&amp; </span><br><span class="line">            !vnode.componentInstance._isDestroyed &amp;&amp; </span><br><span class="line">            vnode.data.keepAlive</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">var</span> mountedNode = vnode; <span class="comment">// work around flow</span></span><br><span class="line">            componentVNodeHooks.prepatch(mountedNode, mountedNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> child = vnode.componentInstance = createComponentInstanceForVnode(vnode,activeInstance);</span><br><span class="line">            child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponentInstanceForVnode</span>(<span class="params"> vnode,parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">        _isComponent: <span class="literal">true</span>,</span><br><span class="line">        _parentVnode: vnode,</span><br><span class="line">        parent: parent</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> vnode.componentOptions.Ctor(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="keep-alive组件的实现原理"><a href="#keep-alive组件的实现原理" class="headerlink" title="keep-alive组件的实现原理"></a>keep-alive组件的实现原理</h2><h2 id="函数式组件的实现原理"><a href="#函数式组件的实现原理" class="headerlink" title="函数式组件的实现原理"></a>函数式组件的实现原理</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前我们讨论的模版都是没有使用组件的，不过我们在开发中，经常会在模版中使用组件的，接下来我们看看在模版中使用组件，Vue内部是如何处理的？&lt;br&gt;假定模版如下所示：在模版中使用了全局组件&lt;code&gt;global-component&lt;/code&gt;，局部组件&lt;code&gt;loca</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>6. Vue的diff算法</title>
    <link href="http://example.com/2020/12/19/vue06/"/>
    <id>http://example.com/2020/12/19/vue06/</id>
    <published>2020-12-19T07:03:14.000Z</published>
    <updated>2020-12-22T10:30:33.580Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们已经知道在触发更新后，<code>渲染watcher</code>会重新触发求值函数，求值函数内部先要<code>vm._render()</code>生成新值对应的虚拟dom，并把结果交给<code>vm._update</code>处理，接下来我们看看<code>vm._update</code>内部的实现逻辑？</p><ol><li><code>prevVnode</code>存储上次更新时的虚拟dom</li><li><code>vm._vnode</code>存储本次更新时的虚拟dom</li><li>如果<code>prevVnode</code>没有值，即首次挂载组件，则创建真实dom</li><li>如果<code>prevVnode</code>有值，即非首次挂载组件，那就把更新前后的虚拟dom传入<code>vm.__patch__</code>函数中去比较。</li></ol><p>显然组件更新时，应该走进else语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    vm._update(vm._render(), hydrating);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode, hydrating</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> prevEl = vm.$el;</span><br><span class="line">    <span class="keyword">var</span> prevVnode = vm._vnode;</span><br><span class="line">    vm._vnode = vnode;</span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">        <span class="comment">// initial render</span></span><br><span class="line">        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// updates</span></span><br><span class="line">        vm.$el = vm.__patch__(prevVnode, vnode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="diff算法的入口"><a href="#diff算法的入口" class="headerlink" title="diff算法的入口"></a>diff算法的入口</h2><p>函数<code>vm.__patch__</code>是Vue的diff算法入口，我们看看内部是如何处理的？</p><ol><li>判断当前虚拟dom是否是静态节点，如果是静态节点，那就不再进行比较了。</li><li>把新老虚拟dom，放到<code>cbs.update</code>数组中各个函数去比较，其中<code>cbs.update</code>数组中各函数的作用是比较虚拟dom的属性</li><li>把新老虚拟dom,放到<code>updateChildren</code>函数中去比较，比较出差异，最终更新视图</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span>(<span class="params"> oldVnode,vnode</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">if</span> (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) &#123;</span><br><span class="line">        vnode.componentInstance = oldVnode.componentInstance;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data = vnode.data;</span><br><span class="line">    <span class="keyword">var</span> oldCh = oldVnode.children;</span><br><span class="line">    <span class="keyword">var</span> ch = vnode.children;</span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) &#123; cbs.update[i](oldVnode, vnode); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) &#123; updateChildren(elm, oldCh, ch) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较虚拟dom的data"><a href="#比较虚拟dom的data" class="headerlink" title="比较虚拟dom的data"></a>比较虚拟dom的data</h2><p>上面说到的<code>cbs.update</code>的结构以及假定本次生成的虚拟dom如下，其中：</p><ol><li><code>updateAttrs</code>是用来比对attrs的差异并更新的</li><li><code>updateclass</code>是用来比对class的差异并更新的</li><li><code>updateDomListeners</code>是用来比对绑定事件的差异并更新的</li><li><code>updateDOMProps</code>是用来比对</li><li><code>updateStyle</code>是用来比对样式的差异并更新的</li><li><code>update</code>是用来比对ref的差异并更新的</li><li><code>updateDirectives</code>是用来比对自定义指令的差异并更新的<br>具体详情见:<a href="https://cn.vuejs.org/v2/guide/render-function.html">https://cn.vuejs.org/v2/guide/render-function.html</a><br>归根结底，<code>cbs.update</code>内部的函数其实就是用来找到<code>虚拟dom上的</code>所有属性并更新的，不过上面的比较方式是有弊端的，如果我本次没有更新这些虚拟dom上的属性，Vue内部还是会比较dom上的全部属性(全量比较)。<br>其实当我们没有更新虚拟dom上的属性时，最好的做法就是不比较，只有在更新某些属性的时候，我们再比较这些更新的属性。这样做可以节省无谓的比较次数。当然Vue2.x采用的是全量比较，在Vue3中就给需要更新的属性加上flag，只更新有flag的属性值。这也是Vue3的性能比Vue2好的一个原因。</li></ol><img src="/images/vdom.png" width='400px'><img src="/images/updatefn.png" width='400px'><h2 id="比较虚拟dom的children"><a href="#比较虚拟dom的children" class="headerlink" title="比较虚拟dom的children"></a>比较虚拟dom的children</h2><p>如果说上面的<code>cbs.update</code>函数是用来比较<code>虚拟dom属性</code>的差异，那<code>updateChildren</code>就是用来比较<code>虚拟dom的子节点</code>差异的，我们接下来看看<code>updateChildren</code>的内部实现：</p><ol><li>定义四个指针，其中<code>oldStartIdx,oldEndIdx</code>指向更新前虚拟dom(老虚拟dom)的首尾索引，<code>newStartIdx,newEndIdx</code>指向更新后(新虚拟dom)的首尾索引。</li><li>再定义四个指针，其中<code>oldStartVnode,oldEndVnode</code>指向更新前虚拟dom的首尾节点，<code>newStartVnode,newEndVnode</code>指向更新后(新虚拟dom)的首尾节点。</li><li>启动while循环，前两个判断是处理越界情况的并不是重点，重要的是后面四个else if判断，分别是：<ol><li>判断老dom的头和新dom中的头是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动<code>oldStartIdx,newStartIdx,oldStartVnode,newStartVnode</code>指针。</li><li>判断老dom的尾和新dom中的尾是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动<code>oldEndIdx,newEndIdx,oldEndVnode,newEndVnode</code>指针。</li><li>判断老dom的头和新dom中的尾是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动<code>oldStartIdx,newEndIdx,oldStartVnode,newEndVnode</code>指针。</li><li>判断老dom的尾和新dom中的头是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动<code>oldEndIdx,newStartIdx,oldEndVnode,newStartVnode</code>指针。</li><li>如果上面四个判断都没走进去，那就基于本次添加的新dom创建真实dom，并添加到页面上。<br>归根结底上面的四个判断，<code>其实就是老头对新头，老尾对新尾，老头对新尾，老尾对新头的比较，这样比较的好处是尽可能多的复用老的虚拟dom</code>。</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oldStartIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> newStartIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> oldEndIdx = oldCh.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> oldStartVnode = oldCh[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">    <span class="keyword">var</span> newEndIdx = newCh.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> newStartVnode = newCh[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> newEndVnode = newCh[newEndIdx];</span><br><span class="line">    <span class="keyword">var</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]; <span class="comment">// Vnode has been moved left</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">            newEndVnode = newCh[--newEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">            newEndVnode = newCh[--newEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isUndef(oldKeyToIdx)) &#123; </span><br><span class="line">                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); </span><br><span class="line">            &#125;</span><br><span class="line">            idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">            <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vnodeToMove = oldCh[idxInOld];</span><br><span class="line">                <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">                    patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class="line">                    oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">                    canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">        refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm;</span><br><span class="line">        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sameVNode"><a href="#sameVNode" class="headerlink" title="sameVNode"></a>sameVNode</h2><p>上面的<code>updateChildren</code>函数中用到<code>sameVNode</code>来判断是否是同一个虚拟dom，我们看看内部是如何判断的？</p><ol><li><code>key</code>值必须相同，在没有给虚拟dom添加<code>key</code>的情况下，<code>key</code>都是<code>undefined</code>，所以在没有手动添加key的情况下<code>a.key===b.key</code>成立，都是<code>undefined</code>。</li><li><code>tag</code>值必须相同，即虚拟dom对应的标签名必须一样。</li><li>对应<code>input</code>标签，<code>type</code>值必须相同。</li></ol><p>满足以上条件，才会判定是同一个虚拟dom。才会有走到同一个虚拟dom的<code>patch</code>逻辑中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        a.key === b.key &amp;&amp; (</span><br><span class="line">        (</span><br><span class="line">            a.tag === b.tag &amp;&amp;</span><br><span class="line">            a.isComment === b.isComment &amp;&amp;</span><br><span class="line">            isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">            sameInputType(a, b)</span><br><span class="line">        ) || (</span><br><span class="line">            isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">            a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">            isUndef(b.asyncFactory.error)</span><br><span class="line">        )</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="v-for的key"><a href="#v-for的key" class="headerlink" title="v-for的key"></a>v-for的key</h2><p>我们是不建议在列表循环时，用索引来动态绑定<code>key</code>值的，为什么呢，可以看下面的情况:</p><ol><li>对比老dom的头和新dom的头，发现<code>key</code>都是0,则判定是同一个虚拟dom，比较出差异，由1-&gt;3 ，更新dom，之后移动指针</li><li>重复第一步， 比对老dom的头和新dom的头，发现<code>key</code>都是1,则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针</li><li>重复第一步， 比对老dom的头和新dom的头，发现<code>key</code>都是2,则判定是同一个虚拟dom，比较出差异，由3-&gt;1 ，更新dom</li></ol><p><code>根据以上分析，用索引来动态绑定key值会有两次dom操作。</code><br><img src="/images/before.png" width='500px'></p><p>让我们换个方式，用数组内部来动态绑定<code>key</code>：</p><ol><li>对比老dom的头和新dom的头，发现<code>key</code>不同，老头<code>key：1</code>,新头<code>key：3</code>，则判定不是同一个虚拟dom。</li><li>对比老dom的头和新dom的尾，发现<code>key</code>都是1，则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针</li><li>重复第一步， 比对老dom的头和新dom的头，发现<code>key</code>不同，老头<code>key：2</code>,新头<code>key：3</code>，则判定不是同一个虚拟dom。</li><li>对比老dom的头和新dom的尾，发现<code>key</code>都是2，则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针</li><li>重复第一步， 比对老dom的头和新dom的头，发现<code>key</code>都是3,则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针</li></ol><p><code>根据以上分析，用数组内部来动态绑定key值没有进行dom操作。</code></p><img src="/images/after.png" width='500px'>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一节我们已经知道在触发更新后，&lt;code&gt;渲染watcher&lt;/code&gt;会重新触发求值函数，求值函数内部先要&lt;code&gt;vm._render()&lt;/code&gt;生成新值对应的虚拟dom，并把结果交给&lt;code&gt;vm._update&lt;/code&gt;处理，接下来我们看看&lt;cod</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>5. Vue的更新策略</title>
    <link href="http://example.com/2020/12/17/vue05/"/>
    <id>http://example.com/2020/12/17/vue05/</id>
    <published>2020-12-16T17:00:34.000Z</published>
    <updated>2020-12-22T05:22:39.078Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇文章中，我们已经讲到Vue内部如何进行依赖收集的，咱们先假定模版如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;handleClick&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&#x27;item in list&#x27;</span>&gt;</span>&#123;&#123;item&#125;&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;obj&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;splitMsg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">&#x27;我是数据&#x27;</span>,</span><br><span class="line">    list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    obj: &#123;</span><br><span class="line">      name: <span class="string">&#x27;heaven&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">splitMsg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.msg = <span class="string">&#x27;我是修改的数据&#x27;</span>;</span><br><span class="line">      <span class="built_in">this</span>.lish.push(<span class="number">4</span>)</span><br><span class="line">      <span class="built_in">this</span>.obj.name = <span class="string">&#x27;啦啦啦&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/render01.png" ><p>最终模版转成的render函数如上所示，依赖收集的结果如下:</p><ol><li>list对应的订阅器对象dep中<code>subs=[渲染watcher]</code></li><li>obj对应的订阅器对象dep中<code>subs=[渲染watcher]</code></li><li>splitMsg是计算属性，所以msg对应的订阅器对象dep中<code>subs=[lazyWatcher,渲染watcher]</code></li><li>name对应的订阅器对象dep中<code>subs=[渲染watcher]</code><br>并且因为<code>childOb.dep.depend</code>的原因，obj和list这俩引用数据的dep订阅器对象的sub也会存储watcher，并且<code>subs=[渲染watcher]</code></li></ol><h2 id="渲染watcher的依赖图"><a href="#渲染watcher的依赖图" class="headerlink" title="渲染watcher的依赖图"></a>渲染watcher的依赖图</h2><p>最终渲染watcher收集的dep如下</p><img src="/images/renderwatcher.png" ><h2 id="lazyWatcher的依赖图"><a href="#lazyWatcher的依赖图" class="headerlink" title="lazyWatcher的依赖图"></a>lazyWatcher的依赖图</h2><p>最终lazyWatcher收集的dep如下<br><img src="/images/lazywatcher.png" ></p><h2 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h2><p>我们知道Vue内部为普通对象/数组构建了响应式系统，想要视图更新共有两种：</p><ol><li>给对象属性赋值，触发set钩子</li><li>执行数组变异方法，触发mutator函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  methods:&#123;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.msg = <span class="string">&#x27;我是修改的数据&#x27;</span>;</span><br><span class="line">      <span class="built_in">this</span>.lish.push(<span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="修改对象属性"><a href="#修改对象属性" class="headerlink" title="修改对象属性"></a>修改对象属性</h3><p>上面代码<code>this.msg = &#39;我是修改的数据&#39;</code>会触发下面的set钩子函数，<code>dep.notify()</code>就是触发视图更新的关键代码，<br>视图更新的逻辑如下：</p><ol><li>取出subs数组中所有的watcher，并触发watcher的update方法。对于msg来说，subs数组的watcher只有一个渲染watcher</li><li>update内部是基于watcher的种类做不同的处理，对于渲染watcher直接放到queueWatcher函数中处理，对于lazyWatcher，把dirty置true，表示lazyWatcher并没有求值。queueWatcher函数内部拿到watcher会怎么处理，我们稍等再说，值得注意的是，此时视图还没有更新呢。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  val = newVal;</span><br><span class="line">  childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">  dep.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.prototype.notify = <span class="function"><span class="keyword">function</span> <span class="title">notify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> subs = <span class="built_in">this</span>.subs.slice();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].update();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">    <span class="built_in">this</span>.run();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组变异方法"><a href="#数组变异方法" class="headerlink" title="数组变异方法"></a>数组变异方法</h3>接下来我们执行数组的变异方法<code>this.lish.push(4)</code>来触发mutator函数，大致逻辑是：</li><li><code>original.apply</code>执行数组原型的push方法</li><li>对push/unshift/splice这三个方法，对添加的到list数组的新数据进行观测</li><li><code>ob.dep.notify()</code>触发视图更新，值得注意的是ob指向<code>this.__ob__</code>，mutator函数内部this指向list数组，在观测list数组时，就已经通过<code>def(value, &#39;__ob__&#39;, this)</code>给list数组添加__ob__属性了。所以<code>this.__ob__</code>指向的就是list数组对应的观测对象，一旦执行<code>ob.dep.notify()</code>，就会取出list数组对应的dep订阅器对象里subs所有的watcher，对于list数组来说，subs数组只有一个渲染watcher，接着再执行watcher.update，最后是把渲染watcher放到queueWatcher函数中处理。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> original = arrayProto[method];</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [], len = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">while</span> (len--) args[len] = <span class="built_in">arguments</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    <span class="keyword">var</span> ob = <span class="built_in">this</span>.__ob__;</span><br><span class="line">    <span class="keyword">var</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) &#123; ob.observeArray(inserted); &#125;</span><br><span class="line">    ob.dep.notify();</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="vm-set"><a href="#vm-set" class="headerlink" title="vm.$set"></a>vm.$set</h3><p>如果要让视图中的obj更新，只要<code>this.obj.name=&#39;啦啦啦&#39;</code>即可，其更新视图的流程和上面分析的<code>this.msg=&#39;我是修改的数据&#39;</code>一致，当然我们修改的obj的name属性，因为在构建响应式系统时，已经给name属性添加get和set，自然可以触发视图更新了，假定我们<code>this.obj.age=28</code>这样是否可以触发视图更新呢，根据Vue的使用经验，其实这样是不会触发视图更新的，<br>如果就是希望<code>this.obj.age=28</code>来触发视图更新，可以使用<code>vm.$set</code>这个API来触发视图更新，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  methods:&#123;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.obj.name = <span class="string">&#x27;啦啦啦&#x27;</span> <span class="comment">//可以触发视图更新，因为构建响应式系统时已经添加set</span></span><br><span class="line">      <span class="built_in">this</span>.obj.age = <span class="number">28</span> <span class="comment">//不可以触发视图更新，因为构建响应式系统时，并没有添加set</span></span><br><span class="line">      vm.$set(<span class="built_in">this</span>.obj,<span class="string">&#x27;age&#x27;</span>,<span class="number">28</span>)  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接下来，我们看看<code>vm.$set</code>是如何实现的？</p><ol><li>取出ob，这里ob指向<code>this.obj</code>这个对象的Observe实例</li><li>使用defineReactive$$1函数给<code>ob.value</code>的age属性构建响应式系统，这里<code>ob.value</code>指向<code>this.obj</code></li><li><code>ob.dep.notify()</code>触发更新，也是把渲染watcher放到queueWatcher函数中处理，因为<code>childOb.dep.depend</code>的原因，所以这里<code>ob.dep</code>的subs中已经存储了渲染watcher。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$set = <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此处省略若干代码</span></span><br><span class="line">  <span class="keyword">var</span> ob = (target).__ob__;</span><br><span class="line">  defineReactive$$1(ob.value, key, val);</span><br><span class="line">  ob.dep.notify();</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h2><h3 id="queueWatcher"><a href="#queueWatcher" class="headerlink" title="queueWatcher"></a>queueWatcher</h3><p>上面我们讨论了三种触发视图更新的方式，不过我们只讨论到把watcher交给queueWatcher中处理，在这之前其实视图并没有更新，也就是说真正视图更新的逻辑是放在queueWatcher去做的，我们看看queueWatcher内部的代码逻辑：</p><ol><li>has存储不同的watcher.id</li><li>定义开关flushing，只要<code>flushing=false</code>那就把watcher放到queue数组中,其实flushSchedulerQueue没执行，flushing就一直为false</li><li>定义开关waiting，只要<code>waiting=false</code>那就触发<code>nextTick(flushSchedulerQueue)</code>,并立马把waiting置true，防止再次触发<code>nextTick(flushSchedulerQueue)</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> has = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> queue = [];</span><br><span class="line"><span class="keyword">var</span> waiting = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> flushing = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此处省略若干代码</span></span><br><span class="line">  <span class="keyword">var</span> id = watcher.id;</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span>;</span><br><span class="line">      nextTick(flushSchedulerQueue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p>nextTick的作用是收集本次传入的cb回调函数，并立马触发timerFunc，处理方式如下：</p><ol><li>callbacks存放传入的cb回调函数，例如上面的<code>nextTick(flushSchedulerQueue)</code>就是把flushSchedulerQueue放入到callbacks中，其实当用户手动触发<code>this.$nextTick(回调函数)</code>，也会将回调函数放入到callbacks中</li><li>定义开关pending，只要<code>pending=false</code>那就触发<code>timerFunc()</code>,并立马把pending置true，防止再次触发<code>timerFunc()</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = [];</span><br><span class="line"><span class="keyword">var</span> pending = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb, ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _resolve;</span><br><span class="line">  callbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">       cb.call(ctx);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span>;</span><br><span class="line">    timerFunc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 手动触发this.$nextTick(回调函数)的逻辑</span></span><br><span class="line">Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextTick(fn, <span class="built_in">this</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="timerFunc"><a href="#timerFunc" class="headerlink" title="timerFunc"></a>timerFunc</h3><p>timerFunc的作用异步处理<code>flushCallbacks</code>，其中<code>flushCallbacks</code>存放的全是<code>nextTick函数</code>中<code>callbacks</code>收集的cb回调函数，例如<code>flushSchedulerQueue，自定义回调</code>等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="comment">// 此处省略若干代码</span></span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  timerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    p.then(flushCallbacks);</span><br><span class="line">  &#125;;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> copies = callbacks.slice(<span class="number">0</span>);</span><br><span class="line">  callbacks.length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h3><p>终于走到flushSchedulerQueue函数了，这里才是真正视图更新的地方，先看看内部的逻辑：</p><ol><li>queue数组升序排列</li><li>判断before存在，其实只有渲染watcher创建时有配置before，所以对于渲染watcher需要触发before配置，即组件的<code>beforeUpdate</code>钩子函数</li><li>取出queue中的每个watcher，并执行watcher.run，在这个情况，queue数组中只有一个渲染watcher，可以看到watcher.run中就执行了get触发求值函数了，因为template中用到了<code>list/obj/splitMsg</code>三个值，所以求值函数会求出<code>list/obj/splitMsg</code>最新的值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  currentFlushTimestamp = getNow();</span><br><span class="line">  flushing = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> watcher, id;</span><br><span class="line">  queue.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a.id - b.id; &#125;);</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index];</span><br><span class="line">    <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">      watcher.before();</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id;</span><br><span class="line">    has[id] = <span class="literal">null</span>;</span><br><span class="line">    watcher.run();</span><br><span class="line">  &#125;</span><br><span class="line">  callUpdatedHooks(updatedQueue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置任务状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetSchedulerState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  queue.length = <span class="number">0</span>;</span><br><span class="line">  has = &#123;&#125;;</span><br><span class="line">  waiting = flushing = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.run = <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="built_in">this</span>.get();</span><br><span class="line">    <span class="keyword">if</span> ( value !== <span class="built_in">this</span>.value || isObject(value) || <span class="built_in">this</span>.deep) &#123;</span><br><span class="line">      <span class="keyword">var</span> oldValue = <span class="built_in">this</span>.value;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上就是Vue的更新策略，其实就是将所有的<code>watcher</code>都放到<code>queue</code>数组中，并异步执行<code>watcher.run</code>从而让视图更新，当然我们知道触发求值函数一定可以算出新值，即<code>list/obj/splitMsg</code>，那算出新值之后是直接把新值作为内容直接渲染到dom结构中嘛？这样其实并不合理，假如我们没有更新<code>list</code>,那算出的<code>list</code>就和更新之前的<code>list</code>是一样的。这种情况，其实没有必要把没变化的<code>list</code>作为内容直接渲染到dom结构中。即在算出新值时，我们需要和更新前的值比较，新值和老值一样，就不进行dom操作，新值和老值不一样，就更新dom，这就涉及到解析来我们要讲的Vue内部的diff算法了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上篇文章中，我们已经讲到Vue内部如何进行依赖收集的，咱们先假定模版如下：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>4. Vue首次挂载，发生了肾么事?</title>
    <link href="http://example.com/2020/12/15/vue04/"/>
    <id>http://example.com/2020/12/15/vue04/</id>
    <published>2020-12-15T13:14:44.000Z</published>
    <updated>2020-12-22T13:30:04.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="挂载组件的入口"><a href="#挂载组件的入口" class="headerlink" title="挂载组件的入口"></a>挂载组件的入口</h2><p>在第三节文章中，我们知道了Vue把<code>template</code>编译成<code>render</code>函数的过程。接下来Vue内部会怎么处理呢？其实接下来Vue就会执行<code>mountComponent</code>函数来挂载组件，如下所示：</p><ol><li>触发<code>beforeMount</code>钩子</li><li>创建<code>watcher</code>的求值函数<code>updateComponent</code>，其中<code>_render</code>函数是创建虚拟dom,<code>_update</code>函数在首次触发时会基于创建的虚拟dom来生成真实dom</li><li>创建渲染<code>watcher</code>,其中最后一个参数true表示该<code>watcher</code>是<code>渲染watcher</code></li><li>触发<code>mounted</code>钩子</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vm, el,hydrating</span>) </span>&#123;</span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> updateComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        vm._update(vm._render(), hydrating);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">        before: <span class="function"><span class="keyword">function</span> <span class="title">before</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">                callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">        vm._isMounted = <span class="literal">true</span>;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建渲染watcher"><a href="#创建渲染watcher" class="headerlink" title="创建渲染watcher"></a>创建渲染watcher</h2><p>接下来咱们看看Vue是如何定义<code>Watcher</code>这个类的，对于<code>Watcher</code>类的参数需要详细说下：</p><ol><li><code>expOrFn</code>存储<code>watcher</code>的求值函数 ，对于<code>渲染watcher</code>，<code>expOrFn</code>就是<code>updateComponent</code> ，当然除了<code>渲染watcher</code>之后，其实还会有别的两<code>类watcher</code>，分别是为计算属性创建的<code>lazyWatcher</code>和为<code>watch</code>选项创建的<code>自定义watcher</code>，这两类对应的求值函数都是用户自定义传入的。</li><li><code>cb</code>存储求值函数执行后的回调函数，对于<code>渲染watcher</code>，<code>cb</code>就是<code>noop</code>空函数</li><li><code>options</code>存储<code>watcher</code>创建的配置参数，其中创建<code>渲染watcher</code>传入的配置对象有<code>before</code>钩子函数，创建<code>自定义watcher</code>时传入的配置对象有<code>user</code>属性为<code>true</code>，创建<code>lazyWatcher</code>时传入的配置对象有<code>lazy</code>属性为<code>true</code>。</li><li><code>isRenderWatcher</code> 表示创建的<code>watcher</code>是否是<code>渲染watcher</code>，<code>isRenderWatcher</code>为<code>true</code>表示<code>渲染watcher</code>，并将<code>渲染watcher</code>放到<code>vm._watcher</code>中。</li></ol><p>除了这些参数之外，还有别的处理，比如:</p><ol><li>每次创建<code>watcher</code>时都会把<code>watcher</code>放到<code>vm._watchers</code></li><li>在创建<code>watcher</code>时，基于<code>lazy</code>值判断是否执行求值函数，其中如果是<code>lazyWatcher</code>就不立马求值，不是<code>lazyWatcher</code>就立马求值。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Watcher = <span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params"> vm, expOrFn, cb, options, isRenderWatcher</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = !!options.deep;</span><br><span class="line">      <span class="built_in">this</span>.user = !!options.user;</span><br><span class="line">      <span class="built_in">this</span>.lazy = !!options.lazy;</span><br><span class="line">      <span class="built_in">this</span>.sync = !!options.sync;</span><br><span class="line">      <span class="built_in">this</span>.before = options.before;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = <span class="built_in">this</span>.user = <span class="built_in">this</span>.lazy = <span class="built_in">this</span>.sync = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.id = ++uid$<span class="number">2</span>; <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="built_in">this</span>.active = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="built_in">this</span>.lazy; <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="built_in">this</span>.deps = [];</span><br><span class="line">    <span class="built_in">this</span>.newDeps = [];</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="keyword">new</span> _Set();</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = <span class="keyword">new</span> _Set();</span><br><span class="line">    <span class="built_in">this</span>.expression = expOrFn.toString();</span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.lazy ? <span class="literal">undefined</span> : <span class="built_in">this</span>.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watche-run"><a href="#watche-run" class="headerlink" title="watche.run"></a>watche.run</h3><p>经过上面的分析，只要不是<code>lazyWatcher</code>就求值，那我们在初始化<code>渲染watcher</code>就会触发求值函数了，接下来我们看看run函数的逻辑：<br>1.触发<code>pushTarget</code>，当前的<code>watcher</code>入<code>targetStack</code>栈，<code>Dep.target</code>指向栈顶的<code>watcher</code><br>2.触发求值函数<code>getter</code><br>3.触发<code>popTarget</code>，当前的<code>watcher</code>出<code>targetStack</code>栈，<code>Dep.target</code>指向栈顶的<code>watcher</code><br>4.触发<code>cleanupDeps</code>函数，<code>depIds/deps</code>存储本次<code>newDepIds/newDeps</code>的值，之后再清空<code>newDepIds/newDeps</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    pushTarget(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>.vm;</span><br><span class="line">    value = <span class="built_in">this</span>.getter.call(vm, vm);</span><br><span class="line">    popTarget();</span><br><span class="line">    <span class="built_in">this</span>.cleanupDeps();</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> targetStack = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    targetStack.push(target);</span><br><span class="line">    Dep.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    targetStack.pop();</span><br><span class="line">    Dep.target = targetStack[targetStack.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.cleanupDeps = <span class="function"><span class="keyword">function</span> <span class="title">cleanupDeps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="built_in">this</span>.deps.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">var</span> dep = <span class="built_in">this</span>.deps[i];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="built_in">this</span>.depIds;</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="built_in">this</span>.newDepIds;</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = tmp;</span><br><span class="line">    <span class="built_in">this</span>.newDepIds.clear();</span><br><span class="line">    tmp = <span class="built_in">this</span>.deps;</span><br><span class="line">    <span class="built_in">this</span>.deps = <span class="built_in">this</span>.newDeps;</span><br><span class="line">    <span class="built_in">this</span>.newDeps = tmp;</span><br><span class="line">    <span class="built_in">this</span>.newDeps.length = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="渲染watcher求值"><a href="#渲染watcher求值" class="headerlink" title="渲染watcher求值"></a>渲染watcher求值</h3><p>对于<code>渲染watcher</code>来说，求值函数<code>getter</code>就是<code>updateComponent</code>，而<code>updateComponent</code>函数的逻辑也很清晰:</p><ol><li>触发<code>_render</code>函数</li><li>触发<code>_update</code>函数<br>可以看到<code>_render</code>函数内部就是执行生成的<code>render</code>函数，而这个<code>render</code>函数就是基于<code>template</code>模版创建的<code>render</code>函数，值的注意的是，执行<code>render</code>函数时，会将内部this指向<code>vm._renderProxy</code>，<code>vm._renderProxy</code>对象经过处理指向组件实例vm。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> updateComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    vm._update(vm._render(), hydrating);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> ref = vm.$options;</span><br><span class="line">    <span class="keyword">var</span> render = ref.render;</span><br><span class="line">    <span class="keyword">var</span> vnode = render.call(vm._renderProxy, vm.$createElement);</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假定template模版如下，则生成的render函数如下图所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">app</span> <span class="attr">class</span>=<span class="string">&quot;heaven&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;handleClick&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/images/render.png"  ><h3 id="渲染watcher收集依赖"><a href="#渲染watcher收集依赖" class="headerlink" title="渲染watcher收集依赖"></a>渲染watcher收集依赖</h3><p>当执行<code>render</code>函数时，有个<code>with</code>语句，执行<code>with</code>内部逻辑时，总是从<code>this</code>中取值，即取<code>msg</code>的值时，等价取<code>vm.msg</code>，因为我们之前做了数据代理的原因， 所以取<code>vm.msg</code>时，等价取<code>vm._data.msg</code> ,此时就触发了<code>msg</code>的<code>get</code>钩子函数。这时候<code>get</code>函数内部就会构建属性<code>msg</code>和<code>watcher</code>的依赖关系，我们看看<code>get</code>函数内部是怎么做的？</p><ol><li>判断<code>Dep.target</code>是否存在，之所以要有这个判断，是因为我们只要在<code>渲染watcher/lazyWatcher/自定义watcher</code>的求值函数触发时，才触发<code>dep.depend</code>函数</li><li>判断<code>childOb</code>是否存在，存在就执行<code>childOb.dep.depend</code>，childOb是什么？为什么要执行<code>childOb.dep.depend</code>，我们会在<code>Vue的更新策略</code>再说。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive$$1</span>(<span class="params"> obj, key, val, customSetter,shallow</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep(key);</span><br><span class="line">    <span class="keyword">var</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                dep.depend();</span><br><span class="line">                <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">                    childOb.dep.depend();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">                        dependArray(value);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            val = newVal;</span><br><span class="line">            childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面的分析，我们知道<code>Dep.target</code>存在的话就要执行<code>dep.depend</code>方法，我们看看这个函数内部做了什么？</p><ol><li>判断<code>Dep.target</code>是否存在，值得注意的是，此时<code>Dep.target</code>指向<code>渲染watcher</code>，并且执行<code>渲染watcher</code>的<code>addDep</code>方法</li><li><code>watcher</code>的<code>addDep</code>方法内部用到两个if判断，第一个判断是为了防止在本次求值过程中重复把<code>watcher</code>放到<code>dep</code>对象中，第二个if判断是为了防止在不同的求值时刻（用户更新视图会再次求值，再次求值会再次走到<code>addDep</code>的逻辑中）重复把<code>watcher</code>放到<code>dep</code>对象中。</li><li>最终会触发<code>dep.addSub</code>方法，把<code>watcher</code>放到<code>depd对象的subs</code>中。<br>至此属性<code>msg</code>的<code>dep</code>对象中的<code>subs</code>数组收集到了<code>渲染watcher</code>，这就是<code>msg</code>属性的依赖收集过程。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Dep = <span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.id = uid++;</span><br><span class="line">    <span class="built_in">this</span>.subs = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dep.prototype.addSub = <span class="function"><span class="keyword">function</span> <span class="title">addSub</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">&#125;;</span><br><span class="line">Dep.prototype.depend = <span class="function"><span class="keyword">function</span> <span class="title">depend</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        Dep.target.addDep(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.addDep = <span class="function"><span class="keyword">function</span> <span class="title">addDep</span>(<span class="params">dep</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = dep.id;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.newDepIds.add(id);</span><br><span class="line">        <span class="built_in">this</span>.newDeps.push(dep);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.depIds.has(id)) &#123;</span><br><span class="line">            dep.addSub(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="childOb-dep-depend的作用"><a href="#childOb-dep-depend的作用" class="headerlink" title="childOb.dep.depend的作用"></a>childOb.dep.depend的作用</h3><p>上面留了一个疑问，在<code>get</code>钩子中为什么要判断<code>childObj</code>?要明确这一点，我们先要知道<code>childObj</code>是什么？根据上面代码可知，<code>childObj</code>是<code>observe</code>函数的返回值，先看看<code>observe</code>函数是什么？其实<code>observe</code>函数就是第一节说到的Vue响应式系统的入口，<code>observe</code>函数返回的是个观测后的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value, asRootData</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ob;</span><br><span class="line">    <span class="keyword">if</span> (hasOwn(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">        ob = value.__ob__;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        shouldObserve &amp;&amp;</span><br><span class="line">        !isServerRendering() &amp;&amp;</span><br><span class="line">        (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">        <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">        !value._isVue</span><br><span class="line">    ) &#123;</span><br><span class="line">        ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep(value);</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">            protoAugment(value, arrayMethods);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">this</span>.observeArray(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果观测的数据是<code>value=[1,2,3,4]</code>,那么<code>observe</code>函数返回的结果如下：</p><img src="/images/childobj.png"  ><p>所以<code>childObj</code>就是类似上面的数据结构，之所以在<code>get</code>的钩子函数中还要在判断<code>childObj</code>是否存在，其实就是为了当<code>childObj</code>存在时，再把当前的<code>watcher</code>添加到<code>childObj.dep.subs</code>数组中，为什么要把<code>watcher</code>放到<code>subs</code>数组中？咱们在下一节<code>Vue的更新策略</code>中会讲到。</p><p>上面讲到的是<code>渲染watcher</code>的创建和收集依赖的过程，接下来再说一下<code>lazyWatcher</code>的创建和收集依赖的过程,假定模版如下所示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">app</span> <span class="attr">class</span>=<span class="string">&quot;heaven&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;splitMsg&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: <span class="string">&#x27;我是数据&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        <span class="function"><span class="title">splitMsg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建lazyWatcher"><a href="#创建lazyWatcher" class="headerlink" title="创建lazyWatcher"></a>创建lazyWatcher</h2><p>其实对于<code>computed</code>选项里的每个计算属性，Vue内部都会为其生成一个<code>lazyWatcher</code>，我们看下Vue内部的处理，大致逻辑如下：</p><ol><li>遍历<code>computed</code>选项，为每个计算属性都创建一个<code>watcher</code>，这里传递的求值函数是用户自己配置的属性的get</li><li>触发<code>defineComputed</code>函数，给计算属性添加<code>get/set</code>，即<code>vm.filterMsg</code>就会触发get钩子函数<br>值得注意的是，<code>computedWatcherOptions</code>的<code>lazy</code>值为<code>true</code>，用来标记是一个<code>lazyWatcher</code>，而且<code>lazyWatcher</code>上有个<code>dirty</code>表示<code>lazyWatcher</code>是否已经求值了，<code>lazyWatcher</code>初始时是不会求值的，所以<code>dirty</code>为<code>true</code>。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span>(<span class="params">vm, computed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">    <span class="keyword">var</span> isSSR = isServerRendering();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">        <span class="keyword">var</span> userDef = computed[key];</span><br><span class="line">        <span class="keyword">var</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.get;</span><br><span class="line">        <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">            <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">            watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">                vm,</span><br><span class="line">                getter || noop,</span><br><span class="line">                noop,</span><br><span class="line">                computedWatcherOptions</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        defineComputed(vm, key, userDef);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span>(<span class="params">target, key,userDef</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    sharedPropertyDefinition.get = createComputedGetter(key)</span><br><span class="line">    sharedPropertyDefinition.set = noop;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> watcher = <span class="built_in">this</span>._computedWatchers &amp;&amp; <span class="built_in">this</span>._computedWatchers[key];</span><br><span class="line">        <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">            <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">                watcher.evaluate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                watcher.depend();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> watcher.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="lazyWatcher收集依赖"><a href="#lazyWatcher收集依赖" class="headerlink" title="lazyWatcher收集依赖"></a>lazyWatcher收集依赖</h3><p>当然，在创建<code>watcher</code>时，一旦<code>lazy</code>是<code>true</code>，就不会在立马执行求值函数，那么<code>lazyWatcher</code>是在什么时刻求值的呢？其实也是在<code>render</code>函数中执行时才求值的，上面的模版最终编译的<code>render</code>函数如下，当执行<code>this.filterMsg</code>时，就会触发get函数，而get钩子函数的逻辑:</p><ol><li>从<code>_computedWatchers</code>中取出<code>lazyWatcher</code></li><li>判断<code>dirty</code>，如果值为<code>true</code>，就表示此刻<code>lazyWatcher</code>还没有求值，就触发<code>evaluate</code>函数</li></ol><img src="/images/computed.png"  ><p>在<code>evaluate</code>函数函数里面,就会触发求值函数了，之后会把<code>dirty</code>置<code>false</code>，表示<code>lazyWatcher</code>已经求值完成，在<code>lazyWatcher</code>求值时，需要注意下面几点：</p><ol><li><p>因为<code>lazyWatcher</code>是在<code>render</code>函数执行时遇到计算属性的基础上求值的，所以在<code>lazyWatcher</code>求值之前，<code>targetStack=[渲染watcher]</code>,在<code>lazyWatcher</code>求值之后，<code>targetStack=[渲染watcher,lazyWatcher]</code></p></li><li><p>此刻<code>Dep.target</code>指向<code>lazyWatcher</code></p></li><li><p><code>lazyWatcher</code>的求值函数是用户自定义的，在这里应该是<code> splitMsg() &#123; return this.msg.split(&#39;&#39;) &#125;</code>,可想而知，一旦执行该函数，就会执行<code>this.msg</code>，这时就会触发<code>msg</code>的get钩子函数进行依赖收集，把<code>lazyWatcher</code>添加到<code>msg</code>的<code>dep</code>(属性订阅器)的<code>subs</code>中（步骤和收集<code>渲染watcher</code>一致）。</p></li><li><p>执行<code>popTarget</code>函数，<code>lazyWatcher</code>从<code>targetStack</code>弹出，此刻<code>Dep.target</code>指向<code>渲染watcher</code></p></li><li><p>求值结束后，判断<code>Dep.target</code>是否存在，此刻是存在的，再把<code>Dep.target</code>即<code>渲染watcher</code>添加到<code>msg</code>的<code>dep</code>(属性订阅器)的<code>subs</code>中,最终<code>msg</code>的<code>dep</code>(属性订阅器)的<code>subs=[lazyWatcher,渲染watcher]</code></p></li></ol><p>至此属性<code>msg</code>的<code>dep</code>对象中的<code>subs</code>数组收集到了<code>lazyWatcher</code>和<code>渲染watcher</code>，这就是某个计算属性的依赖收集过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.evaluate = <span class="function"><span class="keyword">function</span> <span class="title">evaluate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    pushTarget(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>.vm;</span><br><span class="line">    value = <span class="built_in">this</span>.getter.call(vm, vm);</span><br><span class="line">    popTarget();</span><br><span class="line">    <span class="built_in">this</span>.cleanupDeps();</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="创建虚拟dom"><a href="#创建虚拟dom" class="headerlink" title="创建虚拟dom"></a>创建虚拟dom</h2><p>根据上面的分析，我们知道在触发<code>vm._render</code>函数时，会收集依赖，其实<code>vm._render</code>函数还有另外一个作用：创建虚拟dom，这就要说到生成的<code>render</code>函数里用到的辅助函数<code>_c</code>了，它是用来创建虚拟的元素节点，我们看看函数内部的逻辑：</p><ol><li>执行<code>createElement</code>函数，作用是参数重载，用来确保data存节点的属性，children存子节点</li><li>执行<code>_createElement</code>函数，该函数作用有三：<br> 2.1 处理传入的<code>children</code>子节点，<br> 2.2 处理原生html标签如<code>div,p</code>，并使用 <code>new VNode()</code>来创建标签对应的虚拟dom<br> 2.3 处理自定义组件，并使用<code>createComponent</code>来创建组件对应的虚拟dom(后面讲Vue组件系统时会讲到)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vm._c = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c, d</span>) </span>&#123; <span class="keyword">return</span> createElement(vm, a, b, c, d, <span class="literal">false</span>); &#125;;</span><br><span class="line"><span class="comment">// 参数重载 保证data存属性  children存子节点的顺序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">context,tag,data,children,normalizationType,alwaysNormalize </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data) || isPrimitive(data)) &#123;</span><br><span class="line">        normalizationType = children;</span><br><span class="line">        children = data;</span><br><span class="line">        data = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isTrue(alwaysNormalize)) &#123;</span><br><span class="line">        normalizationType = ALWAYS_NORMALIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _createElement(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createElement</span>(<span class="params">context,tag,data,children,normalizationType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">      children = normalizeChildren(children);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">      children = simpleNormalizeChildren(children);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> vnode;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> Ctor;</span><br><span class="line">        <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">            <span class="comment">// platform built-in elements</span></span><br><span class="line">            vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">            config.parsePlatformTagName(tag), data, children,</span><br><span class="line">            <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">            <span class="comment">// component</span></span><br><span class="line">            vnode = createComponent(Ctor, data, context, children, tag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Vue内部创建好虚拟dom后，就会把虚拟dom交给<code>vm._update</code>处理，我们看看这个函数内部的逻辑：</p><ol><li><code>prevEl</code>存储组件的挂载点(真实dom)</li><li><code>prevVnode</code>存储上次生成的虚拟dom，对于首次触发<code>_update</code>函数来说，<code>prevVnode</code>为<code>undefined</code></li><li><code>vm._vnode</code>存储本次生成的虚拟dom</li></ol><p>显然首次触发<code>_update</code>函数时，会走进if，从而触发<code>vm.__patch__</code>函数并传入<code>vm.$el</code>和<code>vnode</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode, hydrating</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> prevEl = vm.$el;</span><br><span class="line">    <span class="keyword">var</span> prevVnode = vm._vnode;</span><br><span class="line">    vm._vnode = vnode;</span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">        <span class="comment">// initial render</span></span><br><span class="line">        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// updates</span></span><br><span class="line">        vm.$el = vm.__patch__(prevVnode, vnode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="创建真实dom"><a href="#创建真实dom" class="headerlink" title="创建真实dom"></a>创建真实dom</h2><h3 id="vm-patch"><a href="#vm-patch" class="headerlink" title="vm.patch"></a>vm.<strong>patch</strong></h3><p>接下来，我们看看<code>vm.__patch__</code>函数的实现：</p><ol><li>判断<code>oldVnode</code>是不是真实的dom节点，如果是真实节点，那就说明是因为首次挂载组件触发<code>patch</code>函数的，那就使用<code>createElm</code>来创建真实dom</li><li>如果不是元素节点，那就说明是因为组件更新触发<code>patch</code>函数的，那就使用<code>patchVnode</code>来比对更新前后的虚拟dom。<br>对于首次触发<code>patch</code>函数时，因为<code>oldVnode</code>是真实节点，所以会走进else语句，最终触发<code>createElm</code>函数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode, vnode</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isRealElement = isDef(oldVnode.nodeType);</span><br><span class="line">    <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// patch existing root node</span></span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">            oldVnode = emptyNodeAt(oldVnode);</span><br><span class="line">            <span class="keyword">var</span> oldElm = oldVnode.elm;</span><br><span class="line">            <span class="keyword">var</span> parentElm = nodeOps.parentNode(oldElm);</span><br><span class="line">            <span class="comment">// create new node</span></span><br><span class="line">            createElm(</span><br><span class="line">                vnode,</span><br><span class="line">                insertedVnodeQueue,</span><br><span class="line">                oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">                nodeOps.nextSibling(oldElm)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="createElm"><a href="#createElm" class="headerlink" title="createElm"></a>createElm</h3><p>Vue内部是使用<code>createElm</code>函数来根据虚拟dom创建真实dom的，我们看看内部的处理:</p><ol><li>如果虚拟dom里有组件，那就创建组件(这里没有组件，后面在讲Vue组件系统会讲到)</li><li>把<code>vnode</code>及其子节点<code>children</code>放到<code>createChildren</code>函数中处理，生成子节点对应的真实dom。</li><li>最终把生成的子节点插入到父节点<code>parentElm</code>中</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span>(<span class="params"> vnode,insertedVnodeQueue,parentElm,refElm </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> data = vnode.data;</span><br><span class="line">    <span class="keyword">var</span> children = vnode.children;</span><br><span class="line">    <span class="keyword">var</span> tag = vnode.tag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDef(tag)) &#123;</span><br><span class="line">        vnode.elm = nodeOps.createElement(tag, vnode);</span><br><span class="line">        createChildren(vnode, children );</span><br><span class="line">        insert(parentElm, vnode.elm, refElm);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isTrue(vnode.isComment)) &#123;</span><br><span class="line">        vnode.elm = nodeOps.createComment(vnode.text);</span><br><span class="line">        insert(parentElm, vnode.elm, refElm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode.elm = nodeOps.createTextNode(vnode.text);</span><br><span class="line">        insert(parentElm, vnode.elm, refElm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createChildren</span>(<span class="params">vnode, children, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">        checkDuplicateKeys(children);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">            createElm(children[i], insertedVnodeQueue, vnode.elm, <span class="literal">null</span>, <span class="literal">true</span>, children, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，就是Vue内部从挂载组件到生成真实dom的全部过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;挂载组件的入口&quot;&gt;&lt;a href=&quot;#挂载组件的入口&quot; class=&quot;headerlink&quot; title=&quot;挂载组件的入口&quot;&gt;&lt;/a&gt;挂载组件的入口&lt;/h2&gt;&lt;p&gt;在第三节文章中，我们知道了Vue把&lt;code&gt;template&lt;/code&gt;编译成&lt;code&gt;ren</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>实现express的洋葱模型</title>
    <link href="http://example.com/2020/12/11/express01/"/>
    <id>http://example.com/2020/12/11/express01/</id>
    <published>2020-12-11T09:39:55.000Z</published>
    <updated>2020-12-17T05:09:26.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Layer-js"><a href="#Layer-js" class="headerlink" title="Layer.js"></a>Layer.js</h2><h3 id="express-js"><a href="#express-js" class="headerlink" title="express.js"></a>express.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> CreateApplication()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="CreateApplication-js"><a href="#CreateApplication-js" class="headerlink" title="CreateApplication.js"></a>CreateApplication.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateApplication</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._router = <span class="keyword">new</span> Router()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">path, ...handlers</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._router.get(path, handlers)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">post</span>(<span class="params">path, ...handlers</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._router.post(path, handlers)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">use</span>(<span class="params">path, ...handlers</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._router.use(path, handlers)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">listen</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">      res.end(<span class="string">`Cannot <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.url&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._router.handle(req, res, done)</span><br><span class="line">    &#125;).listen(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Router-js"><a href="#Router-js" class="headerlink" title="Router.js"></a>Router.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stacks = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">path, handlers</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> layer = <span class="keyword">new</span> Layer(path, <span class="string">&#x27;get&#x27;</span>, handlers)</span><br><span class="line">    <span class="built_in">this</span>.stacks.push(layer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">post</span>(<span class="params">path, handlers</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> layer = <span class="keyword">new</span> Layer(path, <span class="string">&#x27;post&#x27;</span>, handlers)</span><br><span class="line">    <span class="built_in">this</span>.stacks.push(layer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">use</span>(<span class="params">path, handlers</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> layer = <span class="keyword">new</span> Layer(path, <span class="string">&#x27;use&#x27;</span>, handlers)</span><br><span class="line">    <span class="built_in">this</span>.stacks.push(layer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handle</span>(<span class="params">req, res, done</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; pathname &#125; = url.parse(req.url)</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (idx &gt;= <span class="built_in">this</span>.stacks.length) <span class="keyword">return</span> done(req, res)</span><br><span class="line">        <span class="keyword">let</span> layer = <span class="built_in">this</span>.stacks[idx++]</span><br><span class="line">        <span class="keyword">const</span> &#123; method &#125; = layer</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">          pathname === layer.path &amp;&amp; (method === req.method.toLowerCase() || method === <span class="string">&#x27;use&#x27;</span>)</span><br><span class="line">      ) &#123;</span><br><span class="line">        layer.dispatch(req, res, next)<span class="comment">//触发内层</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next() <span class="comment">//触发外层</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Layer-js-1"><a href="#Layer-js-1" class="headerlink" title="Layer.js"></a>Layer.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">path, method, handlers</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stacks = []</span><br><span class="line">    <span class="built_in">this</span>.method = method</span><br><span class="line">    <span class="built_in">this</span>.path = path</span><br><span class="line">    <span class="built_in">this</span>.stacks.push(...handlers)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">dispatch</span>(<span class="params">req, res, out</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> next = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (idx &gt;= <span class="built_in">this</span>.stacks.length) <span class="keyword">return</span> out()</span><br><span class="line">      <span class="keyword">let</span> handler = <span class="built_in">this</span>.stacks[idx++]</span><br><span class="line">      handler(req, res, next)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Layer-js&quot;&gt;&lt;a href=&quot;#Layer-js&quot; class=&quot;headerlink&quot; title=&quot;Layer.js&quot;&gt;&lt;/a&gt;Layer.js&lt;/h2&gt;&lt;h3 id=&quot;express-js&quot;&gt;&lt;a href=&quot;#express-js&quot; class=&quot;</summary>
      
    
    
    
    <category term="Node" scheme="http://example.com/categories/Node/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>3. Vue生成ast树后，发生了肾么事？</title>
    <link href="http://example.com/2020/12/06/vue03/"/>
    <id>http://example.com/2020/12/06/vue03/</id>
    <published>2020-12-06T06:59:10.000Z</published>
    <updated>2020-12-21T11:28:41.748Z</updated>
    
    <content type="html"><![CDATA[<p>Vue生成了ast语法树之后，还对这个树结构进行了静态标记，之所以给ast树打上是否是静态的标记，是因为在后面diff算法的时候，直接跳过静态的节点，可以节省diff的开销。下面我们看看是怎么给节点打静态标记的吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ast = parse(template.trim(), options);</span><br><span class="line"><span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">    optimize(ast, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">optimize</span>(<span class="params">root, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    isStaticKey = genStaticKeysCached(options.staticKeys || <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    isPlatformReservedTag = options.isReservedTag || no;</span><br><span class="line">    <span class="comment">// 给节点打上是否是静态节点的标记</span></span><br><span class="line">    markStatic$<span class="number">1</span>(root);</span><br><span class="line">    <span class="comment">// 给节点打上是否是静态根节点的标记</span></span><br><span class="line">    markStaticRoots(root, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，markStatic$1函数是给节点打上是否是静态节点的标记，markStaticRoots函数是给节点打上是否是静态根节点的标记，我们先看看markStatic$1函数内部的逻辑，其实核心isStatic函数，这个函数是判断节点是否是静态节点。判断的逻辑大致如下</p><ol><li>如果是插值文本 那就不是静态节点</li><li>如果是普通文本 那就是静态节点</li><li>有跳过编译的指令pre 那就是静态节点</li><li>没有属性绑定&amp;有if for&amp;不是Vue内置标签等 那就是静态节点</li></ol><p>在经过上面判断出这个节点是否是静态节点，如果是那就给这个节点在加上<code>static:true</code>标记，当然这还没结束，接着还会在遍历这个节点的子节点们，判断子节点是否是静态节点，一旦某个子节点不是静态节点，那就给这个节点<br>打上<code>static:false</code>标记</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">markStatic$1</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    node.static = isStatic(node);</span><br><span class="line">   <span class="keyword">if</span> (node.type === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> child = node.children[i];</span><br><span class="line">        markStatic$<span class="number">1</span>(child);</span><br><span class="line">        <span class="keyword">if</span> (!child.static) &#123;</span><br><span class="line">          node.static = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isStatic</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="number">2</span>) &#123; <span class="comment">// expression</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="number">3</span>) &#123; <span class="comment">// text</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !!(node.pre || (</span><br><span class="line">      !node.hasBindings &amp;&amp; <span class="comment">// no dynamic bindings</span></span><br><span class="line">      !node.if &amp;&amp; !node.for &amp;&amp; <span class="comment">// not v-if or v-for or v-else</span></span><br><span class="line">      !isBuiltInTag(node.tag) &amp;&amp; <span class="comment">// not a built-in</span></span><br><span class="line">      isPlatformReservedTag(node.tag) &amp;&amp; <span class="comment">// not a component</span></span><br><span class="line">      !isDirectChildOfTemplateFor(node) &amp;&amp;</span><br><span class="line">      <span class="built_in">Object</span>.keys(node).every(isStaticKey)</span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再看看markStaticRoots函数的逻辑,判断节点是否是静态根节点的逻辑大致如下</p><ol><li>如果是该节点是静态节点，并且这个节点的子节点长度大于1，那这个节点就是静态根节点</li><li>不满足上述条件，则这个节点就不是静态根节点<br>在经过上面判断出这个节点是否是静态根节点，如果是那就给这个节点在加上<code>staticRoot:true</code>标记，当然这还没结束，接着还会在遍历这个节点的子节点们，判断子节点是否是静态根节点，最后给子节点们打上staticRoot标记</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStaticRoots</span>(<span class="params">node, isInFor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// For a node to qualify as a static root, it should have children that</span></span><br><span class="line">      <span class="comment">// are not just static text. Otherwise the cost of hoisting out will</span></span><br><span class="line">      <span class="comment">// outweigh the benefits and it&#x27;s better off to just always render it fresh.</span></span><br><span class="line">      <span class="keyword">if</span> (node.static &amp;&amp; node.children.length &amp;&amp; !(</span><br><span class="line">        node.children.length === <span class="number">1</span> &amp;&amp;</span><br><span class="line">        node.children[<span class="number">0</span>].type === <span class="number">3</span></span><br><span class="line">      )) &#123;</span><br><span class="line">        node.staticRoot = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.staticRoot = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.children) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">          markStaticRoots(node.children[i], isInFor || !!node.for);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终Vue就处理好了ast树，接着会基于ast树生成代码，,这里使用到了generate函数，generate这个函数内部的逻辑大致是:</p><ol><li>genElement函数内部创建节点对应的代码存到data中</li><li>genChildren函数内部创建节点的子节点对应的代码存到children中</li><li>最终基于data和children拼接成最终的code，其中如果节点有if for once等指令，会转换成特殊的代码</li><li>如果是静态根节点，就生成代码并存到staticRenderFns中<br>值得注意的是，我们在下面代码中可以得到结论：v-for的优先级比v-if的优先级<br>因为generate函数内部是先处理el.for，再处理el.if的。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ast = parse(template.trim(), options);</span><br><span class="line"><span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">    optimize(ast, options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> code = generate(ast, options);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">ast, options </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="keyword">new</span> CodegenState(options);</span><br><span class="line">    <span class="keyword">var</span> code = ast ? genElement(ast, state) : <span class="string">&#x27;_c(&quot;div&quot;)&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        render: (<span class="string">&quot;with(this)&#123;return &quot;</span> + code + <span class="string">&quot;&#125;&quot;</span>),</span><br><span class="line">        staticRenderFns: state.staticRenderFns</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genElement</span>(<span class="params">el, state</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (el.parent) &#123;</span><br><span class="line">        el.pre = el.pre || el.parent.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;</span><br><span class="line">        <span class="keyword">return</span> genStatic(el, state)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.once &amp;&amp; !el.onceProcessed) &#123;</span><br><span class="line">        <span class="keyword">return</span> genOnce(el, state)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.for &amp;&amp; !el.forProcessed) &#123;</span><br><span class="line">        <span class="keyword">return</span> genFor(el, state)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.if &amp;&amp; !el.ifProcessed) &#123;</span><br><span class="line">        <span class="keyword">return</span> genIf(el, state)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.tag === <span class="string">&#x27;template&#x27;</span> &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123;</span><br><span class="line">        <span class="keyword">return</span> genChildren(el, state) || <span class="string">&#x27;void 0&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.tag === <span class="string">&#x27;slot&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> genSlot(el, state)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// component or element</span></span><br><span class="line">        <span class="keyword">var</span> code;</span><br><span class="line">        <span class="keyword">if</span> (el.component) &#123;</span><br><span class="line">        code = genComponent(el.component, el, state);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> data;</span><br><span class="line">        <span class="keyword">if</span> (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) &#123;</span><br><span class="line">            data = genData$<span class="number">2</span>(el, state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> children = el.inlineTemplate ? <span class="literal">null</span> : genChildren(el, state, <span class="literal">true</span>);</span><br><span class="line">            code = <span class="string">&quot;_c(&#x27;&quot;</span> + (el.tag) + <span class="string">&quot;&#x27;&quot;</span> + (data ? (<span class="string">&quot;,&quot;</span> + data) : <span class="string">&#x27;&#x27;</span>) + (children ? (<span class="string">&quot;,&quot;</span> + children) : <span class="string">&#x27;&#x27;</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// module transforms</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; state.transforms.length; i++) &#123;</span><br><span class="line">            code = state.transforms[i](el, code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出的code为下图，其中render为可执行的字符串，staticRenderFns为静态节点字符串</p><img src="/images/code.png" ><p>生成code之后，接下来的处理是在compileToFunctions函数中,大致逻辑是：</p><ol><li>定义cache缓存对象</li><li>compile函数返回的是code对象,即compiled-&gt;code对象</li><li>基于render/staticRenderFns创建函数</li><li>返回res对象，并将key-&gt;res存到缓存对象中,这个是vue的优化策略，当第二次再次编译同样的模版时，会直接取出render/staticRenderFns，不会重复编译出render/staticRenderFns，这样在多次使用组件时，就可以极大的节省浏览器开销</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">compileToFunctions</span>(<span class="params"> template, options, vm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//  此时省略很多代码</span></span><br><span class="line">    <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编译模版</span></span><br><span class="line">    <span class="keyword">var</span> compiled = compile(template, options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> fnGenErrors = [];</span><br><span class="line">    res.render = createFunction(compiled.render, fnGenErrors);</span><br><span class="line">    res.staticRenderFns = compiled.staticRenderFns.map(<span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createFunction(code, fnGenErrors)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (cache[key] = res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunction</span>(<span class="params">code, errors</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此Vue编译模版终于结束了，过程是从html字符串-&gt;ast语法树-&gt;code对象-&gt;render函数。其实还有一个很重要的问题，就是Vue在模版编译的过程中，函数嵌套很严重，Vue内部为什么嵌套这么多层呢？其实</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vue生成了ast语法树之后，还对这个树结构进行了静态标记，之所以给ast树打上是否是静态的标记，是因为在后面diff算法的时候，直接跳过静态的节点，可以节省diff的开销。下面我们看看是怎么给节点打静态标记的吧&lt;/p&gt;
&lt;figure class=&quot;highlight j</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>js小技巧</title>
    <link href="http://example.com/2020/12/03/js%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2020/12/03/js%E9%AA%9A%E6%93%8D%E4%BD%9C/</id>
    <published>2020-12-03T10:31:01.000Z</published>
    <updated>2020-12-17T05:14:55.895Z</updated>
    
    <content type="html"><![CDATA[<h3 id="金额格式化"><a href="#金额格式化" class="headerlink" title="金额格式化"></a>金额格式化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num =  <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1:</span></span><br><span class="line"><span class="keyword">let</span> result = num.toLocaleString()  <span class="comment">// 1,000,000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2:</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/(?=(\B)(\d&#123;3&#125;)+$)/g</span></span><br><span class="line"><span class="keyword">let</span> result = num.toString().replace(reg,<span class="string">&#x27;,&#x27;</span>) <span class="comment">// 1,000,000</span></span><br></pre></td></tr></table></figure><h3 id="交换值"><a href="#交换值" class="headerlink" title="交换值"></a>交换值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1:</span></span><br><span class="line">b = [a,a=b][<span class="number">0</span>] <span class="comment">//a=1 b=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line">a = a^b</span><br><span class="line">b = a^b</span><br><span class="line">a = a^b       <span class="comment">//a=1 b=2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;金额格式化&quot;&gt;&lt;a href=&quot;#金额格式化&quot; class=&quot;headerlink&quot; title=&quot;金额格式化&quot;&gt;&lt;/a&gt;金额格式化&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>2. Vue如何编译模版?</title>
    <link href="http://example.com/2020/12/01/vue02/"/>
    <id>http://example.com/2020/12/01/vue02/</id>
    <published>2020-12-01T13:26:48.000Z</published>
    <updated>2020-12-19T04:23:21.613Z</updated>
    
    <content type="html"><![CDATA[<p>Vue上手非常简单，因为我们可以直接编写html作为组件的模版，对比学习React还需要接触<code>jsx</code>语法，Vue对新手可以说是非常友好了，接下来我们看看vue是如何处理template模版的？</p><h2 id="Vue编译器入口"><a href="#Vue编译器入口" class="headerlink" title="Vue编译器入口"></a>Vue编译器入口</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createCompiler = createCompilerCreator(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span>(<span class="params">template, options</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// template -&gt; ast   对template的第一层抽象</span></span><br><span class="line">        <span class="keyword">var</span> ast = parse(template.trim(), options);</span><br><span class="line">        <span class="comment">// 优化ast树 标注静态节点</span></span><br><span class="line">        <span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">            optimize(ast, options);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ast -&gt; 可执行code  对template的第二层抽象</span></span><br><span class="line">        <span class="keyword">var</span> code = generate(ast, options);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ast: ast,</span><br><span class="line">            render: code.render,</span><br><span class="line">            staticRenderFns: code.staticRenderFns</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>可以看到首先是template模版放到parse函数中处理，得到ast对象(abstract syntax tree)，其实ast对象是对template的第一层抽象，template模版本质上是一个html字符串，现在用ast对象来描述template模版，接下来看看html字符串如何被转换成ast对象的？假定template模版如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html模版</span></span><br><span class="line"><span class="keyword">let</span> template = <span class="string">`</span></span><br><span class="line"><span class="string">     &lt;div id=app v-if=&#x27;msg&#x27; v-for=&#x27;item in 3&#x27; v-once:click=&#x27;handleClick&#x27;&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&#x27;text&#x27; title=&#x27;heaven&#x27;&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">        <span class="comment">// 解析到开始标签的钩子函数</span></span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        <span class="comment">//  解析到结束标签的钩子函数</span></span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        <span class="comment">// 解析到文本的钩子函数</span></span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="parseHTML-编译模版"><a href="#parseHTML-编译模版" class="headerlink" title="parseHTML 编译模版"></a>parseHTML 编译模版</h2><p>可以看到真正处理template的是parseHTML这个函数，我们看看这个函数内部的逻辑是什么？其实大致有4步</p><ol><li>定义token，这些token用来解析开始标签 标签属性 结束标签等</li><li>处理开始标签，并把处理的结果交给handleStartTag处理</li><li>处理结束标签，并把处理的结果交给parseEndTag处理</li><li>处理文本，并把文本交给chars钩子函数处理<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  解析属性的token id=&#x27;app&#x27;</span></span><br><span class="line"><span class="keyword">var</span> attribute = <span class="regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span>;</span><br><span class="line"><span class="keyword">var</span> ncname = <span class="string">&quot;[a-zA-Z_][\\-\\.0-9_a-zA-Z&quot;</span> + (unicodeRegExp.source) + <span class="string">&quot;]*&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> qnameCapture = <span class="string">&quot;((?:&quot;</span> + ncname + <span class="string">&quot;\\:)?&quot;</span> + ncname + <span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="comment">// 解析开始标签的token &lt;div </span></span><br><span class="line"><span class="keyword">var</span> startTagOpen = <span class="keyword">new</span> <span class="built_in">RegExp</span>((<span class="string">&quot;^&lt;&quot;</span> + qnameCapture));</span><br><span class="line"><span class="comment">// 解析开始标签结束的token /&gt;  &gt;</span></span><br><span class="line"><span class="keyword">var</span> startTagClose = <span class="regexp">/^\s*(\/?)&gt;/</span>;</span><br><span class="line"><span class="comment">// 解析结束标签的token &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> endTag = <span class="keyword">new</span> <span class="built_in">RegExp</span>((<span class="string">&quot;^&lt;\\/&quot;</span> + qnameCapture + <span class="string">&quot;[^&gt;]*&gt;&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseHTML</span>(<span class="params">html, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (html) &#123;</span><br><span class="line">        <span class="keyword">var</span> textEnd = html.indexOf(<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">        <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">        <span class="comment">// 处理开始标签</span></span><br><span class="line">        <span class="keyword">var</span> startTagMatch = parseStartTag();</span><br><span class="line">        <span class="keyword">if</span> (startTagMatch) &#123;</span><br><span class="line">            handleStartTag(startTagMatch);</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理结束标签</span></span><br><span class="line">        <span class="keyword">var</span> endTagMatch = html.match(endTag);</span><br><span class="line">        <span class="keyword">if</span> (endTagMatch) &#123;</span><br><span class="line">            <span class="keyword">var</span> curIndex = index;</span><br><span class="line">            advance(endTagMatch[<span class="number">0</span>].length);</span><br><span class="line">            parseEndTag(endTagMatch[<span class="number">1</span>], curIndex, index);</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理文本 包括静态文本和插值</span></span><br><span class="line">        <span class="keyword">var</span> text </span><br><span class="line">        <span class="keyword">if</span> (textEnd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">            text = html.substring(<span class="number">0</span>, textEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (text) advance(text.length);</span><br><span class="line">        <span class="keyword">if</span> (options.chars &amp;&amp; text) &#123;</span><br><span class="line">            options.chars(text, index - text.length, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析开始标签"><a href="#解析开始标签" class="headerlink" title="解析开始标签"></a>解析开始标签</h2>接下来，我们看看parseStartTag函数是如何处理开始标签的？<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制全局的index/html向前移动n</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">advance</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    index += n;</span><br><span class="line">    html = html.substring(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseStartTag</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 解析到开始标签</span></span><br><span class="line">    <span class="keyword">var</span> start = html.match(startTagOpen);</span><br><span class="line">    <span class="keyword">if</span> (start) &#123;</span><br><span class="line">        <span class="keyword">var</span> match = &#123;</span><br><span class="line">            tagName: start[<span class="number">1</span>], </span><br><span class="line">            attrs: [],</span><br><span class="line">            start: index</span><br><span class="line">        &#125;;</span><br><span class="line">        advance(start[<span class="number">0</span>].length);</span><br><span class="line">        <span class="keyword">var</span> end, attr;</span><br><span class="line">        <span class="keyword">while</span> (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(dynamicArgAttribute) || html.match(attribute))) &#123;</span><br><span class="line">            attr.start = index;</span><br><span class="line">            advance(attr[<span class="number">0</span>].length);</span><br><span class="line">            attr.end = index;</span><br><span class="line">            match.attrs.push(attr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end) &#123;</span><br><span class="line">            match.unarySlash = end[<span class="number">1</span>];</span><br><span class="line">            advance(end[<span class="number">0</span>].length);</span><br><span class="line">            match.end = index;</span><br><span class="line">            <span class="keyword">return</span> match</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>最终开始标签<code>&lt;div id=&#39;app&#39;&gt;</code>被解析成下面的结构，其中attrs里面存放开始标签的属性集合，start是开始标签的起始位置，end是开始标签的结束位置，tagName是开始标签的标签类型，unarySlash为空代表标签为双标签，这样开始标签所有信息都被这个对象完美描述了，下面是match的结构图<img src="/images/start.png" width="300px" ></li></ol><p>接下来，开始标签的处理结果match还需要交给handleStartTag处理，我们看看handleStartTag内部的逻辑，其实也是很清晰的</p><ol><li>处理attrs属性，最终把标签的属性改成key:value的形式，并且标记attrs内部的属性开始和结束位置</li><li>将开始标签的信息放到stack栈中</li><li>触发start钩子函数<br>值的注意的是value值为<code>args[3] || args[4] || args[5]</code>,这是怎么回事呢？<br>这是因为对于属性值的三种形式<code>&lt;div id=&quot;app&quot;&gt;</code> app可以是单引号，双引号，不加引号，分别对应<code>args[3] || args[4] || args[5]</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStartTag</span>(<span class="params">match</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> tagName = match.tagName;</span><br><span class="line">      <span class="keyword">var</span> unarySlash = match.unarySlash;</span><br><span class="line">      <span class="keyword">var</span> unary = isUnaryTag$$1(tagName) || !!unarySlash;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> l = match.attrs.length;</span><br><span class="line">      <span class="keyword">var</span> attrs = <span class="keyword">new</span> <span class="built_in">Array</span>(l);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> args = match.attrs[i];</span><br><span class="line">        <span class="keyword">var</span> value = args[<span class="number">3</span>] || args[<span class="number">4</span>] || args[<span class="number">5</span>] || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        attrs[i] = &#123;</span><br><span class="line">          name: args[<span class="number">1</span>],</span><br><span class="line">          value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (options.outputSourceRange) &#123;</span><br><span class="line">          attrs[i].start = args.start + args[<span class="number">0</span>].match(<span class="regexp">/^\s*/</span>).length;</span><br><span class="line">          attrs[i].end = args.end;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理双标签</span></span><br><span class="line">      <span class="keyword">if</span> (!unary) &#123;</span><br><span class="line">        stack.push(&#123; <span class="attr">tag</span>: tagName, <span class="attr">lowerCasedTag</span>: tagName.toLowerCase(), <span class="attr">attrs</span>: attrs, <span class="attr">start</span>: match.start, <span class="attr">end</span>: match.end &#125;);</span><br><span class="line">        lastTag = tagName;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (options.start) &#123;</span><br><span class="line">        options.start(tagName, attrs, unary, match.start, match.end);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到Vue把数据做了处理之后，又把这些数据交给了start钩子处理，我们看看start钩子里面的逻辑<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createASTElement</span>(<span class="params">tag,attrs,parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="number">1</span>,</span><br><span class="line">      tag: tag,</span><br><span class="line">      attrsList: attrs,</span><br><span class="line">      attrsMap: makeAttrsMap(attrs),</span><br><span class="line">      rawAttrsMap: &#123;&#125;,</span><br><span class="line">      parent: parent,</span><br><span class="line">      children: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">tag, attrs, unary, start$<span class="number">1</span>, end</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> element = createASTElement(tag, attrs, currentParent);</span><br><span class="line">            <span class="keyword">if</span> (options.outputSourceRange) &#123;</span><br><span class="line">                element.start = start$<span class="number">1</span>;</span><br><span class="line">                element.end = end;</span><br><span class="line">                element.rawAttrsMap = element.attrsList.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">cumulated, attr</span>) </span>&#123;</span><br><span class="line">                    cumulated[attr.name] = attr;</span><br><span class="line">                    <span class="keyword">return</span> cumulated</span><br><span class="line">                &#125;, &#123;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理v-for v-if指令</span></span><br><span class="line">            <span class="keyword">if</span> (!element.processed) &#123;</span><br><span class="line">                processFor(element);  </span><br><span class="line">                processIf(element);</span><br><span class="line">                processOnce(element);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解析到的第一个元素 就是根节点</span></span><br><span class="line">            <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">                root = element;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  如果是双标签 那currentParent就指定当前的ast元素，并存到stack栈中</span></span><br><span class="line">            <span class="keyword">if</span> (!unary) &#123;</span><br><span class="line">                currentParent = element;</span><br><span class="line">                stack.push(element);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                closeElement(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其实start钩子内部大致就做了三件事：</li><li>根据createASTElement生成一个ast元素，该ast元素也是用来描述开始标签，虽然match也用来描述开始标签，但是JS操作ast元素显然更方便些。</li><li>处理开始标签上面的v-if v-for v-once指令 </li><li>初始化root currentParent stack的值，其中root存储模版的根节点，currentParent指定当前解析到的ast元素，stack存放解析到的所有ast元素<br>下面是开始标签对应ast元素的结构图:</li></ol><img src="/images/ast.png" width="600px" ><h2 id="解析字符文本"><a href="#解析字符文本" class="headerlink" title="解析字符文本"></a>解析字符文本</h2><p>以上就是Vue内部解析开始标签的所有过程了，接下来我们再看看Vue内部如何解析文本的？,根据上面的分析，我们已经知道解析到文本会交给chars钩子处理，我们来看看chars钩子内部的逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        <span class="comment">// 解析到文本的钩子函数</span></span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span> (<span class="params">text, start, end</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> children = currentParent.children;</span><br><span class="line">            <span class="keyword">var</span> res;</span><br><span class="line">            <span class="keyword">var</span> child;</span><br><span class="line">            <span class="comment">//   解析到有插值的文本</span></span><br><span class="line">            <span class="keyword">if</span> (!inVPre &amp;&amp; text !== <span class="string">&#x27; &#x27;</span> &amp;&amp; (res = parseText(text, delimiters))) &#123;</span><br><span class="line">                child = &#123;</span><br><span class="line">                    type: <span class="number">2</span>,</span><br><span class="line">                    expression: res.expression,</span><br><span class="line">                    tokens: res.tokens,</span><br><span class="line">                    text: text</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (text !== <span class="string">&#x27; &#x27;</span> || !children.length || children[children.length - <span class="number">1</span>].text !== <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析到没有插值的文本</span></span><br><span class="line">                child = &#123;</span><br><span class="line">                    type: <span class="number">3</span>,</span><br><span class="line">                    text: text</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chars钩子内部逻辑很简单，就是区分文本是否有插值符号，有插值符号的话ast对象type标记为2，并解析插值，没有插值就当作普通文本处理ast对象type标记为3。下面是插值文本对应的ast对象</p><img src="/images/char.png" width="300px" ><h2 id="解析结束标签"><a href="#解析结束标签" class="headerlink" title="解析结束标签"></a>解析结束标签</h2><p>最后我们再看看Vue内部解析结束标签的过程，,根据上面的分析，我们已经知道解析到结束标签会交给parseEndTag函数处理，来看看parseEndTag函数内部的逻辑。大致意思是取出stack栈中的最后一项，并将最后一项的tag，start，end交给end钩子处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseEndTag</span>(<span class="params">tagName, start, end</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> pos, lowerCasedTagName;</span><br><span class="line">      <span class="keyword">if</span> (start == <span class="literal">null</span>) &#123; start = index; &#125;</span><br><span class="line">      <span class="keyword">if</span> (end == <span class="literal">null</span>) &#123; end = index; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Find the closest opened tag of the same type</span></span><br><span class="line">      <span class="keyword">if</span> (tagName) &#123;</span><br><span class="line">        lowerCasedTagName = tagName.toLowerCase();</span><br><span class="line">        <span class="keyword">for</span> (pos = stack.length - <span class="number">1</span>; pos &gt;= <span class="number">0</span>; pos--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If no tag name is provided, clean shop</span></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Close all the open elements, up the stack</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = stack.length - <span class="number">1</span>; i &gt;= pos; i--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (options.end) &#123;</span><br><span class="line">            options.end(stack[i].tag, start, end);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Remove the open elements from the stack</span></span><br><span class="line">        stack.length = pos;</span><br><span class="line">        lastTag = pos &amp;&amp; stack[pos - <span class="number">1</span>].tag;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看end钩子函数的处理逻辑，大致意思是取出stack栈中最后一项element，接着又使用closeElement来构建elemenet这个ast对象的父子级关系，currentParent又指定stack栈中的最后一项。<br>需要注意的是parse函数里面的stack栈和parseHTML函数里面的stack栈不是一回事，parse函数里面的stack栈中存放的是ast对象，parseHTML函数里面的stack栈存放的是所有开始标签的信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> element = stack[stack.length - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// pop stack</span></span><br><span class="line">            stack.length -= <span class="number">1</span>;</span><br><span class="line">            currentParent = stack[stack.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (options.outputSourceRange) &#123;</span><br><span class="line">                element.end = end$<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            closeElement(element);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 解析到文本的钩子函数</span></span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建ast对象的父子级关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeElement</span> (<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    currentParent.children.push(element);</span><br><span class="line">    element.parent = currentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终返回的root根元素就是最终的ast树。以上，就是Vue内部如何把一个html字符串转换成ast树的过程，我们看看ast树的结构,其中包含了父子级关系，if for directives等指令标记，节点自身的相关信息</p><img src="/images/asttree.png" width="600px" >]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vue上手非常简单，因为我们可以直接编写html作为组件的模版，对比学习React还需要接触&lt;code&gt;jsx&lt;/code&gt;语法，Vue对新手可以说是非常友好了，接下来我们看看vue是如何处理template模版的？&lt;/p&gt;
&lt;h2 id=&quot;Vue编译器入口&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>1. Vue如何构建响应式系统?</title>
    <link href="http://example.com/2020/11/21/vue01/"/>
    <id>http://example.com/2020/11/21/vue01/</id>
    <published>2020-11-21T11:07:30.000Z</published>
    <updated>2020-12-17T13:50:23.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="响应式系统入口"><a href="#响应式系统入口" class="headerlink" title="响应式系统入口"></a>响应式系统入口</h2><p>vue2.x版本的响应系统入口是observe函数，先看下Vue内部的处理：</p><h3 id="observe-amp-Observer"><a href="#observe-amp-Observer" class="headerlink" title="observe &amp; Observer"></a>observe &amp; Observer</h3><ol><li>可以看到observe函数只检测数组和普通对象，并对数组和普通对象做了不同处理</li><li>Observer类的实例会有dep属性，该属性用来指向dep订阅器对象，注意：初始化时dep订阅器对象为空。dep属性的作用是什么？我们会在<code>Vue如何构建依赖关系</code>时讲到。 </li><li><code>def(value, &#39;__ob__&#39;, this)</code>其实就是给观测的数组/普通对象添加__ob__属性，值指向Observer的实例，__ob__属性的作用是什么？我们会在<code>Vue的更新策略</code>时讲到。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value, asRootData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ob;</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep(value);</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123; <span class="comment">//构建数组对象的响应式系统</span></span><br><span class="line">       protoAugment(value, arrayMethods);</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//构建普通对象的响应式系统</span></span><br><span class="line">      <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h2><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>可以看到构建数据对象data的响应式系统很简单，就是用<code>Object.defineProperty</code>给data的每个key都设置get/set钩子,用户每次获取值的时候例如<code>this.data.msg</code>，都会触发key的get钩子，设置新值的时候例如<code>this.data.msg=&#39;新的msg&#39;</code>，都会触发key的set钩子从而让视图更新，不过视图更新我们会在<code>Vue的更新策略</code>讨论,不管怎样，普通对象的响应式系统确实是通过<code> Object.defineProperty</code>这个API很轻易的构建出来了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Observer.prototype.walk = <span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive$$1(obj, keys[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive$$1</span>(<span class="params"> obj, key, val, customSetter, shallow </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep(key);</span><br><span class="line">    <span class="keyword">var</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">        <span class="comment">// TODO </span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">        <span class="comment">// 老值和新值相等 就终止函数</span></span><br><span class="line">        <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (customSetter) &#123;</span><br><span class="line">          customSetter();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getter &amp;&amp; !setter) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">          setter.call(obj, newVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 劫持新设置的值  </span></span><br><span class="line">        childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">        dep.notify(); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h3><p>还有一个问题，平时我们都是<code>this.msg</code>就可以获取data中的<code>msg</code>了，现在这个响应式系统只能通过<code>this.data.msg</code>拿到data中的<code>msg</code>。很显然，这个响应式系统并不完善，我们看看vue源码如何实现更完善的响应式系统的？</p><ol><li>把数据对象data数据对象存到<code>_data</code>中</li><li>触发proxy函数，proxy函数的功能就是每次访问<code>vm[key]</code>时都会返回<code>vm._data[key]</code>属性<br>以上就实现了更完善的响应式系统了。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = vm.$options.data;</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line">  <span class="keyword">var</span> i = keys.length;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    proxy(vm, <span class="string">&quot;_data&quot;</span>, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据代理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">target, sourceKey, key</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key]</span><br><span class="line">  &#125;;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[sourceKey][key] = val;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// vm.msg --&gt; vm._data.msg</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h2><p>普通对象的响应式系统已经构建完成了，我们接下来再看看数组对象是如何构建响应式系统的？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep(value);</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      protoAugment(value, arrayMethods);</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改隐式原型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span>(<span class="params">target, src</span>) </span>&#123;</span><br><span class="line">  target.__proto__ = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，当处理数组的时候会触发<code>protoAugment</code>函数把数组的隐式原型<code>__proto__</code>指向了<code>arrayMethods</code>,那<code>arrayMethods</code>是什么呢？看下面的代码可知：</p><ol><li><code>arrayMethods</code>是一个空对象，其隐式原型<code>__proto__</code>指向了<code>Array.prototype</code>，这样的话，在<code>arrayMethods</code>这个对象的原型链上就有了数组的所有方法了。</li><li>遍历<code>methodsToPatch</code>，给<code>arrayMethods</code>对象添加<code>push,pop,shift,unshift,splice,sort,reverse</code>这七个属性，值是mutator函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">var</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> methodsToPatch = [</span><br><span class="line">    <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 基于原型链获取数组原型上的方法</span></span><br><span class="line">    <span class="keyword">var</span> original = arrayProto[method];</span><br><span class="line">    <span class="comment">// 给arrayMethods对象设置method属性  即arrayMethods[&#x27;push&#x27;] = mutator  </span></span><br><span class="line">    def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> args = [], len = <span class="built_in">arguments</span>.length;</span><br><span class="line">      <span class="keyword">while</span> (len--) args[len] = <span class="built_in">arguments</span>[len];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> result = original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      <span class="keyword">var</span> ob = <span class="built_in">this</span>.__ob__;</span><br><span class="line">      <span class="keyword">var</span> inserted;</span><br><span class="line">      <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">          inserted = args;</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">          inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (inserted) &#123; ob.observeArray(inserted); &#125;</span><br><span class="line">      <span class="comment">// notify change</span></span><br><span class="line">      ob.dep.notify();</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/images/1.png" width="300px" ><p>可以看到，最终的<code>arrayMethods</code>就是上面的结构，它是一个对象，自身有7个属性，隐式原型上有所有的数组方法，想象一下，如果我们执行<code>this.list.push(2)</code>，就会沿着原型链找到<code>arrayMethods</code>对象上的<code>push</code>方法执行，即mutator函数，mutator函数内部的逻辑其实就是触发视图更新。这个我们在后面章节<code>Vue的更新策略</code>讨论 ，不管怎样，数组对象的响应式系统确实是通过延长数组对象的原型链构建出来了。</p><p>需要注意的是，对于数组，Vue只为<code>methodsToPatch</code>中的7个方法构建了响应式系统，对于其他的数组方法，Vue并没有构建响应式系统。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>以上，就是Vue如何为数组对象/普通对象构建响应式系统的过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;响应式系统入口&quot;&gt;&lt;a href=&quot;#响应式系统入口&quot; class=&quot;headerlink&quot; title=&quot;响应式系统入口&quot;&gt;&lt;/a&gt;响应式系统入口&lt;/h2&gt;&lt;p&gt;vue2.x版本的响应系统入口是observe函数，先看下Vue内部的处理：&lt;/p&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存策略</title>
    <link href="http://example.com/2020/11/19/cache/"/>
    <id>http://example.com/2020/11/19/cache/</id>
    <published>2020-11-19T15:49:23.000Z</published>
    <updated>2020-12-16T07:39:06.693Z</updated>
    
    <content type="html"><![CDATA[<h4 id="当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。"><a href="#当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。" class="headerlink" title="当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。"></a>当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。</h4><h2 id="1-目录结构如下"><a href="#1-目录结构如下" class="headerlink" title="1.目录结构如下"></a>1.目录结构如下</h2><img src="/images/directry.png" width="300px" ><h2 id="2-首页结构"><a href="#2-首页结构" class="headerlink" title="2.首页结构"></a>2.首页结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- cache.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;data:image/ico;base64,aWNv&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>基于node学习浏览器缓存策略<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是服务首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-搭建服务"><a href="#3-搭建服务" class="headerlink" title="3.搭建服务"></a>3.搭建服务</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (request.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createStream(<span class="string">&#x27;./cache.html&#x27;</span>); </span><br><span class="line">        readStream.pipe(response) </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.test(request.url)) &#123;  </span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;./script.js&#x27;</span>);</span><br><span class="line">        readStream.pipe(response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-强缓存"><a href="#4-强缓存" class="headerlink" title="4.强缓存"></a>4.强缓存</h2><h4 id="触发浏览器强缓存策略需要后端配置特殊字段Expires-Cache-Control均可，并且返回状态码200"><a href="#触发浏览器强缓存策略需要后端配置特殊字段Expires-Cache-Control均可，并且返回状态码200" class="headerlink" title="触发浏览器强缓存策略需要后端配置特殊字段Expires/Cache-Control均可，并且返回状态码200"></a>触发浏览器强缓存策略需要后端配置特殊字段Expires/Cache-Control均可，并且返回状态码200</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (request.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createStream(<span class="string">&#x27;./cache.html&#x27;</span>); </span><br><span class="line">        readStream.pipe(response) </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.test(request.url)) &#123;  </span><br><span class="line">        <span class="comment">// Expires字段设置的时间是固定的某个时间点</span></span><br><span class="line">        <span class="comment">// response.writeHead(200, &#123; </span></span><br><span class="line">        <span class="comment">//     &#x27;Expires&#x27;: new Date(&#x27;2020-12-30 12:00:00&#x27;),</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="comment">// Cache-Control字段设置的是相对于本次服务端返回的时间 单位s</span></span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">           <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=200&#x27;</span>   </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;./script.js&#x27;</span>);</span><br><span class="line">        readStream.pipe(response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一次访问资源命中强缓存之后，浏览器就不会同样的资源发起网络请求了，浏览器会直接强制从memory(内存)/disk(硬盘)中读取资源，如下所示<br><img src="/images/image.png"></p><h2 id="5-协商缓存"><a href="#5-协商缓存" class="headerlink" title="5.协商缓存"></a>5.协商缓存</h2><h4 id="触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified-Etag均可，并且返回状态码304"><a href="#触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified-Etag均可，并且返回状态码304" class="headerlink" title="触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified/Etag均可，并且返回状态码304"></a>触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified/Etag均可，并且返回状态码304</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (request.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createStream(<span class="string">&#x27;./cache.html&#x27;</span>);   </span><br><span class="line">        readStream.pipe(response) </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.test(request.url)) &#123;  </span><br><span class="line">        <span class="comment">// const buffer = fs.readFileSync(&#x27;./script.js&#x27;);</span></span><br><span class="line">        <span class="comment">// const fileMd5 = md5(buffer); 文件的md5值</span></span><br><span class="line">        <span class="comment">// const noneMatch = request.headers[&#x27;if-none-match&#x27;]; 来自浏览器端传递的值</span></span><br><span class="line">        <span class="comment">// 协商成功 状态码返回304</span></span><br><span class="line">        <span class="comment">// if (noneMatch === fileMd5) &#123;</span></span><br><span class="line">        <span class="comment">//     response.statusCode = 304;</span></span><br><span class="line">        <span class="comment">//     response.end();</span></span><br><span class="line">        <span class="comment">//     return;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 协商失败 状态码返回200</span></span><br><span class="line">        <span class="comment">// response.writeHead(200, &#123;</span></span><br><span class="line">        <span class="comment">//     &#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;,</span></span><br><span class="line">        <span class="comment">//     &#x27;ETag&#x27;: fileMd5,</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="keyword">const</span> stat = fs.statSync(<span class="string">&#x27;./script.js&#x27;</span>); </span><br><span class="line">        <span class="keyword">const</span> mtime = stat.mtime.toGMTString() </span><br><span class="line">        <span class="keyword">const</span> requestMtime = request.headers[<span class="string">&#x27;if-modified-since&#x27;</span>]; </span><br><span class="line">        <span class="comment">// 协商成功  本次服务端不返回资源  让浏览器使用缓存的资源</span></span><br><span class="line">        <span class="keyword">if</span> (mtime === requestMtime) &#123;</span><br><span class="line">            response.statusCode = <span class="number">304</span>; <span class="comment">//必须返回304</span></span><br><span class="line">            response.end();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 协商失败 状态码返回200</span></span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;Last-Modified&#x27;</span>: mtime,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>, <span class="comment">// 必须设置，否则下次浏览器请求会命中强缓存</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;./script.js&#x27;</span>);</span><br><span class="line">        readStream.pipe(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一次访问资源命中协商缓存之后，浏览器会在下次网络请求中用特殊字段(if-modified-since/if-no-match)携带第一次访问后端时返回的响应头信息，后端在对比前后数据之后，判断资源的内容是否更改，如果更改，就协商失败，返回最新的资源给浏览器，如果没有更改，就协商成功，不返回数据给浏览器，浏览器最终使用缓存的资源</p><h2 id="6-强缓存和协商缓存对比"><a href="#6-强缓存和协商缓存对比" class="headerlink" title="6.强缓存和协商缓存对比"></a>6.强缓存和协商缓存对比</h2><p>6.1 强缓存优先级比协商缓存高，因为浏览器总是倾向于请求更少的资源，命中强缓存后，浏览器都不会向后端请求资源了，所以强缓存优先级比协商缓存高<br>6.2 判断是否命中强缓存的纬度是时间，Expires是固定时间，Cache-Control是相对时间 ;<br>判断是否命中协商缓存的纬度是资源内容是否被更改，Last-Modified是用资源的修改时间，Etag是用资源的hash值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。&quot;&gt;&lt;a href=&quot;#当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="浏览器" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/11/17/hello-world/"/>
    <id>http://example.com/2020/11/17/hello-world/</id>
    <published>2020-11-16T16:51:19.875Z</published>
    <updated>2020-11-19T15:35:10.620Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
