<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>4.Vue如何构建依赖关系</title>
      <link href="2020/12/15/vue04/"/>
      <url>2020/12/15/vue04/</url>
      
        <content type="html"><![CDATA[<p>在第三节文章中，我们知道了Vue把template编译成render函数的过程。接下来Vue内部会怎么处理呢？其实接下来Vue就会执行mountComponent函数来挂载组件，如下所示,函数内部逻辑也很清晰</p><ol><li>触发beforeMount钩子</li><li>创建watcher的求值函数updateComponent，其中_render函数是创建虚拟dom,_update函数在首次触发是创建真实dom,再次触发是比对前后的虚拟dom</li><li>创建渲染watcher,其中最后一个参数true表示该watcher是渲染watcher</li><li>触发mounted钩子</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vm, el,hydrating</span>) </span>&#123;</span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> updateComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        vm._update(vm._render(), hydrating);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">        before: <span class="function"><span class="keyword">function</span> <span class="title">before</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">                callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">        vm._isMounted = <span class="literal">true</span>;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来咱们看看Vue是如何定义Watcher这个类的，代码如下，对于Watcher类的参数需要详细说下：</p><ol><li>expOrFn 存储watcher的求值函数 ，对于渲染watcher，expOrFn就是updateComponent ，当然除了watcher之后，其实还会有别的两类watcher，分别为计算属性创建的lazyWatcher和为watch选项创建的自定义watcher，这两类对应的求值函数是什么后面再说。</li><li>cb 存储求值函数expOrFn执行后的回调函数，对于渲染watcher，cb就是noop空函数</li><li>options 存储watcher创建的配置参数，其中创建渲染watcher传入的配置对象有before钩子函数，创建自定义watcher时传入的配置对象有user属性为true，创建lazyWatcher时传入的配置对象有lazy属性为true。</li><li>isRenderWatcher 表示创建的watcher是否是渲染watcher，isRenderWatcher为true表示渲染watcher，并将渲染watcher放到vm._watcher中。</li></ol><p>除了这些参数之外，还有别的处理，比如:</p><ol><li>每次创建watcher时都会把watcher放到vm._watchers</li><li>在创建watcher时，基于lazy值判断是否执行求值函数，其中如果是lazyWatcher就不求值，不是lazyWatcher就求值。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Watcher = <span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params"> vm, expOrFn, cb, options, isRenderWatcher</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = !!options.deep;</span><br><span class="line">      <span class="built_in">this</span>.user = !!options.user;</span><br><span class="line">      <span class="built_in">this</span>.lazy = !!options.lazy;</span><br><span class="line">      <span class="built_in">this</span>.sync = !!options.sync;</span><br><span class="line">      <span class="built_in">this</span>.before = options.before;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = <span class="built_in">this</span>.user = <span class="built_in">this</span>.lazy = <span class="built_in">this</span>.sync = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.id = ++uid$<span class="number">2</span>; <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="built_in">this</span>.active = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="built_in">this</span>.lazy; <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="built_in">this</span>.deps = [];</span><br><span class="line">    <span class="built_in">this</span>.newDeps = [];</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="keyword">new</span> _Set();</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = <span class="keyword">new</span> _Set();</span><br><span class="line">    <span class="built_in">this</span>.expression = expOrFn.toString();</span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.lazy ? <span class="literal">undefined</span> : <span class="built_in">this</span>.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面的分析，只要不是lazyWatcher就求值，那我们在初始化渲染watcher就会触发求值函数了，接下来我们看看求值函数的逻辑：<br>1.触发pushTarget，当前的watcher入targetStack栈，Dep.target指向栈顶的watcher<br>2.触发求值函数getter<br>3.触发popTarget，当前的watcher出targetStack栈，Dep.target指向栈顶的watcher<br>4.触发cleanupDeps函数，depIds/deps存储本次newDepIds/newDeps的值，之后再清空newDepIds/newDeps</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    pushTarget(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>.vm;</span><br><span class="line">    value = <span class="built_in">this</span>.getter.call(vm, vm);</span><br><span class="line">    popTarget();</span><br><span class="line">    <span class="built_in">this</span>.cleanupDeps();</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> targetStack = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    targetStack.push(target);</span><br><span class="line">    Dep.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    targetStack.pop();</span><br><span class="line">    Dep.target = targetStack[targetStack.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.cleanupDeps = <span class="function"><span class="keyword">function</span> <span class="title">cleanupDeps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="built_in">this</span>.deps.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">var</span> dep = <span class="built_in">this</span>.deps[i];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="built_in">this</span>.depIds;</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="built_in">this</span>.newDepIds;</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = tmp;</span><br><span class="line">    <span class="built_in">this</span>.newDepIds.clear();</span><br><span class="line">    tmp = <span class="built_in">this</span>.deps;</span><br><span class="line">    <span class="built_in">this</span>.deps = <span class="built_in">this</span>.newDeps;</span><br><span class="line">    <span class="built_in">this</span>.newDeps = tmp;</span><br><span class="line">    <span class="built_in">this</span>.newDeps.length = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于渲染watcher来说，getter就是updateComponent函数，而updateComponent函数的逻辑也很清晰:</p><ol><li>触发_render函数</li><li>触发_update函数<br>可以看到_render函数内部就是执行render，而这个render函数就是基于template模版创建的render函数，值的注意的是，执行render函数时，会将内部this指向vm._renderProxy，vm._renderProxy对象经过处理指向组件实例vm。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> updateComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    vm._update(vm._render(), hydrating);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> ref = vm.$options;</span><br><span class="line">    <span class="keyword">var</span> render = ref.render;</span><br><span class="line">    <span class="keyword">var</span> vnode = render.call(vm._renderProxy, vm.$createElement);</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假定template模版如下，则生成的render函数如下图所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">app</span> <span class="attr">class</span>=<span class="string">&quot;heaven&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;handleClick&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/images/render.png"  ><p>当执行render函数时，有个with语句，执行with内部逻辑时，总是从this中取值，即取msg的值时，等价取vm.msg，因为我们之前做了数据代理的原因， 所以取vm.msg时，等价取vm._data.msg ,此时就触发了msg的get钩子函数。这时候get函数内部就会构建属性msg和watcher的依赖关系，我们看看get函数内部是怎么做的？</p><ol><li>判断Dep.target是否存在，之所以要有这个判断，是因为我们只要在渲染watcher/lazyWatcher/自定义watcher的求值函数触发时，才触发dep.depend函数</li><li>判断childOb是否存在，存在就执行childOb.dep.depend，childOb是什么？为什么要执行childOb.dep.depend，我们稍等再说。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive$$1</span>(<span class="params"> obj, key, val, customSetter,shallow</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep(key);</span><br><span class="line">    <span class="keyword">var</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                dep.depend();</span><br><span class="line">                <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">                    childOb.dep.depend();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">                        dependArray(value);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            val = newVal;</span><br><span class="line">            childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面的分析，我们知道Dep.target存在的话就要执行dep.depend方法，我们看看这个函数内部做了什么？</p><ol><li>也是判断是否Dep.target是否存在，值得注意的是，此时Dep.target指向渲染watcher，并且执行渲染watcher的addDep方法</li><li>watcher的addDep方法内部用到两个if判断，第一个判断是为了防止在本次求值过程中重复把watcher放到dep对象中，第二个if判断是为了防止在不同的求值时刻（用户更新视图会再次求值，再次求值会再次走到addDep的逻辑中）重复把watcher放到dep对象中。</li><li>最终会触发 dep.addSub方法，把watcher放到depd对象的subs中。<br>至此属性msg的dep对象中的subs数组收集到了渲染watcher，这就是某个属性的依赖收集过程。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Dep = <span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.id = uid++;</span><br><span class="line">    <span class="built_in">this</span>.subs = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dep.prototype.addSub = <span class="function"><span class="keyword">function</span> <span class="title">addSub</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">&#125;;</span><br><span class="line">Dep.prototype.depend = <span class="function"><span class="keyword">function</span> <span class="title">depend</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        Dep.target.addDep(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.addDep = <span class="function"><span class="keyword">function</span> <span class="title">addDep</span>(<span class="params">dep</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = dep.id;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.newDepIds.add(id);</span><br><span class="line">        <span class="built_in">this</span>.newDeps.push(dep);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.depIds.has(id)) &#123;</span><br><span class="line">            dep.addSub(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实现express的洋葱模型</title>
      <link href="2020/12/11/express01/"/>
      <url>2020/12/11/express01/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3. Vue生成ast树后，做了肾么事？</title>
      <link href="2020/12/06/vue03/"/>
      <url>2020/12/06/vue03/</url>
      
        <content type="html"><![CDATA[<p>Vue生成了ast语法树之后，还对这个树结构进行了静态标记，之所以给ast树打上是否是静态的标记，是因为在后面diff算法的时候，直接跳过静态的节点，可以节省diff的开销。下面我们看看是怎么给节点打静态标记的吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ast = parse(template.trim(), options);</span><br><span class="line"><span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">    optimize(ast, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">optimize</span>(<span class="params">root, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    isStaticKey = genStaticKeysCached(options.staticKeys || <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    isPlatformReservedTag = options.isReservedTag || no;</span><br><span class="line">    <span class="comment">// 给节点打上是否是静态节点的标记</span></span><br><span class="line">    markStatic$<span class="number">1</span>(root);</span><br><span class="line">    <span class="comment">// 给节点打上是否是静态根节点的标记</span></span><br><span class="line">    markStaticRoots(root, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，markStatic$1函数是给节点打上是否是静态节点的标记，markStaticRoots函数是给节点打上是否是静态根节点的标记，我们先看看markStatic$1函数内部的逻辑，其实核心isStatic函数，这个函数是判断节点是否是静态节点。判断的逻辑大致如下</p><ol><li>如果是插值文本 那就不是静态节点</li><li>如果是普通文本 那就是静态节点</li><li>有跳过编译的指令pre 那就是静态节点</li><li>没有属性绑定&amp;有if for&amp;不是Vue内置标签等 那就是静态节点</li></ol><p>在经过上面判断出这个节点是否是静态节点，如果是那就给这个节点在加上<code>static:true</code>标记，当然这还没结束，接着还会在遍历这个节点的子节点们，判断子节点是否是静态节点，一旦某个子节点不是静态节点，那就给这个节点<br>打上<code>static:false</code>标记</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">markStatic$1</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    node.static = isStatic(node);</span><br><span class="line">   <span class="keyword">if</span> (node.type === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> child = node.children[i];</span><br><span class="line">        markStatic$<span class="number">1</span>(child);</span><br><span class="line">        <span class="keyword">if</span> (!child.static) &#123;</span><br><span class="line">          node.static = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isStatic</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="number">2</span>) &#123; <span class="comment">// expression</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="number">3</span>) &#123; <span class="comment">// text</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !!(node.pre || (</span><br><span class="line">      !node.hasBindings &amp;&amp; <span class="comment">// no dynamic bindings</span></span><br><span class="line">      !node.if &amp;&amp; !node.for &amp;&amp; <span class="comment">// not v-if or v-for or v-else</span></span><br><span class="line">      !isBuiltInTag(node.tag) &amp;&amp; <span class="comment">// not a built-in</span></span><br><span class="line">      isPlatformReservedTag(node.tag) &amp;&amp; <span class="comment">// not a component</span></span><br><span class="line">      !isDirectChildOfTemplateFor(node) &amp;&amp;</span><br><span class="line">      <span class="built_in">Object</span>.keys(node).every(isStaticKey)</span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再看看markStaticRoots函数的逻辑,判断节点是否是静态根节点的逻辑大致如下</p><ol><li>如果是该节点是静态节点，并且这个节点的子节点长度大于1，那这个节点就是静态根节点</li><li>不满足上述条件，则这个节点就不是静态根节点<br>在经过上面判断出这个节点是否是静态根节点，如果是那就给这个节点在加上<code>staticRoot:true</code>标记，当然这还没结束，接着还会在遍历这个节点的子节点们，判断子节点是否是静态根节点，最后给子节点们打上staticRoot标记</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStaticRoots</span>(<span class="params">node, isInFor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// For a node to qualify as a static root, it should have children that</span></span><br><span class="line">      <span class="comment">// are not just static text. Otherwise the cost of hoisting out will</span></span><br><span class="line">      <span class="comment">// outweigh the benefits and it&#x27;s better off to just always render it fresh.</span></span><br><span class="line">      <span class="keyword">if</span> (node.static &amp;&amp; node.children.length &amp;&amp; !(</span><br><span class="line">        node.children.length === <span class="number">1</span> &amp;&amp;</span><br><span class="line">        node.children[<span class="number">0</span>].type === <span class="number">3</span></span><br><span class="line">      )) &#123;</span><br><span class="line">        node.staticRoot = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.staticRoot = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.children) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">          markStaticRoots(node.children[i], isInFor || !!node.for);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终Vue就处理好了ast树，接着会基于ast树生成代码，,这里使用到了generate函数，generate这个函数内部的逻辑大致是:</p><ol><li>genElement函数内部创建节点对应的代码存到data中</li><li>genChildren函数内部创建节点的子节点对应的代码存到children中</li><li>最终基于data和children拼接成最终的code，其中如果节点有if for once等指令，会转换成特殊的代码</li><li>如果是静态根节点，就生成代码并存到staticRenderFns中<br>值得注意的是，我们在下面代码中可以得到结论：v-for的优先级比v-if的优先级<br>因为generate函数内部是先处理el.for，再处理el.if的。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ast = parse(template.trim(), options);</span><br><span class="line"><span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">    optimize(ast, options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> code = generate(ast, options);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">ast, options </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="keyword">new</span> CodegenState(options);</span><br><span class="line">    <span class="keyword">var</span> code = ast ? genElement(ast, state) : <span class="string">&#x27;_c(&quot;div&quot;)&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        render: (<span class="string">&quot;with(this)&#123;return &quot;</span> + code + <span class="string">&quot;&#125;&quot;</span>),</span><br><span class="line">        staticRenderFns: state.staticRenderFns</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genElement</span>(<span class="params">el, state</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (el.parent) &#123;</span><br><span class="line">        el.pre = el.pre || el.parent.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;</span><br><span class="line">        <span class="keyword">return</span> genStatic(el, state)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.once &amp;&amp; !el.onceProcessed) &#123;</span><br><span class="line">        <span class="keyword">return</span> genOnce(el, state)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.for &amp;&amp; !el.forProcessed) &#123;</span><br><span class="line">        <span class="keyword">return</span> genFor(el, state)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.if &amp;&amp; !el.ifProcessed) &#123;</span><br><span class="line">        <span class="keyword">return</span> genIf(el, state)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.tag === <span class="string">&#x27;template&#x27;</span> &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123;</span><br><span class="line">        <span class="keyword">return</span> genChildren(el, state) || <span class="string">&#x27;void 0&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.tag === <span class="string">&#x27;slot&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> genSlot(el, state)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// component or element</span></span><br><span class="line">        <span class="keyword">var</span> code;</span><br><span class="line">        <span class="keyword">if</span> (el.component) &#123;</span><br><span class="line">        code = genComponent(el.component, el, state);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> data;</span><br><span class="line">        <span class="keyword">if</span> (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) &#123;</span><br><span class="line">            data = genData$<span class="number">2</span>(el, state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> children = el.inlineTemplate ? <span class="literal">null</span> : genChildren(el, state, <span class="literal">true</span>);</span><br><span class="line">            code = <span class="string">&quot;_c(&#x27;&quot;</span> + (el.tag) + <span class="string">&quot;&#x27;&quot;</span> + (data ? (<span class="string">&quot;,&quot;</span> + data) : <span class="string">&#x27;&#x27;</span>) + (children ? (<span class="string">&quot;,&quot;</span> + children) : <span class="string">&#x27;&#x27;</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// module transforms</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; state.transforms.length; i++) &#123;</span><br><span class="line">            code = state.transforms[i](el, code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出的code为下图，其中render为可执行的字符串，staticRenderFns为静态节点字符串</p><img src="/images/code.png" ><p>生成code之后，接下来的处理是在compileToFunctions函数中,大致逻辑是：</p><ol><li>定义cache缓存对象</li><li>compile函数返回的是code对象,即compiled-&gt;code对象</li><li>基于render/staticRenderFns创建函数</li><li>返回res对象，并将key-&gt;res存到缓存对象中,这个是vue的优化策略，当第二次再次编译同样的模版时，会直接取出render/staticRenderFns，不会重复编译出render/staticRenderFns，这样在多次使用组件时，就可以极大的节省浏览器开销</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">compileToFunctions</span>(<span class="params"> template, options, vm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//  此时省略很多代码</span></span><br><span class="line">    <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编译模版</span></span><br><span class="line">    <span class="keyword">var</span> compiled = compile(template, options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> fnGenErrors = [];</span><br><span class="line">    res.render = createFunction(compiled.render, fnGenErrors);</span><br><span class="line">    res.staticRenderFns = compiled.staticRenderFns.map(<span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createFunction(code, fnGenErrors)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (cache[key] = res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunction</span>(<span class="params">code, errors</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此Vue编译模版终于结束了，过程是从html字符串-&gt;ast语法树-&gt;code对象-&gt;render函数。其实还有一个很重要的问题，就是Vue在模版编译的过程中，函数嵌套很严重，Vue内部为什么嵌套这么多层呢？其实</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js小技巧</title>
      <link href="2020/12/03/js%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
      <url>2020/12/03/js%E9%AA%9A%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>金额格式化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num =  <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = num.toLocaleString()  <span class="comment">// 1,000,000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/(?=(\B)(\d&#123;3&#125;)+$)/g</span></span><br><span class="line"><span class="keyword">let</span> result = num.toString().replace(reg,<span class="string">&#x27;,&#x27;</span>) <span class="comment">// 1,000,000</span></span><br></pre></td></tr></table></figure><p>交换值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">b = [a,a=b][<span class="number">0</span>] <span class="comment">//a=1 b=2</span></span><br><span class="line"></span><br><span class="line">a = a^b</span><br><span class="line">b = a^b</span><br><span class="line">a = a^b  <span class="comment">//a=1 b=2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2.  Vue如何编译模版</title>
      <link href="2020/12/01/vue02/"/>
      <url>2020/12/01/vue02/</url>
      
        <content type="html"><![CDATA[<p>Vue上手非常简单，因为我们可以直接编写html作为组件的模版，对比学习React还需要接触<code>jsx</code>语法，Vue对新手可以说是非常友好了，接下来我们看看vue是如何处理template模版的？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createCompiler = createCompilerCreator(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span>(<span class="params">template, options</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// template -&gt; ast   对template的第一层抽象</span></span><br><span class="line">        <span class="keyword">var</span> ast = parse(template.trim(), options);</span><br><span class="line">        <span class="comment">// 优化ast树 标注静态节点</span></span><br><span class="line">        <span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">            optimize(ast, options);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ast -&gt; 可执行code  对template的第二层抽象</span></span><br><span class="line">        <span class="keyword">var</span> code = generate(ast, options);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ast: ast,</span><br><span class="line">            render: code.render,</span><br><span class="line">            staticRenderFns: code.staticRenderFns</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>可以看到首先是template模版放到parse函数中处理，得到ast对象(abstract syntax tree)，其实ast对象是对template的第一层抽象，template模版本质上是一个html字符串，现在用ast对象来描述template模版，接下来看看html字符串如何被转换成ast对象的？假定template模版如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html模版</span></span><br><span class="line"><span class="keyword">let</span> template = <span class="string">`</span></span><br><span class="line"><span class="string">     &lt;div id=app v-if=&#x27;msg&#x27; v-for=&#x27;item in 3&#x27; v-once:click=&#x27;handleClick&#x27;&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&#x27;text&#x27; title=&#x27;heaven&#x27;&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">        <span class="comment">// 解析到开始标签的钩子函数</span></span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        <span class="comment">//  解析到结束标签的钩子函数</span></span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        <span class="comment">// 解析到文本的钩子函数</span></span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到真正处理template的是parseHTML这个函数，我们看看这个函数内部的逻辑是什么？其实大致有4步</p><ol><li>定义token，这些token用来解析开始标签 标签属性 结束标签等</li><li>处理开始标签，并把处理的结果交给handleStartTag处理</li><li>处理结束标签，并把处理的结果交给parseEndTag处理</li><li>处理文本，并把文本交给chars钩子函数处理<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  解析属性的token id=&#x27;app&#x27;</span></span><br><span class="line"><span class="keyword">var</span> attribute = <span class="regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span>;</span><br><span class="line"><span class="keyword">var</span> ncname = <span class="string">&quot;[a-zA-Z_][\\-\\.0-9_a-zA-Z&quot;</span> + (unicodeRegExp.source) + <span class="string">&quot;]*&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> qnameCapture = <span class="string">&quot;((?:&quot;</span> + ncname + <span class="string">&quot;\\:)?&quot;</span> + ncname + <span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="comment">// 解析开始标签的token &lt;div </span></span><br><span class="line"><span class="keyword">var</span> startTagOpen = <span class="keyword">new</span> <span class="built_in">RegExp</span>((<span class="string">&quot;^&lt;&quot;</span> + qnameCapture));</span><br><span class="line"><span class="comment">// 解析开始标签结束的token /&gt;  &gt;</span></span><br><span class="line"><span class="keyword">var</span> startTagClose = <span class="regexp">/^\s*(\/?)&gt;/</span>;</span><br><span class="line"><span class="comment">// 解析结束标签的token &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> endTag = <span class="keyword">new</span> <span class="built_in">RegExp</span>((<span class="string">&quot;^&lt;\\/&quot;</span> + qnameCapture + <span class="string">&quot;[^&gt;]*&gt;&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseHTML</span>(<span class="params">html, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (html) &#123;</span><br><span class="line">        <span class="keyword">var</span> textEnd = html.indexOf(<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">        <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">        <span class="comment">// 处理开始标签</span></span><br><span class="line">        <span class="keyword">var</span> startTagMatch = parseStartTag();</span><br><span class="line">        <span class="keyword">if</span> (startTagMatch) &#123;</span><br><span class="line">            handleStartTag(startTagMatch);</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理结束标签</span></span><br><span class="line">        <span class="keyword">var</span> endTagMatch = html.match(endTag);</span><br><span class="line">        <span class="keyword">if</span> (endTagMatch) &#123;</span><br><span class="line">            <span class="keyword">var</span> curIndex = index;</span><br><span class="line">            advance(endTagMatch[<span class="number">0</span>].length);</span><br><span class="line">            parseEndTag(endTagMatch[<span class="number">1</span>], curIndex, index);</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理文本 包括静态文本和插值</span></span><br><span class="line">        <span class="keyword">var</span> text </span><br><span class="line">        <span class="keyword">if</span> (textEnd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">            text = html.substring(<span class="number">0</span>, textEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (text) advance(text.length);</span><br><span class="line">        <span class="keyword">if</span> (options.chars &amp;&amp; text) &#123;</span><br><span class="line">            options.chars(text, index - text.length, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-解析开始标签"><a href="#1-解析开始标签" class="headerlink" title="1.解析开始标签"></a>1.解析开始标签</h4>接下来，我们看看parseStartTag函数是如何处理开始标签的？<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制全局的index/html向前移动n</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">advance</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    index += n;</span><br><span class="line">    html = html.substring(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseStartTag</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 解析到开始标签</span></span><br><span class="line">    <span class="keyword">var</span> start = html.match(startTagOpen);</span><br><span class="line">    <span class="keyword">if</span> (start) &#123;</span><br><span class="line">        <span class="keyword">var</span> match = &#123;</span><br><span class="line">            tagName: start[<span class="number">1</span>], </span><br><span class="line">            attrs: [],</span><br><span class="line">            start: index</span><br><span class="line">        &#125;;</span><br><span class="line">        advance(start[<span class="number">0</span>].length);</span><br><span class="line">        <span class="keyword">var</span> end, attr;</span><br><span class="line">        <span class="keyword">while</span> (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(dynamicArgAttribute) || html.match(attribute))) &#123;</span><br><span class="line">            attr.start = index;</span><br><span class="line">            advance(attr[<span class="number">0</span>].length);</span><br><span class="line">            attr.end = index;</span><br><span class="line">            match.attrs.push(attr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end) &#123;</span><br><span class="line">            match.unarySlash = end[<span class="number">1</span>];</span><br><span class="line">            advance(end[<span class="number">0</span>].length);</span><br><span class="line">            match.end = index;</span><br><span class="line">            <span class="keyword">return</span> match</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>最终开始标签<code>&lt;div id=&#39;app&#39;&gt;</code>被解析成下面的结构，其中attrs里面存放开始标签的属性集合，start是开始标签的起始位置，end是开始标签的结束位置，tagName是开始标签的标签类型，unarySlash为空代表标签为双标签，这样开始标签所有信息都被这个对象完美描述了，下面是match的结构图<img src="/images/start.png" width="300px" ></li></ol><p>接下来，开始标签的处理结果match还需要交给handleStartTag处理，我们看看handleStartTag内部的逻辑，其实也是很清晰的</p><ol><li>处理attrs属性，最终把标签的属性改成key:value的形式，并且标记attrs内部的属性开始和结束位置</li><li>将开始标签的信息放到stack栈中</li><li>触发start钩子函数<br>值的注意的是value值为<code>args[3] || args[4] || args[5]</code>,这是怎么回事呢？<br>这是因为对于属性值的三种形式<code>&lt;div id=&quot;app&quot;&gt;</code> app可以是单引号，双引号，不加引号，分别对应<code>args[3] || args[4] || args[5]</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStartTag</span>(<span class="params">match</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> tagName = match.tagName;</span><br><span class="line">      <span class="keyword">var</span> unarySlash = match.unarySlash;</span><br><span class="line">      <span class="keyword">var</span> unary = isUnaryTag$$1(tagName) || !!unarySlash;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> l = match.attrs.length;</span><br><span class="line">      <span class="keyword">var</span> attrs = <span class="keyword">new</span> <span class="built_in">Array</span>(l);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> args = match.attrs[i];</span><br><span class="line">        <span class="keyword">var</span> value = args[<span class="number">3</span>] || args[<span class="number">4</span>] || args[<span class="number">5</span>] || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        attrs[i] = &#123;</span><br><span class="line">          name: args[<span class="number">1</span>],</span><br><span class="line">          value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (options.outputSourceRange) &#123;</span><br><span class="line">          attrs[i].start = args.start + args[<span class="number">0</span>].match(<span class="regexp">/^\s*/</span>).length;</span><br><span class="line">          attrs[i].end = args.end;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理双标签</span></span><br><span class="line">      <span class="keyword">if</span> (!unary) &#123;</span><br><span class="line">        stack.push(&#123; <span class="attr">tag</span>: tagName, <span class="attr">lowerCasedTag</span>: tagName.toLowerCase(), <span class="attr">attrs</span>: attrs, <span class="attr">start</span>: match.start, <span class="attr">end</span>: match.end &#125;);</span><br><span class="line">        lastTag = tagName;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (options.start) &#123;</span><br><span class="line">        options.start(tagName, attrs, unary, match.start, match.end);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到Vue把数据做了处理之后，又把这些数据交给了start钩子处理，我们看看start钩子里面的逻辑<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createASTElement</span>(<span class="params">tag,attrs,parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="number">1</span>,</span><br><span class="line">      tag: tag,</span><br><span class="line">      attrsList: attrs,</span><br><span class="line">      attrsMap: makeAttrsMap(attrs),</span><br><span class="line">      rawAttrsMap: &#123;&#125;,</span><br><span class="line">      parent: parent,</span><br><span class="line">      children: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">tag, attrs, unary, start$<span class="number">1</span>, end</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> element = createASTElement(tag, attrs, currentParent);</span><br><span class="line">            <span class="keyword">if</span> (options.outputSourceRange) &#123;</span><br><span class="line">                element.start = start$<span class="number">1</span>;</span><br><span class="line">                element.end = end;</span><br><span class="line">                element.rawAttrsMap = element.attrsList.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">cumulated, attr</span>) </span>&#123;</span><br><span class="line">                    cumulated[attr.name] = attr;</span><br><span class="line">                    <span class="keyword">return</span> cumulated</span><br><span class="line">                &#125;, &#123;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理v-for v-if指令</span></span><br><span class="line">            <span class="keyword">if</span> (!element.processed) &#123;</span><br><span class="line">                processFor(element);  </span><br><span class="line">                processIf(element);</span><br><span class="line">                processOnce(element);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解析到的第一个元素 就是根节点</span></span><br><span class="line">            <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">                root = element;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  如果是双标签 那currentParent就指定当前的ast元素，并存到stack栈中</span></span><br><span class="line">            <span class="keyword">if</span> (!unary) &#123;</span><br><span class="line">                currentParent = element;</span><br><span class="line">                stack.push(element);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                closeElement(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其实start钩子内部大致就做了三件事：</li><li>根据createASTElement生成一个ast元素，该ast元素也是用来描述开始标签，虽然match也用来描述开始标签，但是JS操作ast元素显然更方便些。</li><li>处理开始标签上面的v-if v-for v-once指令 </li><li>初始化root currentParent stack的值，其中root存储模版的根节点，currentParent指定当前解析到的ast元素，stack存放解析到的所有ast元素<br>下面是开始标签对应ast元素的结构图:</li></ol><img src="/images/ast.png" width="600px" ><p>以上就是Vue内部解析开始标签的所有过程了，接下来我们再看看Vue内部如何解析文本的？,根据上面的分析，我们已经知道解析到文本会交给chars钩子处理，我们来看看chars钩子内部的逻辑。</p><h4 id="2-解析文本"><a href="#2-解析文本" class="headerlink" title="2.解析文本"></a>2.解析文本</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        <span class="comment">// 解析到文本的钩子函数</span></span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span> (<span class="params">text, start, end</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> children = currentParent.children;</span><br><span class="line">            <span class="keyword">var</span> res;</span><br><span class="line">            <span class="keyword">var</span> child;</span><br><span class="line">            <span class="comment">//   解析到有插值的文本</span></span><br><span class="line">            <span class="keyword">if</span> (!inVPre &amp;&amp; text !== <span class="string">&#x27; &#x27;</span> &amp;&amp; (res = parseText(text, delimiters))) &#123;</span><br><span class="line">                child = &#123;</span><br><span class="line">                    type: <span class="number">2</span>,</span><br><span class="line">                    expression: res.expression,</span><br><span class="line">                    tokens: res.tokens,</span><br><span class="line">                    text: text</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (text !== <span class="string">&#x27; &#x27;</span> || !children.length || children[children.length - <span class="number">1</span>].text !== <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析到没有插值的文本</span></span><br><span class="line">                child = &#123;</span><br><span class="line">                    type: <span class="number">3</span>,</span><br><span class="line">                    text: text</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chars钩子内部逻辑很简单，就是区分文本是否有插值符号，有插值符号的话ast对象type标记为2，并解析插值，没有插值就当作普通文本处理ast对象type标记为3。下面是插值文本对应的ast对象</p><img src="/images/char.png" width="300px" ><p>最后我们再看看Vue内部解析结束标签的过程，,根据上面的分析，我们已经知道解析到结束标签会交给parseEndTag函数处理，来看看parseEndTag函数内部的逻辑。大致意思是取出stack栈中的最后一项，并将最后一项的tag，start，end交给end钩子处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseEndTag</span>(<span class="params">tagName, start, end</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> pos, lowerCasedTagName;</span><br><span class="line">      <span class="keyword">if</span> (start == <span class="literal">null</span>) &#123; start = index; &#125;</span><br><span class="line">      <span class="keyword">if</span> (end == <span class="literal">null</span>) &#123; end = index; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Find the closest opened tag of the same type</span></span><br><span class="line">      <span class="keyword">if</span> (tagName) &#123;</span><br><span class="line">        lowerCasedTagName = tagName.toLowerCase();</span><br><span class="line">        <span class="keyword">for</span> (pos = stack.length - <span class="number">1</span>; pos &gt;= <span class="number">0</span>; pos--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If no tag name is provided, clean shop</span></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Close all the open elements, up the stack</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = stack.length - <span class="number">1</span>; i &gt;= pos; i--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (options.end) &#123;</span><br><span class="line">            options.end(stack[i].tag, start, end);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Remove the open elements from the stack</span></span><br><span class="line">        stack.length = pos;</span><br><span class="line">        lastTag = pos &amp;&amp; stack[pos - <span class="number">1</span>].tag;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看end钩子函数的处理逻辑，大致意思是取出stack栈中最后一项element，接着又使用closeElement来构建elemenet这个ast对象的父子级关系，currentParent又指定stack栈中的最后一项。<br>需要注意的是parse函数里面的stack栈和parseHTML函数里面的stack栈不是一回事，parse函数里面的stack栈中存放的是ast对象，parseHTML函数里面的stack栈存放的是所有开始标签的信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> element = stack[stack.length - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// pop stack</span></span><br><span class="line">            stack.length -= <span class="number">1</span>;</span><br><span class="line">            currentParent = stack[stack.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (options.outputSourceRange) &#123;</span><br><span class="line">                element.end = end$<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            closeElement(element);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 解析到文本的钩子函数</span></span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建ast对象的父子级关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeElement</span> (<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    currentParent.children.push(element);</span><br><span class="line">    element.parent = currentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终返回的root根元素就是最终的ast树。以上，就是Vue内部如何把一个html字符串转换成ast树的过程，我们看看ast树的结构,其中包含了父子级关系，if for directives等指令标记，节点自身的相关信息</p><img src="/images/asttree.png" width="600px" >]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1.  Vue如何构建响应式系统</title>
      <link href="2020/11/21/vue01/"/>
      <url>2020/11/21/vue01/</url>
      
        <content type="html"><![CDATA[<p>vue2.x版本的响应系统是基于Object.defineProperty实现的，我们看看vue源码的具体代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.value = value;</span><br><span class="line">  <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep(value);</span><br><span class="line">  <span class="built_in">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">  def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123; <span class="comment">//构建数组对象的响应式系统</span></span><br><span class="line">     protoAugment(value, arrayMethods);</span><br><span class="line">    <span class="built_in">this</span>.observeArray(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//构建普通对象的响应式系统</span></span><br><span class="line">    <span class="built_in">this</span>.walk(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到在构建响应式系统时，对普通对象和数组对象做了不同的处理，我们先看普通对象是如何构建响应式系统的？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Observer.prototype.walk = <span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive$$1(obj, keys[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive$$1</span>(<span class="params"> obj, key, val, customSetter, shallow </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep(key);</span><br><span class="line">    <span class="keyword">var</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">        <span class="comment">// TODO </span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">        <span class="comment">// 老值和新值相等 就终止函数</span></span><br><span class="line">        <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (customSetter) &#123;</span><br><span class="line">          customSetter();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getter &amp;&amp; !setter) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">          setter.call(obj, newVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 劫持新设置的值  </span></span><br><span class="line">        childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">        dep.notify(); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到构建数据对象data的响应式系统很简单，就是给data的每个key都设置get/set钩子,用户每次获取值的时候例如<code>this.data.msg</code>，都会触发key的get钩子，设置新值的时候例如<code>this.data.msg=&#39;新的msg&#39;</code>，都会触发key的set钩子，Vue在set/get钩子里面做了很多事情，不过这都是后面章节我们才讨论的,不管怎样，普通对象的响应式系统确实是通过<code> Object.defineProperty</code>这个API很轻易的构建出来了。<br>还有一个问题，平时我们都是<code>this.msg</code>就可以获取data中的<code>msg</code>了，现在这个响应式系统只能通过<code>this.data.msg</code>拿到data中的<code>msg</code>。很显然，这个响应式系统并不完善，我们看看vue源码如何实现更完善的响应式系统的？先是把data数据对象存到<code>_data</code>中，proxy函数的功能就是每次访问<code>vm[key]</code>时都会返回<code>vm._data[key]</code>属性,这样就实现了完善的响应式系统</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = vm.$options.data;</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line">  <span class="keyword">var</span> i = keys.length;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    proxy(vm, <span class="string">&quot;_data&quot;</span>, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据代理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">target, sourceKey, key</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key]</span><br><span class="line">  &#125;;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[sourceKey][key] = val;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// vm.msg --&gt; vm._data.msg</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通对象的响应式系统已经构建完成了，我们接下来再看看数组对象是如何构建响应式系统的？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep(value);</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      protoAugment(value, arrayMethods);</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改隐式原型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span>(<span class="params">target, src</span>) </span>&#123;</span><br><span class="line">    target.__proto__ = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，当处理数组的时候把数组的隐式原型<code>__proto__</code>指向了<code>arrayMethods</code>,那<code>arrayMethods</code>是什么呢？其实<code>arrayMethods</code>是一个普通对象，其隐式原型指定了<code>Array.prototype</code>,这样的话,在<code>arrayMethods</code>的原型链上就有了数组的所有方法了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">var</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> methodsToPatch = [</span><br><span class="line">    <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 基于原型链获取数组原型上的方法</span></span><br><span class="line">    <span class="keyword">var</span> original = arrayProto[method];</span><br><span class="line">    <span class="comment">// 给arrayMethods对象设置method属性  即arrayMethods[&#x27;push&#x27;] = mutator  </span></span><br><span class="line">    def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> args = [], len = <span class="built_in">arguments</span>.length;</span><br><span class="line">      <span class="keyword">while</span> (len--) args[len] = <span class="built_in">arguments</span>[len];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> result = original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      <span class="keyword">var</span> ob = <span class="built_in">this</span>.__ob__;</span><br><span class="line">      <span class="keyword">var</span> inserted;</span><br><span class="line">      <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">          inserted = args;</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">          inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (inserted) &#123; ob.observeArray(inserted); &#125;</span><br><span class="line">      <span class="comment">// notify change</span></span><br><span class="line">      ob.dep.notify();</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>现在我们看看<code>arrayMethods</code>是什么样子,可以看到它是一个对象，自身有7个key,隐式原型上有所有的数组方法，这样的话，如果我们执行<code>this.list.push(2)</code>，就会沿着原型链找到<code>arrayMethods</code>对象上的<code>push</code>方法执行，即mutator，而mutator内部的逻辑有三个:<br>1.执行<code>Array.prototype</code>的<code>push</code>方法<br>2. 劫持添加的数据再次构建响应式系统<br>3. <code>ob.dep.notify()</code>触发视图更新（后面章节会讲）<br><img src="/images/1.png" width="300px" ><br>需要注意的是，对于数组，Vue只为<code>methodsToPatch</code>中的7个方法构建了响应式系统，对于其他的数组方法，Vue并没有构建响应式系统。</p><p>以上，就是Vue如何构建响应式系统。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存策略</title>
      <link href="2020/11/19/cache/"/>
      <url>2020/11/19/cache/</url>
      
        <content type="html"><![CDATA[<h4 id="当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。"><a href="#当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。" class="headerlink" title="当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。"></a>当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。</h4><h2 id="1-目录结构如下"><a href="#1-目录结构如下" class="headerlink" title="1.目录结构如下"></a>1.目录结构如下</h2><img src="/images/directry.png" width="300px" ><h2 id="2-首页结构"><a href="#2-首页结构" class="headerlink" title="2.首页结构"></a>2.首页结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- cache.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;data:image/ico;base64,aWNv&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>基于node学习浏览器缓存策略<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是服务首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-搭建服务"><a href="#3-搭建服务" class="headerlink" title="3.搭建服务"></a>3.搭建服务</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (request.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createStream(<span class="string">&#x27;./cache.html&#x27;</span>); </span><br><span class="line">        readStream.pipe(response) </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.test(request.url)) &#123;  </span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;./script.js&#x27;</span>);</span><br><span class="line">        readStream.pipe(response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-强缓存"><a href="#4-强缓存" class="headerlink" title="4.强缓存"></a>4.强缓存</h2><h4 id="触发浏览器强缓存策略需要后端配置特殊字段Expires-Cache-Control均可，并且返回状态码200"><a href="#触发浏览器强缓存策略需要后端配置特殊字段Expires-Cache-Control均可，并且返回状态码200" class="headerlink" title="触发浏览器强缓存策略需要后端配置特殊字段Expires/Cache-Control均可，并且返回状态码200"></a>触发浏览器强缓存策略需要后端配置特殊字段Expires/Cache-Control均可，并且返回状态码200</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (request.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createStream(<span class="string">&#x27;./cache.html&#x27;</span>); </span><br><span class="line">        readStream.pipe(response) </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.test(request.url)) &#123;  </span><br><span class="line">        <span class="comment">// Expires字段设置的时间是固定的某个时间点</span></span><br><span class="line">        <span class="comment">// response.writeHead(200, &#123; </span></span><br><span class="line">        <span class="comment">//     &#x27;Expires&#x27;: new Date(&#x27;2020-12-30 12:00:00&#x27;),</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="comment">// Cache-Control字段设置的是相对于本次服务端返回的时间 单位s</span></span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">           <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=200&#x27;</span>   </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;./script.js&#x27;</span>);</span><br><span class="line">        readStream.pipe(response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一次访问资源命中强缓存之后，浏览器就不会同样的资源发起网络请求了，浏览器会直接强制从memory(内存)/disk(硬盘)中读取资源，如下所示<br><img src="/images/image.png"></p><h2 id="5-协商缓存"><a href="#5-协商缓存" class="headerlink" title="5.协商缓存"></a>5.协商缓存</h2><h4 id="触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified-Etag均可，并且返回状态码304"><a href="#触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified-Etag均可，并且返回状态码304" class="headerlink" title="触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified/Etag均可，并且返回状态码304"></a>触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified/Etag均可，并且返回状态码304</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (request.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createStream(<span class="string">&#x27;./cache.html&#x27;</span>);   </span><br><span class="line">        readStream.pipe(response) </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.test(request.url)) &#123;  </span><br><span class="line">        <span class="comment">// const buffer = fs.readFileSync(&#x27;./script.js&#x27;);</span></span><br><span class="line">        <span class="comment">// const fileMd5 = md5(buffer); 文件的md5值</span></span><br><span class="line">        <span class="comment">// const noneMatch = request.headers[&#x27;if-none-match&#x27;]; 来自浏览器端传递的值</span></span><br><span class="line">        <span class="comment">// 协商成功 状态码返回304</span></span><br><span class="line">        <span class="comment">// if (noneMatch === fileMd5) &#123;</span></span><br><span class="line">        <span class="comment">//     response.statusCode = 304;</span></span><br><span class="line">        <span class="comment">//     response.end();</span></span><br><span class="line">        <span class="comment">//     return;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 协商失败 状态码返回200</span></span><br><span class="line">        <span class="comment">// response.writeHead(200, &#123;</span></span><br><span class="line">        <span class="comment">//     &#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;,</span></span><br><span class="line">        <span class="comment">//     &#x27;ETag&#x27;: fileMd5,</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="keyword">const</span> stat = fs.statSync(<span class="string">&#x27;./script.js&#x27;</span>); </span><br><span class="line">        <span class="keyword">const</span> mtime = stat.mtime.toGMTString() </span><br><span class="line">        <span class="keyword">const</span> requestMtime = request.headers[<span class="string">&#x27;if-modified-since&#x27;</span>]; </span><br><span class="line">        <span class="comment">// 协商成功  本次服务端不返回资源  让浏览器使用缓存的资源</span></span><br><span class="line">        <span class="keyword">if</span> (mtime === requestMtime) &#123;</span><br><span class="line">            response.statusCode = <span class="number">304</span>; <span class="comment">//必须返回304</span></span><br><span class="line">            response.end();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 协商失败 状态码返回200</span></span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;Last-Modified&#x27;</span>: mtime,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>, <span class="comment">// 必须设置，否则下次浏览器请求会命中强缓存</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;./script.js&#x27;</span>);</span><br><span class="line">        readStream.pipe(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一次访问资源命中协商缓存之后，浏览器会在下次网络请求中用特殊字段(if-modified-since/if-no-match)携带第一次访问后端时返回的响应头信息，后端在对比前后数据之后，判断资源的内容是否更改，如果更改，就协商失败，返回最新的资源给浏览器，如果没有更改，就协商成功，不返回数据给浏览器，浏览器最终使用缓存的资源</p><h2 id="6-强缓存和协商缓存对比"><a href="#6-强缓存和协商缓存对比" class="headerlink" title="6.强缓存和协商缓存对比"></a>6.强缓存和协商缓存对比</h2><p>6.1 强缓存优先级比协商缓存高，因为浏览器总是倾向于请求更少的资源，命中强缓存后，浏览器都不会向后端请求资源了，所以强缓存优先级比协商缓存高<br>6.2 判断是否命中强缓存的纬度是时间，Expires是固定时间，Cache-Control是相对时间 ;<br>判断是否命中协商缓存的纬度是资源内容是否被更改，Last-Modified是用资源的修改时间，Etag是用资源的hash值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/17/hello-world/"/>
      <url>2020/11/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
