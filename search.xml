<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>自定义打包器</title>
      <link href="2021/02/06/minipack/"/>
      <url>2021/02/06/minipack/</url>
      
        <content type="html"><![CDATA[<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><img src="/images/strat.png" width='300px'><h2 id="createAsset-打包静态资源"><a href="#createAsset-打包静态资源" class="headerlink" title="createAsset 打包静态资源"></a>createAsset 打包静态资源</h2><p>使用<code>@babel/parser @babel/traverse @babel/core</code>这些模块打包静态资源，其中作用如下:</p><ol><li><code>@babel/parser</code>的作用是：将字符串转化成<code>ast</code>对象。</li><li><code>@babel/traverse</code>的作用是：在转换<code>ast</code>对象的过程中，遇到<code>import</code>就把<code>node.source.value</code>放到<code>dependencies</code>中去，<code>dependencies</code>是专门存放依赖模块的相对路径，<code>ImportDeclaration</code>是解析到<code>import</code>字段就会触发的钩子函数。</li><li><code>@babel/core</code>的作用是：将<code>ast</code>对象转换成可执行的 es5 代码。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> babelParser = <span class="built_in">require</span>(<span class="string">&quot;@babel/parser&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; transformFromAst &#125; = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&quot;@babel/traverse&quot;</span>).default;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAsset</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> content = fs.readFileSync(filename, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> ast = babelParser.parse(content, &#123;</span><br><span class="line">    sourceType: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> dependencies = [];</span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    <span class="comment">// 遍历所有的 import 模块，并将相对路径放入 dependencies</span></span><br><span class="line">    ImportDeclaration: <span class="function">(<span class="params">&#123; node &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      dependencies.push(node.source.value);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> &#123; code &#125; = transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">    presets: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    code,</span><br><span class="line">    dependencies,</span><br><span class="line">    filename,</span><br><span class="line">    id: id++,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="createGraph-构建依赖图"><a href="#createGraph-构建依赖图" class="headerlink" title="createGraph 构建依赖图"></a>createGraph 构建依赖图</h2><p>先打包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&quot;./minipack.config&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> entry = config.entry;</span><br><span class="line"><span class="keyword">const</span> mainAsset = createAsset(entry);</span><br><span class="line"><span class="keyword">const</span> graph = &#123;</span><br><span class="line">  [entry]: mainAsset,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGraph</span>(<span class="params">filename, asset</span>) </span>&#123;</span><br><span class="line">  asset.mapping = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> dirname = path.dirname(filename);</span><br><span class="line">  asset.dependencies.forEach(<span class="function">(<span class="params">relativePath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> absolutePath = path.resolve(dirname, relativePath);</span><br><span class="line">    asset.mapping[relativePath] = absolutePath;</span><br><span class="line">    <span class="keyword">if</span> (!graph[absolutePath]) &#123;</span><br><span class="line">      <span class="keyword">const</span> child = createAsset(absolutePath);</span><br><span class="line">      graph[absolutePath] = child;</span><br><span class="line">      <span class="keyword">if</span> (child.dependencies.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        createGraph(absolutePath, child);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">createGraph(entry, mainAsset);</span><br></pre></td></tr></table></figure><h2 id="bundle-打包"><a href="#bundle-打包" class="headerlink" title="bundle 打包"></a>bundle 打包</h2><p>获得依赖图之后，就可以基于依赖图打包成一个独立的文件了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">graph</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> modules = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> filename <span class="keyword">in</span> graph) &#123;</span><br><span class="line">    <span class="keyword">let</span> mod = graph[filename];</span><br><span class="line">    modules += <span class="string">`&#x27;<span class="subst">$&#123;filename&#125;</span>&#x27;: [</span></span><br><span class="line"><span class="string">      function(require, module, exports) &#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;mod.code&#125;</span></span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(mod.mapping)&#125;</span>,</span></span><br><span class="line"><span class="string">    ],`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="string">`</span></span><br><span class="line"><span class="string">  (function(modules) &#123;</span></span><br><span class="line"><span class="string">    function require(moduleId) &#123;</span></span><br><span class="line"><span class="string">      const [fn, mapping] = modules[moduleId]</span></span><br><span class="line"><span class="string">      function localRequire(name) &#123;</span></span><br><span class="line"><span class="string">        return require(mapping[name])</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      const module = &#123;exports: &#123;&#125;&#125;</span></span><br><span class="line"><span class="string">      fn(localRequire, module, module.exports)</span></span><br><span class="line"><span class="string">      return module.exports</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    require(&#x27;<span class="subst">$&#123;entry&#125;</span>&#x27;)</span></span><br><span class="line"><span class="string">  &#125;)(&#123;<span class="subst">$&#123;modules&#125;</span>&#125;)</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = bundle(graph);</span><br><span class="line"><span class="keyword">const</span> dist = path.join(output.path, output.filename);</span><br><span class="line">fs.writeFile(dist, result, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;文件已经被打包&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue.config.js的常用配置</title>
      <link href="2021/01/11/vue-config-js/"/>
      <url>2021/01/11/vue-config-js/</url>
      
        <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> CompressionWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;compression-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isProduction = process.env.NODE_ENV === <span class="string">&quot;production&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  productionSourceMap: isProduction ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 定义文件夹的路径</span></span><br><span class="line">    config.resolve.alias</span><br><span class="line">        .set(<span class="string">&#x27;@&#x27;</span>, resolve(<span class="string">&#x27;src&#x27;</span>))</span><br><span class="line">        .set(<span class="string">&#x27;@assets&#x27;</span>, resolve(<span class="string">&#x27;src/assets&#x27;</span>))</span><br><span class="line">        .set(<span class="string">&#x27;@components&#x27;</span>, resolve(<span class="string">&#x27;src/components&#x27;</span>))</span><br><span class="line">        .set(<span class="string">&#x27;@router&#x27;</span>, resolve(<span class="string">&#x27;src/router&#x27;</span>))</span><br><span class="line">        .set(<span class="string">&#x27;@store&#x27;</span>, resolve(<span class="string">&#x27;src/store&#x27;</span>))</span><br><span class="line">        .set(<span class="string">&#x27;@views&#x27;</span>, resolve(<span class="string">&#x27;src/views&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩图片 小于limit压缩成base64</span></span><br><span class="line">    <span class="keyword">const</span> imagesRule = config.module.rule(<span class="string">&#x27;images&#x27;</span>)</span><br><span class="line">    imagesRule.uses.clear()</span><br><span class="line">    imagesRule.use(<span class="string">&#x27;file-loader&#x27;</span>)</span><br><span class="line">        .loader(<span class="string">&#x27;url-loader&#x27;</span>)</span><br><span class="line">        .options(&#123;</span><br><span class="line">            limit: <span class="number">1024</span>,</span><br><span class="line">            fallback: &#123;</span><br><span class="line">                loader: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// webpack的配置</span></span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第三方模块不放到打包文件</span></span><br><span class="line">    config.externals = &#123;</span><br><span class="line">        jquery: <span class="string">&quot;jQuery&quot;</span>,</span><br><span class="line">        axios: <span class="string">&#x27;axios&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生产环境配置</span></span><br><span class="line">    <span class="keyword">if</span> (isProduction) &#123;</span><br><span class="line">      <span class="comment">// 线上去除console等信息</span></span><br><span class="line">      config.optimization.minimizer[<span class="number">0</span>].options.terserOptions.compress.drop_console = <span class="literal">true</span>;</span><br><span class="line">      config.optimization.minimizer[<span class="number">0</span>].options.terserOptions.compress.drop_debugger = <span class="literal">true</span>;</span><br><span class="line">      config.optimization.minimizer[<span class="number">0</span>].options.terserOptions.compress.pure_funcs = [</span><br><span class="line">          <span class="string">&quot;console.log&quot;</span></span><br><span class="line">      ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启gzip压缩</span></span><br><span class="line">    <span class="keyword">const</span> productionGzipExtensions = <span class="regexp">/\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i</span>;</span><br><span class="line">    config.plugins.push(</span><br><span class="line">      <span class="keyword">new</span> CompressionWebpackPlugin(&#123;</span><br><span class="line">        filename: <span class="string">&quot;[path].gz[query]&quot;</span>,</span><br><span class="line">        algorithm: <span class="string">&quot;gzip&quot;</span>,</span><br><span class="line">        test: productionGzipExtensions,</span><br><span class="line">        threshold: <span class="number">10240</span>,</span><br><span class="line">        minRatio: <span class="number">0.8</span></span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  全局引入less 变量  函数</span></span><br><span class="line">  pluginOptions: &#123;</span><br><span class="line">    <span class="string">&quot;style-resources-loader&quot;</span>: &#123;</span><br><span class="line">        preProcessor: <span class="string">&quot;less&quot;</span>,</span><br><span class="line">        patterns: [</span><br><span class="line">          path.resolve(__dirname, <span class="string">&quot;src/style/_variables.less&quot;</span>),</span><br><span class="line">          path.resolve(__dirname, <span class="string">&quot;src/style/_mixin.less&quot;</span>)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 需要gzip压缩的文件</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    host: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    port: <span class="number">8080</span>, <span class="comment">// 端口号</span></span><br><span class="line">    open: <span class="literal">false</span>, <span class="comment">// 配置自动启动浏览器</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义脚手架</title>
      <link href="2021/01/10/cli/"/>
      <url>2021/01/10/cli/</url>
      
        <content type="html"><![CDATA[<p>随着前端工程化的发展，前端领域出现了很多脚手架工具，例如<code>vue-cli</code>，<code>create-react-app</code>， <code>create-vite-app</code>等。这类脚手架工具可以帮我们快速搭建项目的初始结构，减少人肉操作，之前我们都是使用别人写的脚手架工具，今天我们就制作自己的脚手架工具。</p><h2 id="commander"><a href="#commander" class="headerlink" title="commander"></a>commander</h2><p>commander是<code>npm</code>上非常流程的自定义命令行工具包，我们可以通过这个包在终端上输入自己创建的指令来控制程序的执行。<code>vue-cli</code>，<code>create-react-app</code>， <code>create-vite-app</code>这些脚手架工具也是使用了<code>commander</code>,<a href="https://github.com/tj/commander.js">https://github.com/tj/commander.js</a> 这个地址里有<code>commander</code>的详细用法，本篇文章就不详细介绍了。除了<code>commander</code>之外，我们还需要<code>download-git-repo</code>，<code>ejs</code>，<code>chalk</code>这些第三方模块。初始的项目模版如下：</p><img src="/images/init.png"><p>对于<code>vue-cli</code>，这类脚手架，我们会通过<code>vue -V</code>来用脚手架的版本，同样的，对于我们的脚手架也需要配置一个指令来查看版本，所以我们在<code>pageage.json</code>中配置<code>heaven</code>这个bin指令，其作用就是可以在终端中全局使用<code>heaven</code>指令。当然只是在<code>pageage.json</code>中配置还不够。还需要通过<code>npm link</code>把 <code>heaven</code>指令放到<code>/usr/local/bin  </code>中。效果如下，至于<code>heaven -V</code>如何查看版本，这个就需要借助<code>commander</code>了。</p><img src="/images/link.png"><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><p>在<code>index.js</code>中引入了自定义模块<code>createCommands</code>，该模块存放了我们创建的指令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; createCommands &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./lib/core/create&#x27;</span>)</span><br><span class="line"><span class="comment">// 定义版本</span></span><br><span class="line">program.version(<span class="built_in">require</span>(<span class="string">&#x27;./package.json&#x27;</span>).version);</span><br><span class="line"><span class="comment">// 自定义指令</span></span><br><span class="line">createCommands()</span><br><span class="line"><span class="comment">// 解析指令</span></span><br><span class="line">program.parse(process.argv);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建指令"><a href="#创建指令" class="headerlink" title="创建指令"></a>创建指令</h2><p>在<code>createCommands.js</code>这个模块中，我们创建了三个指令：</p><ol><li><code>heaven create 项目名</code>，一旦执行该指令就会触发<code>createProject</code>回调</li><li><code>heaven addC 组件名</code>，一旦执行该指令就会触发<code>createComponent</code>回调</li><li><code>heaven addP 页面名</code>，一旦执行该指令就会触发<code>createPage</code>回调</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createCommands.js</span></span><br><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; createProject, createComponent, createPage &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./actions&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCommands</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    program</span><br><span class="line">        .command(<span class="string">&#x27;create &lt;project&gt;&#x27;</span>)</span><br><span class="line">        .description(<span class="string">&#x27;clone clone a repository into a newly created directory&#x27;</span>)</span><br><span class="line">        .action(createProject)</span><br><span class="line"></span><br><span class="line">    program</span><br><span class="line">        .command(<span class="string">&#x27;addC &lt;name&gt;&#x27;</span>)</span><br><span class="line">        .description(<span class="string">&#x27;create a component&#x27;</span>)</span><br><span class="line">        .action(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">            createComponent(name, name.toLowerCase())</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    program</span><br><span class="line">        .command(<span class="string">&#x27;addP &lt;name&gt;&#x27;</span>)</span><br><span class="line">        .description(<span class="string">&#x27;create a page&#x27;</span>)</span><br><span class="line">        .action(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">            createPage(name, name.toLowerCase())</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    createCommands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createProject"><a href="#createProject" class="headerlink" title="createProject"></a>createProject</h3><p>其实<code>heaven create 项目名</code>这个指令就是模拟<code>vue create 项目名</code>这个指令，当我们执行<code>vue create 项目名</code>时，需要等好久，其实这些等待的时间就是在下载脚手架的初始模版，所以同样的<code>heaven create 项目名</code>这个指令，也需要下载初始模版。理解了这个，再看<code>createProject</code>内部的逻辑就很清晰了：</p><ol><li>定义下载等待时的提示信息</li><li>下载初始模版，这时需要用<code>download-git-repo</code>来下载，我的项目模版放在了<code>https://github.com/840979094/vue-temp.git</code></li><li>执行<code>npm install</code>，该指令的作用是下载好项目模版后，直接安装项目依赖</li><li>执行<code>npm run serve</code>，该指令的作用是安装好项目依赖后，直接运行项目</li></ol><p>值得注意的是，<code>npm install</code>，<code>npm run serve</code>这俩指令都是运行在<code>node</code>的内置核心模块<code>child_process</code>单独开辟的子进程中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> downloadRepo = promisify(<span class="built_in">require</span>(<span class="string">&#x27;download-git-repo&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> &#123; hint &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../utils/log&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> terminal = <span class="built_in">require</span>(<span class="string">&#x27;../utils/terminal&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ejsComplier, mkdirSync, writeFile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../utils/file&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; remoteRepo &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../utils/constants&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">createProject</span>(<span class="params">project</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.下载提示</span></span><br><span class="line">    hint(<span class="string">&#x27;heaven_cli helps you create your project, please wait a moment~~~&#x27;</span>)</span><br><span class="line">    <span class="comment">// 2.clone远程仓库的代码</span></span><br><span class="line">    <span class="keyword">await</span> downloadRepo(remoteRepo, project, &#123; <span class="attr">clone</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="comment">// 3.执行终端命令npm install</span></span><br><span class="line">    <span class="keyword">const</span> npm = process.platform === <span class="string">&#x27;win32&#x27;</span> ? <span class="string">&#x27;npm.cmd&#x27;</span> : <span class="string">&#x27;npm&#x27;</span>;</span><br><span class="line">    <span class="keyword">await</span> terminal.spawn(npm, [<span class="string">&#x27;install&#x27;</span>], &#123; <span class="attr">cwd</span>: <span class="string">`./<span class="subst">$&#123;project&#125;</span>`</span> &#125;);</span><br><span class="line">    <span class="comment">// 4.运行项目</span></span><br><span class="line">    <span class="keyword">await</span> terminal.spawn(npm, [<span class="string">&#x27;run&#x27;</span>, <span class="string">&#x27;serve&#x27;</span>], &#123; <span class="attr">cwd</span>: <span class="string">`./<span class="subst">$&#123;project&#125;</span>`</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// utils/log.js</span></span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.blue(...arguments))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.red(...arguments))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// utils/terminal.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> spawnCommand = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> childProcess = spawn(...args);</span><br><span class="line">        childProcess.stdout.pipe(process.stdout);</span><br><span class="line">        childProcess.stderr.pipe(process.stderr);</span><br><span class="line">        childProcess.on(<span class="string">&#x27;close&#x27;</span>, resovle)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// utils/constant.js 项目模版地址</span></span><br><span class="line"><span class="keyword">const</span> remoteRepo = <span class="string">&quot;direct:https://github.com/840979094/vue-temp.git&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="createComponent"><a href="#createComponent" class="headerlink" title="createComponent"></a>createComponent</h3><p>一般情况下，在创建组件时，我们会有两个手动操作：</p><ol><li>新建组件文件夹</li><li>新建组件对应的单文件组件<br>而<code>heaven addC 组件名</code>这个指令就能够自动执行这两步操作，假定终端执行<code>heaven addC helloworld</code>指令，我们来看看<code>createComponent</code>内部的逻辑：</li><li>创建<code>src/components/helloworld</code>文件夹</li><li>使用<code>ejs</code>来编译<code>component.ejs</code>模版，并注入变量</li><li>将编译好的结果，写入到<code>src/components/helloworld/helloworld.vue</code>中<br>这样，当我们执行<code>heaven addC helloworld</code>，就会自动创建组件文件夹&amp;单文件组件了。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建组件</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>(<span class="params">name, dest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dirname = resolve(process.cwd(), <span class="string">&quot;src/components&quot;</span>, dest)</span><br><span class="line">    mkdirSync(dirname)</span><br><span class="line">    <span class="keyword">const</span> templatePath = resolve(__dirname, <span class="string">&#x27;../template/component.ejs&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> ejsComplier(templatePath, &#123; name &#125;)</span><br><span class="line">    writeFile(resolve(dirname, <span class="string">`<span class="subst">$&#123;name&#125;</span>.vue`</span>), result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file.js</span></span><br><span class="line"><span class="keyword">const</span> ejsComplier = <span class="function"><span class="keyword">function</span> (<span class="params">path, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        ejs.renderFile(path, data, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">            err ? reject(err) : resolve(result)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mkdirSync = <span class="function">(<span class="params">dirname</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fs.existsSync(dirname)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在,判断父亲文件夹是否存在？</span></span><br><span class="line">        <span class="keyword">if</span> (mkdirSync(path.dirname(dirname))) &#123;</span><br><span class="line">            <span class="comment">//父级文件夹存在 那就创建子文件夹</span></span><br><span class="line">            fs.mkdirSync(dirname)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用到的<code>component.ejs</code>模版如下，我们这里用的是<code>ts</code>模版，当然你也可以使用<code>js</code>模版。</p><img src="/images/template.png" ><h3 id="createPage"><a href="#createPage" class="headerlink" title="createPage"></a>createPage</h3><p>一般情况下，在创建页面时，我们会有三个手动操作：</p><ol><li>新建页面文件夹</li><li>新建页面对应的单文件组件</li><li>在<code>router.js</code>中把创建的页面添加到路由配置表中<br>而<code>heaven addP 页面名</code>这个指令就能够自动执行这三步操作，假定终端执行<code>heaven addP home</code>指令，我们来看看<code>createPage</code>内部的逻辑：</li><li>创建<code>src/pages/home</code>文件夹</li><li>使用<code>ejs</code>来编译<code>component.ejs</code>模版，并注入变量</li><li>将编译好的结果，写入到<code>src/page/home/home.vue</code>中</li><li>使用<code>ejs</code>来编译<code>router.ejs</code>模版，并注入变量</li><li>将编译好的结果，写入到<code>src/router/home.js</code>中</li></ol><p>这样，当我们执行<code>heaven addP home</code>，就会自动创建页面文件夹&amp;单文件组件，并且把创建的页面自动添加到路由配置表中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">createPage</span>(<span class="params">name, dest</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建页面对应的文件夹和单文件组件</span></span><br><span class="line">    <span class="keyword">const</span> pageDirname = resolve(process.cwd(), <span class="string">&quot;src/pages&quot;</span>, dest)</span><br><span class="line">    mkdirSync(pageDirname)</span><br><span class="line">    <span class="keyword">const</span> pagePath = resolve(__dirname, <span class="string">&#x27;../template/component.ejs&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> pageResult = <span class="keyword">await</span> ejsComplier(pagePath, &#123; name &#125;)</span><br><span class="line">    writeFile(resolve(pageDirname, <span class="string">`<span class="subst">$&#123;name&#125;</span>.vue`</span>), pageResult)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把创建的页面 自动添加到路由表中</span></span><br><span class="line">    <span class="keyword">const</span> routerDirname = resolve(process.cwd(), <span class="string">&quot;src/router&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> routerPath = resolve(__dirname, <span class="string">&#x27;../template/router.ejs&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> routerResult = <span class="keyword">await</span> ejsComplier(routerPath, &#123; name &#125;)</span><br><span class="line">    writeFile(resolve(routerDirname, <span class="string">`<span class="subst">$&#123;name&#125;</span>.js`</span>), routerResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用到的<code>router.ejs</code>模版如下:</p><img src="/images/router.png" ><h2 id="发布到npm"><a href="#发布到npm" class="headerlink" title="发布到npm"></a>发布到npm</h2><p>这样，其实我们的脚手架基本就可以工作了，接着我们把脚手架发布到<code>npm</code>上，这样谁都可以下载这个脚手架了。</p><ol><li><a href="https://www.npmjs.com/login">https://www.npmjs.com/login</a> 注册<code>npm</code>账号</li><li>终端输入<code>npm login</code>登录npm账号</li><li>终端输入<code>npm publish</code>发布</li></ol><p>结果如下所示：</p><img src="/images/publish.png"><h2 id="项目模版结构"><a href="#项目模版结构" class="headerlink" title="项目模版结构"></a>项目模版结构</h2><p>如果发布到<code>npm</code>成功，就可以<code>npm i heaven_cli -g</code>让同事下载你的脚手架了。当然这个脚手架使用的项目模版放在了<code>https://github.com/840979094/vue-temp.git</code>，我们再看看这个模版的结构，其中模版的路由配置代码如下:</p><ol><li>初始路由配置表<code>routes</code>为空</li><li><code>require.context</code>递归读取<code>router</code>目录下所有的<code>js/ts</code>文件，加载对应的模块并添加到<code>routes</code>中，之所以要把路由分模块管理，是因为随着项目变得越来也大，如果不分模块管理，<code>routes</code>会非常臃肿，不利于项目当维护。<code>require.context</code>的具体用法见<a href="https://cn.vuejs.org/v2/guide/components-registration.html#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C">https://cn.vuejs.org/v2/guide/components-registration.html#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C</a></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter, &#123; RouteConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./home&#x27;</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> routes: RouteConfig[] = []</span><br><span class="line"><span class="comment">// 自动注入路由记录到routes中</span></span><br><span class="line"><span class="keyword">const</span> requireCxt = <span class="built_in">require</span>.context(<span class="string">&quot;./&quot;</span>, <span class="literal">true</span>, <span class="regexp">/.(js|ts)$/</span>)</span><br><span class="line"></span><br><span class="line">requireCxt.keys().forEach(<span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是./index 那就处理</span></span><br><span class="line">    <span class="keyword">if</span> (filename.indexOf(<span class="string">&quot;./index&quot;</span>) !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> routesModule = requireCxt(filename)</span><br><span class="line">        routes = [routesModule.default, ...routes]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    base: process.env.BASE_URL,</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios在脚手架中的使用</title>
      <link href="2021/01/08/axios/"/>
      <url>2021/01/08/axios/</url>
      
        <content type="html"><![CDATA[<p>axios是基于<code>ajax</code>封装的<code>promise</code>式请求库，在脚手架中通常会使用<code>axios</code>作为<code>http</code>请求库。通常可以使用以下功能。</p><ol><li>拦截请求和响应</li><li>自动刷新<code>token</code></li><li>取消请求</li></ol><h3 id="拦截请求和响应"><a href="#拦截请求和响应" class="headerlink" title="拦截请求和响应"></a>拦截请求和响应</h3><p>一般会在请求拦截器中添加loading动画，在响应拦截器中隐藏loading动画和跳转错误页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    Toast.loading(<span class="string">&#x27;加载中...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.interceptors.response.use(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    Toast.hide()</span><br><span class="line">    <span class="keyword">return</span> response.data</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    my.redirectTo(&#123; <span class="attr">url</span>: <span class="string">&#x27;/pages/error/error&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="自动刷新token"><a href="#自动刷新token" class="headerlink" title="自动刷新token"></a>自动刷新<code>token</code></h3><p>一般情况下会请求<code>token</code>来记录用户的登录状态，但是<code>token</code>会有过期时间，这时候我们可以在响应拦截器中。</p><ol><li>判断<code>token</code>是否过期了（一般后端会返回过期的状态码，假定返回的状态码是<code>ret_code=5007</code>）。</li><li>如果<code>token</code>过期了，再次调用请求<code>token</code>的接口即可，请求<code>token</code>后再次调用<code>axios</code>请求业务接口的数据<br>值得注意的是，因为<code>response.config</code>记录着请求的<code>config</code>，所以再次调用<code>axios</code>时传递的<code>url data params method</code>都是业务接口对应的参数。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ret_code 5007 token超时</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ret_code &#125; = response.data</span><br><span class="line">    <span class="keyword">if</span> (ret_code === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response.data</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( ret_code === <span class="number">5007</span> ) &#123;</span><br><span class="line">        <span class="comment">//  token超时那就获取token  之后再调用业务接口</span></span><br><span class="line">        <span class="keyword">return</span> getToken().then(<span class="function"><span class="params">_</span> =&gt;</span> axios(&#123; </span><br><span class="line">            url:response.config.url ,</span><br><span class="line">            method: response.config.method,</span><br><span class="line">            data: response.config.data ,</span><br><span class="line">            params: response.config.params,</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125; </span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h3><p>我们经常会遇到下面的情况，在<code>user</code>页面会请求很多接口，此时请求还在<code>pengding</code>状态，如果这时候我们再次切换<code>home</code>页面，势必会请求新的接口，但是<code>user</code>页面还在<code>pengding</code>状态的接口势必还会继续请求，因为我们没有取消这些请求。理想状态下，我们在切换<code>home</code>页面时，应该要取消<code>user</code>页面还在<code>pengding</code>状态的接口，这样可以减少服务器的压力，也可以释放浏览器网络线程的资源。</p><img src="/images/cancelToken.png"  width='500px'><p>取消请求的流程如下:</p><ol><li>在请求拦截器中创建请求的<code>cancel</code>函数，并存储到<code>config</code>和<code>cancelTokens</code>中</li><li>因为在用户切换<code>home</code>页面时，有些接口可能已经有返回了，所以在响应拦截器中要找到已经返回接口对应的<code>cancel</code>函数，并从```cancelTokens``删除，</li><li>在用户切换<code>home</code>页面时，在前置钩子<code>beforeEach</code>中，执行<code>cancelTokens</code>里所有的<code>cancel</code>函数执行，就可以取消所有还在<code>pending</code>状态的接口。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">let</span> cancel = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> cancelTokens = []</span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.cancelToken = <span class="keyword">new</span> CancelToken(<span class="function"><span class="params">c</span> =&gt;</span> cancel = c)</span><br><span class="line">    config.cancel = cancel</span><br><span class="line">    cancelTokens.push(cancel)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = cancelTokens.indexOf(response.config.cancel)</span><br><span class="line">    cancelTokens.splice(index, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> response.data</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="comment">// 用户取消</span></span><br><span class="line">    <span class="keyword">if</span> (axios.isCancel(err)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123; &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 请求错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空cancelTokens</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (cancelTokens.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> currentCancel = cancelTokens.pop()</span><br><span class="line">        currentCancel()</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述代码实现的效果如下：</p><p><video src="/images/cancel.mp4"></video></p><h3 id="优化try-catch"><a href="#优化try-catch" class="headerlink" title="优化try/catch"></a>优化try/catch</h3><p>这一点其实和<code>axios</code>本身没有关系，只是对 <code>async</code>函数写法的优化。</p><ol><li>一般情况下<code>async</code>函数内部是无法捕获失败的<code>promise</code>,如果<code>await</code>后面是个失败的<code>promise</code>，就会阻塞<code>await</code>下面代码的执行，见场景1。</li><li>在<code>await</code>后面的<code>promise</code>包一层<code>try/catch</code>,这样失败的<code>promise</code>就会被<code>catch</code>捕获，这样就不会影响下面代码的执行了，见场景2，这样虽然可以解决问题，但是却多了一层代码嵌套，让代码看上去不是很优雅。</li><li>定义工具函数<code>promiseWrapper</code>，并且接受一个<code>promise</code>作为参数，，<code>promiseWrapper</code>函数返回一个<code>promise</code>，其状态总是成功的。其值根据传入<code>promise</code>的状态决定。原则上和<code>node</code>一致，都是错误优先原则。<br>所以以后我们可以把接口都用<code>promiseWrapper</code>包裹，这样就避免了使用<code>try/catch</code>，使得代码更优雅。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景1 无法捕获错误 会影响下面代码的执行</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">case1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="number">111</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景2 catch可以捕获错误 不会影响下面代码的执行</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">case2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="number">1</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景3 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseWrapper</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p.then(<span class="function"><span class="params">res</span> =&gt;</span> [<span class="literal">undefined</span>, res])</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> [err, <span class="literal">undefined</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">case3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [err, res] = <span class="keyword">await</span> promiseWrapper(<span class="built_in">Promise</span>.reject(<span class="number">1</span>))</span><br><span class="line">  <span class="built_in">console</span>.log(err, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试题</title>
      <link href="2020/12/28/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/12/28/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="JS手写篇"><a href="#JS手写篇" class="headerlink" title="JS手写篇"></a>JS手写篇</h2><h3 id="call、apply、bind-实现"><a href="#call、apply、bind-实现" class="headerlink" title="call、apply、bind 实现"></a>call、apply、bind 实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">obj, ...args</span>) </span>&#123;</span><br><span class="line">  obj.__proto__.fn = <span class="built_in">this</span></span><br><span class="line">  obj.fn(...args)</span><br><span class="line">  <span class="keyword">delete</span> obj.__proto__.fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">obj, args</span>) </span>&#123;</span><br><span class="line">  obj.__proto__.fn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(args)) &#123;</span><br><span class="line">    obj.fn(...args)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">`<span class="subst">$&#123;args&#125;</span> is not array`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> obj.__proto__.fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">obj, ...outerArgs</span>) </span>&#123;</span><br><span class="line">  obj.__proto__.fn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...innerArgs</span>) </span>&#123;</span><br><span class="line">    obj.fn(...outerArgs, ...innerArgs)</span><br><span class="line">    <span class="keyword">delete</span> obj.__proto__.fn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟new操作符"><a href="#模拟new操作符" class="headerlink" title="模拟new操作符"></a>模拟new操作符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">Fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(Fn.prototype)</span><br><span class="line">  Fn.call(obj, ...args)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现防抖和节流函数"><a href="#实现防抖和节流函数" class="headerlink" title="实现防抖和节流函数"></a>实现防抖和节流函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖:控制函数执行的频率，在规定时间内，只有最后一次触发有效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">250</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(fn.bind(<span class="built_in">this</span>, ...args), delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流:控制函数执行的频率，在规定时间内，只有第一次触发有效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay = <span class="number">250</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">if</span> (now - start &gt;= delay) &#123;</span><br><span class="line">      fn.call(<span class="built_in">this</span>, ...args)</span><br><span class="line">      start = now</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现instanceof"><a href="#实现instanceof" class="headerlink" title="实现instanceof"></a>实现instanceof</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceOf</span>(<span class="params">tem, Fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> tem !== <span class="string">&#x27;object&#x27;</span> || tem === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">while</span> (tem = tem.__proto__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tem === Fn.prototype) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Object-create"><a href="#实现Object-create" class="headerlink" title="实现Object.create"></a>实现Object.create</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.myCreate = <span class="function"><span class="keyword">function</span> (<span class="params">tem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">  obj.__proto__ = tem</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tem = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] !== <span class="string">&#x27;object&#x27;</span> || obj[key] === <span class="literal">null</span>) &#123;</span><br><span class="line">      tem[key] = obj[key]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tem[key] = <span class="built_in">arguments</span>.callee(obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tem</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;heaven&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> deepObj = deepClone(&#123;<span class="attr">name</span>:<span class="string">&#x27;heaven&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="数组高级方法实现"><a href="#数组高级方法实现" class="headerlink" title="数组高级方法实现"></a>数组高级方法实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFilter = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fn(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>)) &#123;</span><br><span class="line">      arr.push(<span class="built_in">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.myEvery = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fn(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.mySome = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fn(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待优化</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.myReduce = <span class="function"><span class="keyword">function</span> (<span class="params">fn, initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tem = [<span class="literal">null</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="string">&#x27;&#x27;</span>, <span class="literal">NaN</span>]</span><br><span class="line">  <span class="keyword">if</span> (initial || tem.includes(initial)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> res = fn(i === <span class="number">0</span> ? initial : res, <span class="built_in">this</span>[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> res = fn(i === <span class="number">1</span> ? <span class="built_in">this</span>[i - <span class="number">1</span>] : res, <span class="built_in">this</span>[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现promise"><a href="#实现promise" class="headerlink" title="实现promise"></a>实现promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">exectue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exectue !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="string">`<span class="subst">$&#123;exectue&#125;</span> is not a function`</span></span><br><span class="line">    <span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.tasks = []</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.result = res</span><br><span class="line">      queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> item = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">while</span> (item = <span class="built_in">this</span>.tasks.shift()) item.res()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.result = err</span><br><span class="line">      queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> item = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">while</span> (item = <span class="built_in">this</span>.tasks.shift()) item.rej()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    exectue(resolve.bind(<span class="built_in">this</span>), reject.bind(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">resCb, rejCb</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.tasks.push(&#123;</span><br><span class="line">        res () &#123; resCb &amp;&amp; handle(resCb) &#125;,</span><br><span class="line">        rej () &#123; rejCb &amp;&amp; handle(rejCb) &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// then返回的promise状态 只由回调函数的返回值决定</span></span><br><span class="line">      <span class="keyword">let</span> handle = <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = callback(<span class="built_in">this</span>.result)</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          result.then(res, rej)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          res(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">catch</span>(<span class="params">rejCb</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, rejCb)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">finally</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(cb, cb)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回最先有结果的promise 失败/成功都可以</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      promises.forEach(<span class="function"><span class="params">p</span> =&gt;</span> p.then(resolve, reject))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回最先成功的promise </span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">any</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      promises.forEach(<span class="function"><span class="params">p</span> =&gt;</span> p.then(resolve, <span class="literal">undefined</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有都成功 才返回成功的promise 一个失败就返回失败的promise  写法待优化</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      promises.forEach(<span class="function">(<span class="params">p, index</span>) =&gt;</span> &#123;</span><br><span class="line">        p.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          arr[index] = res</span><br><span class="line">          <span class="keyword">if</span> (++idx === promises.length) resolve(arr)</span><br><span class="line">        &#125;, reject)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必然返回成功的promise  写法待优化</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">allSettled</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      promises.forEach(<span class="function">(<span class="params">p, index</span>) =&gt;</span> &#123;</span><br><span class="line">        p.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          arr[index] = &#123;</span><br><span class="line">            status: p.status,</span><br><span class="line">            value: res</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (++idx === promises.length)  resolve(arr)</span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          arr[index] = &#123;</span><br><span class="line">            status: p.status,</span><br><span class="line">            reason: err</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (++idx === promises.length)  resolve(arr)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现async-await"><a href="#实现async-await" class="headerlink" title="实现async/await"></a>实现async/await</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAsync</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> gen = generator();</span><br><span class="line">  <span class="keyword">const</span> handle = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; value, done &#125; = res</span><br><span class="line">    <span class="comment">// generator函数结束 需要包装成promise</span></span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value)</span><br><span class="line">    value = value <span class="keyword">instanceof</span> <span class="built_in">Promise</span> ? value : <span class="built_in">Promise</span>.resolve(value)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">      .then(<span class="function"><span class="params">result</span> =&gt;</span> handle(gen.next(result)))</span><br><span class="line">      .catch(<span class="function"><span class="params">e</span> =&gt;</span> gen.throw(e));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> handle(gen.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(a + <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">const</span> d = <span class="keyword">yield</span> <span class="string">&#x27;2131232&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> c = <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(b + <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c, d); </span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;12312&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myAsync(test);</span><br></pre></td></tr></table></figure><h2 id="JS基础篇"><a href="#JS基础篇" class="headerlink" title="JS基础篇"></a>JS基础篇</h2><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>运算符优先级可参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;  <span class="comment">//a-&gt;地址1</span></span><br><span class="line"><span class="keyword">var</span> b = a     <span class="comment">//b-&gt;地址1</span></span><br><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;  <span class="comment">//地址1.x = a-&gt;地址2</span></span><br><span class="line"><span class="built_in">console</span>.log(a.x)    <span class="comment">//地址2.x</span></span><br></pre></td></tr></table></figure><p><code>var a = 1 + 2</code>该式中有<code>= +</code>两个运算符，运算结果为<code>3</code>，说明<code>+</code>的优先级高于<code>=</code><br><code>a.x = a = &#123; n: 2 &#125;</code>该式中有<code>. = =</code>三个运算符，其中<code>.</code>运算符优先级高于<code>=</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>); &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>); &#125;;</span><br><span class="line">foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">3</span>); &#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">4</span>); &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">5</span>); &#125;</span><br><span class="line"></span><br><span class="line">foo.getName();</span><br><span class="line">getName();</span><br><span class="line">foo().getName();</span><br><span class="line">getName();</span><br><span class="line"><span class="keyword">new</span> foo.getName();        </span><br><span class="line"><span class="keyword">new</span> foo().getName();    </span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> foo().getName();  </span><br></pre></td></tr></table></figure><h3 id="宏任务-amp-微任务"><a href="#宏任务-amp-微任务" class="headerlink" title="宏任务&amp;微任务"></a>宏任务&amp;微任务</h3><p>以下代码的输入顺序?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;回调1&#x27;</span>) </span><br><span class="line">    <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;回调2&#x27;</span>) </span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;then1&#x27;</span></span><br><span class="line">      &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;回调3&#x27;</span>) </span><br><span class="line">      &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;回调4&quot;</span>) </span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;then&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;回调5&quot;</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;回调6&quot;</span>)</span><br><span class="line">          <span class="built_in">Promise</span>.resolve()</span><br><span class="line">            .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;回调7&quot;</span>) </span><br><span class="line">            &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;回调8&quot;</span>) </span><br><span class="line">            &#125;)</span><br><span class="line">      &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;回调9&quot;</span>) </span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;回调10&quot;</span>) </span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;同步代码&#x27;</span>)  </span><br></pre></td></tr></table></figure><p>解析如下:<br><img src="/images/micro.png"></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vite实现原理</title>
      <link href="2020/12/25/vite%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>2020/12/25/vite%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="ESModule-的特点"><a href="#ESModule-的特点" class="headerlink" title="ESModule 的特点"></a>ESModule 的特点</h2><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>ESModule 是<code>js</code>在浏览器端的模块化规范，其实在该规范下，浏览器会自动向依赖的模块发起请求，代码如下：</p><ol><li><code>type=module</code>表示该脚本支持<code>ESModule</code>规范.</li><li>依赖两个模块<code>a,b</code>，因为脚本依赖这两个模块，所以浏览器必然会发送网络请求，如下图所示：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span> <span class="keyword">import</span> &#123;b&#125; <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><img src="/images/esmodule.png"><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>当然，除了会发送网络请求之外，<code>ESModule</code>还可以让某个模块异步加载(按需加载)，代码如下，具体如下图所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&#x27;btn&#x27;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./a.js&#x27;</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><video src="/images/require.mp4"></video></p><h2 id="vite-amp-create-vite-app"><a href="#vite-amp-create-vite-app" class="headerlink" title="vite &amp; create-vite-app"></a>vite &amp; create-vite-app</h2><p>尤大专门为<code>Vue3</code>配套了<code>vite</code>这个打包工具，如果要使用<code>vite</code>来创建项目，需要安装<code>create-vite-app</code>这个脚手架，如何使用这个脚手架创建项目，可以参考这个文章<a href="https://juejin.cn/post/6910014283707318279">https://juejin.cn/post/6910014283707318279</a> 里面有详细的步骤。通过脚手架创建的目录结构如下图：</p><img src="/images/project.png"><p>其中，<code>dev/build</code>指令是用<code>vite</code>做开发/生产环境的打包。<code>server</code>指令是我们自己配置的指令，如果通过该指令，可以对项目进行开发环境的打包，那我们的目标就实现了。当然这是后面要做的事情了，接下来先看看<code>index.html</code>和<code>main.js</code></p><h3 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h3><img src="/images/index.png"><p>可以看到在<code>index.html</code>中<code>script</code>脚本启动了<code>ESModule</code>模块化规范，入口文件是<code>main.js</code></p><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><img src="/images/main.png"><p>可以看到在<code>main.js</code>中，加载了三个模块，分别是<code>vue App.vue index.css</code>，所以浏览器必然会对这三个模块发起网络请求，接下来<code>vite</code>会怎么处理呢，这个就需要了解<code>vite</code>的实现原理了。</p><h2 id="vite-原理"><a href="#vite-原理" class="headerlink" title="vite 原理"></a>vite 原理</h2><p>其实<code>vite</code>的原理就是基于浏览器在加载模块时会发起网络请求来实现的，我们可以试着仿写下，大致流程如下：</p><ol><li>用<code>express</code>启动 web 服务器，我们的端口启动在 3006</li><li>后端拦截所有浏览器请求的模块，并返回加载的模块对应的资源，其中包括 index.html/main.js/第三方模块/单文件组件/css 文件</li><li>拦截首页，返回<code>index.html</code></li><li>在<code>index.html</code>中加载了<code>main.js</code>,所以我们也拦截该请求，值得注意的是，<code>vite</code>并不是原样返回<code>main.js</code>，而是会对<code>main.js</code>中的第三方模块例如<code>vue</code>加上 <code>/modules/</code>，所以我们也需要做<code>vite</code>类似的处理，<code>handleImport</code>就是这个作用。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="comment">// 拦截首页 返回index.html</span></span><br><span class="line">app.get(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pathname = resolve(__dirname, <span class="string">&quot;./index.html&quot;</span>);</span><br><span class="line">  fs.readFile(pathname, <span class="string">&quot;utf-8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 没有会报错，这个可以自行测试</span></span><br><span class="line">    data = data.replace(</span><br><span class="line">      <span class="string">&quot;&lt;script&quot;</span>,</span><br><span class="line">      <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;script&gt;</span></span><br><span class="line"><span class="string">          process = &#123;</span></span><br><span class="line"><span class="string">            env:&#123;&#125;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">      &lt;/script&gt;</span></span><br><span class="line"><span class="string">      &lt;script</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    );</span><br><span class="line">    res.send(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截首页 返回main.js</span></span><br><span class="line">app.get(<span class="regexp">/main.js/</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pathname = resolve(__dirname, <span class="string">`.<span class="subst">$&#123;req.url&#125;</span>`</span>);</span><br><span class="line">  res.header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-javascript&quot;</span>);</span><br><span class="line">  fs.readFile(pathname, <span class="string">&quot;utf-8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span>;</span><br><span class="line">    res.send(handleImport(data));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleImport</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/(from\s+[&#x27;&quot;])(?![\.\/])/g</span>;</span><br><span class="line">  <span class="keyword">return</span> source.replace(reg, <span class="function">(<span class="params">$<span class="number">0</span>, $<span class="number">1</span></span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;$<span class="number">1</span>&#125;</span>/@modules/`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拦截第三方模块"><a href="#拦截第三方模块" class="headerlink" title="拦截第三方模块"></a>拦截第三方模块</h3><p>因为<code>main.js</code>依赖了<code>vue</code>这个第三方模块，所以浏览器必然会发起网络请求，我们也拦截第三方模块，并返回第三方模块对应的资源。值得注意的是第三方模块需要从<code>node_modules</code>读取并返回。读取顺序如下，找到文件夹<code>vue</code>,<code>package.json</code>中的<code>module</code>字段对应的资源路径就是浏览器要加载的<code>vue</code>源码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析第三方模块</span></span><br><span class="line">app.get(<span class="regexp">/^\/@modules/</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// vue模块所在文件夹</span></span><br><span class="line">  <span class="keyword">const</span> prefix = resolve(</span><br><span class="line">    __dirname,</span><br><span class="line">    <span class="string">`./node_modules/`</span>,</span><br><span class="line">    req.url.replace(<span class="regexp">/\/@modules\//</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = <span class="built_in">require</span>(resolve(prefix, <span class="string">&quot;package.json&quot;</span>)).module;</span><br><span class="line">  <span class="comment">// 浏览器加载的vue源码</span></span><br><span class="line">  <span class="keyword">const</span> pathname = resolve(prefix, <span class="built_in">module</span>);</span><br><span class="line">  res.header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-javascript&quot;</span>);</span><br><span class="line">  fs.readFile(pathname, <span class="string">&quot;utf-8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span>;</span><br><span class="line">    res.send(handleImport(data));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="拦截单文件组件"><a href="#拦截单文件组件" class="headerlink" title="拦截单文件组件"></a>拦截单文件组件</h3><p>在<code>main.js</code>还依赖了<code>App.vue</code>这个单文件组件，所以浏览器必然会发起网络请求，我们也要拦截该模块，并返回对应的资源，值得注意的是，</p><ol><li>对于<code>App.vue</code>，<code>vite</code>会用<code>@vue/compiler-sfc</code>包来解析单文件组件并返回数据，返回数据再次依赖了<code>/src/App.vue?type=template</code>(见 if)</li><li>当浏览器处理返回的数据时，会再次发起网络请求<code>/src/App.vue?type=template</code>,所以我们还需要拦截这个请求(见 else)，再使用<code>@vue/compiler-dom</code>包来把组件的模版<code>template</code>转成<code>render</code>函数。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compilersfc = <span class="built_in">require</span>(<span class="string">&quot;@vue/compiler-sfc&quot;</span>); <span class="comment">// 解析单文件组件</span></span><br><span class="line"><span class="keyword">const</span> compilerDom = <span class="built_in">require</span>(<span class="string">&quot;@vue/compiler-dom&quot;</span>); <span class="comment">// template --&gt;render</span></span><br><span class="line"><span class="comment">// 解析单文件组件</span></span><br><span class="line">app.get(<span class="regexp">/\.vue/</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type &#125; = req.query;</span><br><span class="line">  <span class="keyword">const</span> url = req.url.split(<span class="string">&quot;?&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">  res.header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-javascript&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> pathname = resolve(__dirname, <span class="string">`.<span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">  fs.readFile(pathname, <span class="string">&quot;utf-8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 解析单文件组件</span></span><br><span class="line">    <span class="keyword">const</span> &#123; descriptor &#125; = compilersfc.parse(data);</span><br><span class="line">    <span class="keyword">if</span> (!type) &#123;</span><br><span class="line">      <span class="keyword">const</span> content = handleImport(</span><br><span class="line">        descriptor.script.content.replace(</span><br><span class="line">          <span class="string">&quot;export default &quot;</span>,</span><br><span class="line">          <span class="string">&quot;const __script = &quot;</span></span><br><span class="line">        )</span><br><span class="line">      );</span><br><span class="line">      res.send(<span class="string">`</span></span><br><span class="line"><span class="string">              <span class="subst">$&#123;content&#125;</span></span></span><br><span class="line"><span class="string">              import &#123;render as __render&#125; from &#x27;<span class="subst">$&#123;url&#125;</span>?type=template&#x27;</span></span><br><span class="line"><span class="string">              __script.render = __render</span></span><br><span class="line"><span class="string">              export default __script</span></span><br><span class="line"><span class="string">            `</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&quot;template&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; content &#125; = descriptor.template;</span><br><span class="line">      <span class="comment">// 编译template模版 转成render函数</span></span><br><span class="line">      <span class="keyword">const</span> render = compilerDom.compile(content, &#123; <span class="attr">mode</span>: <span class="string">&quot;module&quot;</span> &#125;).code;</span><br><span class="line">      res.send(handleImport(render));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="拦截-css-文件"><a href="#拦截-css-文件" class="headerlink" title="拦截 css 文件"></a>拦截 css 文件</h3><p>在<code>main.js</code>还依赖了<code>index.css</code>这个 css 文件，所以浏览器必然会发起网络请求，我们也要拦截该模块，并返回对应的资源,处理也比较简单，创建<code>style</code>标签即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="regexp">/\.css/</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pathname = resolve(__dirname, <span class="string">`.<span class="subst">$&#123;req.url&#125;</span>`</span>);</span><br><span class="line">  res.header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-javascript&quot;</span>);</span><br><span class="line">  fs.readFile(pathname, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span>;</span><br><span class="line">    res.send(<span class="string">`</span></span><br><span class="line"><span class="string">            let link = document.createElement(&#x27;style&#x27;)</span></span><br><span class="line"><span class="string">            link.innerHTML = &#x27;<span class="subst">$&#123;data.toString().replace(<span class="regexp">/\n/g</span>, <span class="string">&quot;&quot;</span>)&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">            link.setAttribute(&#x27;type&#x27;,&#x27;text/css&#x27;)</span></span><br><span class="line"><span class="string">            document.head.appendChild(link)</span></span><br><span class="line"><span class="string">        `</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至此，我们已经实现的<code>vite</code>已经可以处理第三方模块/单文件组件/css 文件了，基本上可以满足使用了，我们运行<code>server</code>指令的结果如下：</p><p><video src="/images/server.mp4"></video></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. Vue的组件系统</title>
      <link href="2020/12/20/vue07/"/>
      <url>2020/12/20/vue07/</url>
      
        <content type="html"><![CDATA[<p>之前我们讨论的模版都是没有使用组件的，不过我们在开发中，经常会在模版中使用组件的，接下来我们看看在模版中使用组件，Vue内部是如何处理的？<br>假定模版如下所示：在模版中使用了全局组件<code>global-component</code>，局部组件<code>local-component</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">global-component</span>&gt;</span><span class="tag">&lt;/<span class="name">global-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">local-component</span>&gt;</span><span class="tag">&lt;/<span class="name">local-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> Vue.component(<span class="string">&#x27;global-component&#x27;</span>, &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count: <span class="number">0</span>,</span><br><span class="line">            msg: <span class="string">&quot;全局组件&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;&#123;&#123;msg&#125;&#125;count:&#123;&#123; count &#125;&#125;&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LocalComponent = &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count: <span class="number">0</span>,</span><br><span class="line">            msg: <span class="string">&quot;局部组件&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;&#123;&#123;msg&#125;&#125;count:&#123;&#123; count &#125;&#125;&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译组件"><a href="#编译组件" class="headerlink" title="编译组件"></a>编译组件</h2><p>在模版中里引入了两个组件之后，Vue内部依旧会走模版转render函数的流程，如下所示，下面三张图分别对应：</p><ol><li>模版转成AST树</li><li>AST树转可执行代码</li><li>可执行代码转render函数</li></ol><p>其实，不管在模版里面有没有组件，转成render函数的流程都是一样的。如果模版里面有组件的话，也会把组件当作普通的html标签处理。</p><img src="/images/component.png"><img src="/images/comcode.png"><img src="/images/comrender.png"><h2 id="挂载组件"><a href="#挂载组件" class="headerlink" title="挂载组件"></a>挂载组件</h2><p>当把模版转成render函数之后，依旧会执行<code>mountComponent</code>函数走挂载组件的流程，接着是创建渲染watcher，并且触发<code>渲染watcher</code>的求值函数<code>updateComponent</code>，updateComponent的逻辑如下：</p><ol><li><code>vm._render()</code>创建虚拟dom，并收集依赖</li><li><code>vm._update()</code>基于虚拟dom创建真实dom</li></ol><h3 id="区分原生标签-组件"><a href="#区分原生标签-组件" class="headerlink" title="区分原生标签/组件"></a>区分原生标签/组件</h3><p>对于上面的<code>render</code>函数，会使用<code>_c(&#39;global-component&#39;)</code>来创建组件的虚拟dom，我们看看Vue内部是如何创建组件的虚拟dom？<br>可以看到，在<code>_createElement</code>内部分别处理了原生html标签和自定义组件，其中使用<code>new VNode()</code>创建html标签的虚拟dom，使用<code>createComponent</code>创建组件的虚拟dom。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createElement</span>(<span class="params">context,tag,data,children,normalizationType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">      children = normalizeChildren(children);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">      children = simpleNormalizeChildren(children);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> vnode;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> Ctor;</span><br><span class="line">        <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">            <span class="comment">// platform built-in elements</span></span><br><span class="line">            vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">            config.parsePlatformTagName(tag), data, children,</span><br><span class="line">            <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">            <span class="comment">// component</span></span><br><span class="line">            vnode = createComponent(Ctor, data, context, children, tag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAsset</span>(<span class="params">options,type,id,warnMissing</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> assets = options[type];</span><br><span class="line">    <span class="keyword">if</span> (hasOwn(assets, id)) &#123; <span class="keyword">return</span> assets[id] &#125;</span><br><span class="line">    <span class="keyword">var</span> camelizedId = camelize(id);</span><br><span class="line">    <span class="keyword">if</span> (hasOwn(assets, camelizedId)) &#123; <span class="keyword">return</span> assets[camelizedId] &#125;</span><br><span class="line">    <span class="keyword">var</span> PascalCaseId = capitalize(camelizedId);</span><br><span class="line">    <span class="keyword">if</span> (hasOwn(assets, PascalCaseId)) &#123; <span class="keyword">return</span> assets[PascalCaseId] &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res = assets[id] || assets[camelizedId] || assets[PascalCaseId];</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面有两个关键的变量<code>Ctor，resolveAsset</code>，<code>Ctor</code>是<code>resolveAsset</code>的返回值。当执行<code>resolveAsset</code>时，传入的参数分别是<code>context.$options, components, global-component</code>，函数的处理逻辑如下：</p><ol><li><code>assets</code>存放<code>options[&#39;components&#39;]</code>的值。</li><li>如果<code>assets</code>私有属性上有<code>global-component</code>,那就返回</li><li>如果<code>assets</code>原型链上有<code>global-component</code>,那就返回</li></ol><p>值得注意的是，<code>global-component</code>是全局组件，所以会保存在<code>assets</code>的原型链上,<code>local-component</code>是局部组件，所以会保存在<code>assets</code>的私有属性上，如下图所示：<br>其中<code>KeepAlive Transtion TransitionGroup</code>都是Vue内置的全局组件</p><img src="/images/assets.png" width='400px'><h3 id="创建组件的虚拟dom"><a href="#创建组件的虚拟dom" class="headerlink" title="创建组件的虚拟dom"></a>创建组件的虚拟dom</h3><p>根据上图可以看到，传入全局组件<code>global-component</code>返回的<code>Ctor</code>是组件的构造函数<code>VueComponent</code>，传入局部组件<code>local-component</code>返回的<code>Ctor</code>是配置对象。接着就把<code>Ctor</code>传入<code>createComponent</code>函数执行，<code>createComponent</code>函数里的处理如下：</p><ol><li><code>baseCtor</code>指向<code>Vue</code></li><li>如果是局部组件，就把<code>Ctor</code>这个配置对象传入<code>Vue.extend</code>，并返回组件的构造函数<code>VueComponent</code>。</li><li>如果是函数组件，就使用<code>createFunctionalComponent</code>来创建函数组件</li><li>执行<code>installComponentHooks</code>函数往<code>data</code>对象上挂载四个钩子函数，分别是<code>init prepatch insert destroy</code></li><li>执行<code>new VNode</code>创建组件的虚拟dom，值得注意的是，创建组件的虚拟dom，会把组件的配置对象当作第七个参数传入并存到组件虚拟dom的<code>componentOptions</code>中，这是创建html的虚拟dom是没有的。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>(<span class="params"> Ctor, data, context,children,tag</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> baseCtor = context.$options._base;</span><br><span class="line">    <span class="keyword">if</span> (isObject(Ctor)) &#123;</span><br><span class="line">      Ctor = baseCtor.extend(Ctor);</span><br><span class="line">    &#125;</span><br><span class="line">    data = data || &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (isTrue(Ctor.options.functional)) &#123;</span><br><span class="line">      <span class="keyword">return</span> createFunctionalComponent(Ctor, propsData, data, context, children)</span><br><span class="line">    &#125;</span><br><span class="line">    installComponentHooks(data);</span><br><span class="line">    <span class="keyword">var</span> name = Ctor.options.name || tag;</span><br><span class="line">    <span class="keyword">var</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">      (<span class="string">&quot;vue-component-&quot;</span> + Ctor.cid + (name ? <span class="string">&quot;-&quot;</span> + name : <span class="string">&#x27;&#x27;</span>)),</span><br><span class="line">      data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">      &#123; <span class="attr">Ctor</span>: Ctor, <span class="attr">propsData</span>: propsData, <span class="attr">listeners</span>: listeners, <span class="attr">tag</span>: tag, <span class="attr">children</span>: children &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installComponentHooks</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hooks = data.hook || (data.hook = &#123;&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; hooksToMerge.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> key = hooksToMerge[i];</span><br><span class="line">        <span class="keyword">var</span> existing = hooks[key];</span><br><span class="line">        <span class="keyword">var</span> toMerge = componentVNodeHooks[key];</span><br><span class="line">        <span class="keyword">if</span> (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) &#123;</span><br><span class="line">            hooks[key] = existing ? mergeHook$<span class="number">1</span>(toMerge, existing) : toMerge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> componentVNodeHooks = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    prepatch: <span class="function"><span class="keyword">function</span> <span class="title">prepatch</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    insert: <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    destroy: <span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终组件的虚拟dom如下：<br><img src="/images/comVnode.png"></p><h3 id="Vue-extend建立继承关系"><a href="#Vue-extend建立继承关系" class="headerlink" title="Vue.extend建立继承关系"></a>Vue.extend建立继承关系</h3><p>值得注意的是<code>Vue</code>和<code>VueComponent</code>都是构造函数，其中<code>Vue</code>是根组件的构造函数，<code>VueComponent</code>是组件的构造函数，并且<code>VueComponent</code>继承了<code>Vue</code>，这两者的继承关系就是通过<code>Ctor = Vue.extend(Ctor)</code>实现的，我们看看<code>Vue.extend</code>内部的代码：</p><ol><li><code>cachedCtors</code>对象用来缓存组件构造函数<code>VueComponent</code></li><li>执行<code>Sub.prototype = Object.create(Super.prototype)</code>，通过原型链继承，是的<code>Sub.prototype</code>的原型链上有<code>Super.prototype</code>的所有方法。这样组件的实例对象就有<code>Vue.prototype</code>的所有方法了。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">var</span> Super = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> SuperId = Super.cid;</span><br><span class="line">    <span class="keyword">var</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;);</span><br><span class="line">    <span class="keyword">if</span> (cachedCtors[SuperId]) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedCtors[SuperId]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>._init(options);</span><br><span class="line">    &#125;;</span><br><span class="line">    Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">    Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line">    cachedCtors[SuperId] = Sub;</span><br><span class="line">    <span class="keyword">return</span> Sub</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建组件的真实dom"><a href="#创建组件的真实dom" class="headerlink" title="创建组件的真实dom"></a>创建组件的真实dom</h3><p>以上就是创建全局组件<code>global-component</code>对应的虚拟dom的过程。当然创建局部组件<code>local-component</code>的虚拟dom也是一样的，在创建好虚拟dom之后，就要把虚拟dom传入到<code>vm._update</code>中去处理了。</p><p>当首次挂载组件时，必然会走到<code>_update</code>函数里的第一个if判断中，并走到createElm函数来创建真实dom。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode, hydrating</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> prevEl = vm.$el;</span><br><span class="line">    <span class="keyword">var</span> prevVnode = vm._vnode;</span><br><span class="line">    vm._vnode = vnode;</span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vm.$el = vm.__patch__(prevVnode, vnode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">var</span> isRealElement = isDef(oldVnode.nodeType);</span><br><span class="line">    <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createElm( vnode, insertedVnodeQueue, oldElm._leaveCb ? <span class="literal">null</span> : parentElm,nodeOps.nextSibling(oldElm) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看createElm内部是如何处理的？其逻辑如下：</p><ol><li>把根节点交给<code>createComponent</code>处理，处理的结果为false</li><li>再把根节点及其子节点交给<code>createChildren</code>函数处理，其实就是遍历根节点的子节点，再次交给<code>createElm</code>函数去处理</li><li>根节点的子节点分别是<code>global-component，local-component</code>的虚拟dom，<code>createElm</code>内部的<code>createComponent</code>先处理<code>global-component</code>的虚拟dom</li><li>在<code>createComponent</code>函数中，取出组件的<code>init</code>钩子执行来初始化组件。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span>(<span class="params"> vnode,insertedVnodeQueue,parentElm,refElm</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> data = vnode.data;</span><br><span class="line">    <span class="keyword">var</span> children = vnode.children;</span><br><span class="line">    <span class="keyword">var</span> tag = vnode.tag;</span><br><span class="line">    createChildren(vnode, children, insertedVnodeQueue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createChildren</span>(<span class="params">vnode, children, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">        createElm(children[i], insertedVnodeQueue, vnode.elm, <span class="literal">null</span>, <span class="literal">true</span>, children, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>(<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = vnode.data;</span><br><span class="line">    <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;</span><br><span class="line">            i(vnode, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们看看<code>init</code>函数里是如何初始化组件的，流程如下：</p><ol><li>如果组件的虚拟dom<code>vnode</code>上有<code>componentInstance keepAlive</code>，并且组件没有被销毁，就判定组件需要被缓存</li><li>如果组件不是缓存的组件，那就执行<code>createComponentInstanceForVnode</code>来初始化组件.<br> 2.1 <code>createComponentInstanceForVnode</code>函数里中<code>vnode.componentOptions.Ctor</code>指向组件的构造函数<code>VueComponent</code><br> 2.2 创建组件实例的过程，也会为组件的数据对象<code>data</code>构建响应式系统，编译组件模版最终生成<code>render</code>函数等，流程和根组件一致。</li><li>执行<code>child.$mount</code>来挂载组件，因为<code>VueComponent</code>和<code>Vue</code>的继承关系已经通过<code>Vue.extend</code>建立了，所以<code>child</code>上有<code>$mount</code>方法。<br> 3.1 组件挂载的过程，也会创建<code>渲染watcher lazyWatcher 自定义watcher</code>等，并建立属性和<code>watcher</code>的依赖关系，流程和根组件一致。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> componentVNodeHooks = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">vnode, hydrating</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            vnode.componentInstance &amp;&amp; </span><br><span class="line">            !vnode.componentInstance._isDestroyed &amp;&amp; </span><br><span class="line">            vnode.data.keepAlive</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">var</span> mountedNode = vnode; <span class="comment">// work around flow</span></span><br><span class="line">            componentVNodeHooks.prepatch(mountedNode, mountedNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> child = vnode.componentInstance = createComponentInstanceForVnode(vnode,activeInstance);</span><br><span class="line">            child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponentInstanceForVnode</span>(<span class="params"> vnode,parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">        _isComponent: <span class="literal">true</span>,</span><br><span class="line">        _parentVnode: vnode,</span><br><span class="line">        parent: parent</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> vnode.componentOptions.Ctor(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6. Vue的diff算法</title>
      <link href="2020/12/19/vue06/"/>
      <url>2020/12/19/vue06/</url>
      
        <content type="html"><![CDATA[<p>上一节我们已经知道在触发更新后，<code>渲染watcher</code>会重新触发求值函数，求值函数内部先要<code>vm._render()</code>生成新值对应的虚拟dom，并把结果交给<code>vm._update</code>处理，接下来我们看看<code>vm._update</code>内部的实现逻辑？</p><ol><li><code>prevVnode</code>存储上次更新时的虚拟dom</li><li><code>vm._vnode</code>存储本次更新时的虚拟dom</li><li>如果<code>prevVnode</code>没有值，即首次挂载组件，则创建真实dom</li><li>如果<code>prevVnode</code>有值，即非首次挂载组件，那就把更新前后的虚拟dom传入<code>vm.__patch__</code>函数中去比较。</li></ol><p>显然组件更新时，应该走进else语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    vm._update(vm._render(), hydrating);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode, hydrating</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> prevEl = vm.$el;</span><br><span class="line">    <span class="keyword">var</span> prevVnode = vm._vnode;</span><br><span class="line">    vm._vnode = vnode;</span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">        <span class="comment">// initial render</span></span><br><span class="line">        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// updates</span></span><br><span class="line">        vm.$el = vm.__patch__(prevVnode, vnode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="diff算法的入口"><a href="#diff算法的入口" class="headerlink" title="diff算法的入口"></a>diff算法的入口</h2><p>函数<code>vm.__patch__</code>是Vue的diff算法入口，我们看看内部是如何处理的？</p><ol><li>判断当前虚拟dom是否是静态节点，如果是静态节点，那就不再进行比较了。</li><li>把新老虚拟dom，放到<code>cbs.update</code>数组中各个函数去比较，其中<code>cbs.update</code>数组中各函数的作用是比较虚拟dom的属性</li><li>把新老虚拟dom,放到<code>updateChildren</code>函数中去比较，比较出差异，最终更新视图</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span>(<span class="params"> oldVnode,vnode</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">if</span> (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) &#123;</span><br><span class="line">        vnode.componentInstance = oldVnode.componentInstance;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data = vnode.data;</span><br><span class="line">    <span class="keyword">var</span> oldCh = oldVnode.children;</span><br><span class="line">    <span class="keyword">var</span> ch = vnode.children;</span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) &#123; cbs.update[i](oldVnode, vnode); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) &#123; updateChildren(elm, oldCh, ch) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较虚拟dom的data"><a href="#比较虚拟dom的data" class="headerlink" title="比较虚拟dom的data"></a>比较虚拟dom的data</h2><p>上面说到的<code>cbs.update</code>的结构以及假定本次生成的虚拟dom如下，其中：</p><ol><li><code>updateAttrs</code>是用来比对attrs的差异并更新的</li><li><code>updateclass</code>是用来比对class的差异并更新的</li><li><code>updateDomListeners</code>是用来比对绑定事件的差异并更新的</li><li><code>updateDOMProps</code>是用来比对</li><li><code>updateStyle</code>是用来比对样式的差异并更新的</li><li><code>update</code>是用来比对ref的差异并更新的</li><li><code>updateDirectives</code>是用来比对自定义指令的差异并更新的<br>具体详情见:<a href="https://cn.vuejs.org/v2/guide/render-function.html">https://cn.vuejs.org/v2/guide/render-function.html</a><br>归根结底，<code>cbs.update</code>内部的函数其实就是用来找到<code>虚拟dom上的</code>所有属性并更新的，不过上面的比较方式是有弊端的，如果我本次没有更新这些虚拟dom上的属性，Vue内部还是会比较dom上的全部属性(全量比较)。<br>其实当我们没有更新虚拟dom上的属性时，最好的做法就是不比较，只有在更新某些属性的时候，我们再比较这些更新的属性。这样做可以节省无谓的比较次数。当然Vue2.x采用的是全量比较，在Vue3中就给需要更新的属性加上flag，只更新有flag的属性值。这也是Vue3的性能比Vue2好的一个原因。</li></ol><img src="/images/vdom.png" width='400px'><img src="/images/updatefn.png" width='400px'><h2 id="比较虚拟dom的children"><a href="#比较虚拟dom的children" class="headerlink" title="比较虚拟dom的children"></a>比较虚拟dom的children</h2><p>如果说上面的<code>cbs.update</code>函数是用来比较<code>虚拟dom属性</code>的差异，那<code>updateChildren</code>就是用来比较<code>虚拟dom的子节点</code>差异的，我们接下来看看<code>updateChildren</code>的内部实现：</p><ol><li>定义四个指针，其中<code>oldStartIdx,oldEndIdx</code>指向更新前虚拟dom(老虚拟dom)的首尾索引，<code>newStartIdx,newEndIdx</code>指向更新后(新虚拟dom)的首尾索引。</li><li>再定义四个指针，其中<code>oldStartVnode,oldEndVnode</code>指向更新前虚拟dom的首尾节点，<code>newStartVnode,newEndVnode</code>指向更新后(新虚拟dom)的首尾节点。</li><li>启动while循环，前两个判断是处理越界情况的并不是重点，重要的是后面四个else if判断，分别是：<ol><li>判断老dom的头和新dom中的头是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动<code>oldStartIdx,newStartIdx,oldStartVnode,newStartVnode</code>指针。</li><li>判断老dom的尾和新dom中的尾是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动<code>oldEndIdx,newEndIdx,oldEndVnode,newEndVnode</code>指针。</li><li>判断老dom的头和新dom中的尾是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动<code>oldStartIdx,newEndIdx,oldStartVnode,newEndVnode</code>指针。</li><li>判断老dom的尾和新dom中的头是否是同一个虚拟dom，如果是就进行比较，比较出差异并更新视图，比较结束后，移动<code>oldEndIdx,newStartIdx,oldEndVnode,newStartVnode</code>指针。</li><li>如果上面四个判断都没走进去，那就基于本次添加的新dom创建真实dom，并添加到页面上。<br>归根结底上面的四个判断，<code>其实就是老头对新头，老尾对新尾，老头对新尾，老尾对新头的比较，这样比较的好处是尽可能多的复用老的虚拟dom</code>。</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oldStartIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> newStartIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> oldEndIdx = oldCh.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> oldStartVnode = oldCh[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">    <span class="keyword">var</span> newEndIdx = newCh.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> newStartVnode = newCh[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> newEndVnode = newCh[newEndIdx];</span><br><span class="line">    <span class="keyword">var</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]; <span class="comment">// Vnode has been moved left</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">            newEndVnode = newCh[--newEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">            newEndVnode = newCh[--newEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isUndef(oldKeyToIdx)) &#123; </span><br><span class="line">                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); </span><br><span class="line">            &#125;</span><br><span class="line">            idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">            <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vnodeToMove = oldCh[idxInOld];</span><br><span class="line">                <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">                    patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class="line">                    oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">                    canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">        refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm;</span><br><span class="line">        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sameVNode"><a href="#sameVNode" class="headerlink" title="sameVNode"></a>sameVNode</h2><p>上面的<code>updateChildren</code>函数中用到<code>sameVNode</code>来判断是否是同一个虚拟dom，我们看看内部是如何判断的？</p><ol><li><code>key</code>值必须相同，在没有给虚拟dom添加<code>key</code>的情况下，<code>key</code>都是<code>undefined</code>，所以在没有手动添加key的情况下<code>a.key===b.key</code>成立，都是<code>undefined</code>。</li><li><code>tag</code>值必须相同，即虚拟dom对应的标签名必须一样。</li><li>对应<code>input</code>标签，<code>type</code>值必须相同。</li></ol><p>满足以上条件，才会判定是同一个虚拟dom。才会有走到同一个虚拟dom的<code>patch</code>逻辑中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        a.key === b.key &amp;&amp; (</span><br><span class="line">        (</span><br><span class="line">            a.tag === b.tag &amp;&amp;</span><br><span class="line">            a.isComment === b.isComment &amp;&amp;</span><br><span class="line">            isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">            sameInputType(a, b)</span><br><span class="line">        ) || (</span><br><span class="line">            isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">            a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">            isUndef(b.asyncFactory.error)</span><br><span class="line">        )</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="v-for的key"><a href="#v-for的key" class="headerlink" title="v-for的key"></a>v-for的key</h2><p>我们是不建议在列表循环时，用索引来动态绑定<code>key</code>值的，为什么呢，可以看下面的情况:</p><ol><li>对比老dom的头和新dom的头，发现<code>key</code>都是0,则判定是同一个虚拟dom，比较出差异，由1-&gt;3 ，更新dom，之后移动指针</li><li>重复第一步， 比对老dom的头和新dom的头，发现<code>key</code>都是1,则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针</li><li>重复第一步， 比对老dom的头和新dom的头，发现<code>key</code>都是2,则判定是同一个虚拟dom，比较出差异，由3-&gt;1 ，更新dom</li></ol><p><code>根据以上分析，用索引来动态绑定key值会有两次dom操作。</code><br><img src="/images/before.png" width='500px'></p><p>让我们换个方式，用数组内部来动态绑定<code>key</code>：</p><ol><li>对比老dom的头和新dom的头，发现<code>key</code>不同，老头<code>key：1</code>,新头<code>key：3</code>，则判定不是同一个虚拟dom。</li><li>对比老dom的头和新dom的尾，发现<code>key</code>都是1，则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针</li><li>重复第一步， 比对老dom的头和新dom的头，发现<code>key</code>不同，老头<code>key：2</code>,新头<code>key：3</code>，则判定不是同一个虚拟dom。</li><li>对比老dom的头和新dom的尾，发现<code>key</code>都是2，则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针</li><li>重复第一步， 比对老dom的头和新dom的头，发现<code>key</code>都是3,则判定是同一个虚拟dom，没有比较出差异，不更新dom，之后移动指针</li></ol><p><code>根据以上分析，用数组内部来动态绑定key值没有进行dom操作。</code></p><img src="/images/after.png" width='500px'>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. Vue的更新策略</title>
      <link href="2020/12/17/vue05/"/>
      <url>2020/12/17/vue05/</url>
      
        <content type="html"><![CDATA[<p>在上篇文章中，我们已经讲到Vue内部如何进行依赖收集的，咱们先假定模版如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;handleClick&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&#x27;item in list&#x27;</span>&gt;</span>&#123;&#123;item&#125;&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;obj&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;splitMsg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">&#x27;我是数据&#x27;</span>,</span><br><span class="line">    list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    obj: &#123;</span><br><span class="line">      name: <span class="string">&#x27;heaven&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">splitMsg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.msg = <span class="string">&#x27;我是修改的数据&#x27;</span>;</span><br><span class="line">      <span class="built_in">this</span>.lish.push(<span class="number">4</span>)</span><br><span class="line">      <span class="built_in">this</span>.obj.name = <span class="string">&#x27;啦啦啦&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/render01.png" ><p>最终模版转成的render函数如上所示，依赖收集的结果如下:</p><ol><li>list对应的订阅器对象dep中<code>subs=[渲染watcher]</code></li><li>obj对应的订阅器对象dep中<code>subs=[渲染watcher]</code></li><li>splitMsg是计算属性，所以msg对应的订阅器对象dep中<code>subs=[lazyWatcher,渲染watcher]</code></li><li>name对应的订阅器对象dep中<code>subs=[渲染watcher]</code><br>并且因为<code>childOb.dep.depend</code>的原因，obj和list这俩引用数据的dep订阅器对象的sub也会存储watcher，并且<code>subs=[渲染watcher]</code></li></ol><h2 id="渲染watcher的依赖图"><a href="#渲染watcher的依赖图" class="headerlink" title="渲染watcher的依赖图"></a>渲染watcher的依赖图</h2><p>最终渲染watcher收集的dep如下</p><img src="/images/renderwatcher.png" ><h2 id="lazyWatcher的依赖图"><a href="#lazyWatcher的依赖图" class="headerlink" title="lazyWatcher的依赖图"></a>lazyWatcher的依赖图</h2><p>最终lazyWatcher收集的dep如下<br><img src="/images/lazywatcher.png" ></p><h2 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h2><p>我们知道Vue内部为普通对象/数组构建了响应式系统，想要视图更新共有两种：</p><ol><li>给对象属性赋值，触发set钩子</li><li>执行数组变异方法，触发mutator函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  methods:&#123;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.msg = <span class="string">&#x27;我是修改的数据&#x27;</span>;</span><br><span class="line">      <span class="built_in">this</span>.lish.push(<span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="修改对象属性"><a href="#修改对象属性" class="headerlink" title="修改对象属性"></a>修改对象属性</h3><p>上面代码<code>this.msg = &#39;我是修改的数据&#39;</code>会触发下面的set钩子函数，<code>dep.notify()</code>就是触发视图更新的关键代码，<br>视图更新的逻辑如下：</p><ol><li>取出subs数组中所有的watcher，并触发watcher的update方法。对于msg来说，subs数组的watcher只有一个渲染watcher</li><li>update内部是基于watcher的种类做不同的处理，对于渲染watcher直接放到queueWatcher函数中处理，对于lazyWatcher，把dirty置true，表示lazyWatcher并没有求值。queueWatcher函数内部拿到watcher会怎么处理，我们稍等再说，值得注意的是，此时视图还没有更新呢。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  val = newVal;</span><br><span class="line">  childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">  dep.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.prototype.notify = <span class="function"><span class="keyword">function</span> <span class="title">notify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> subs = <span class="built_in">this</span>.subs.slice();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].update();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">    <span class="built_in">this</span>.run();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组变异方法"><a href="#数组变异方法" class="headerlink" title="数组变异方法"></a>数组变异方法</h3>接下来我们执行数组的变异方法<code>this.lish.push(4)</code>来触发mutator函数，大致逻辑是：</li><li><code>original.apply</code>执行数组原型的push方法</li><li>对push/unshift/splice这三个方法，对添加的到list数组的新数据进行观测</li><li><code>ob.dep.notify()</code>触发视图更新，值得注意的是ob指向<code>this.__ob__</code>，mutator函数内部this指向list数组，在观测list数组时，就已经通过<code>def(value, &#39;__ob__&#39;, this)</code>给list数组添加__ob__属性了。所以<code>this.__ob__</code>指向的就是list数组对应的观测对象，一旦执行<code>ob.dep.notify()</code>，就会取出list数组对应的dep订阅器对象里subs所有的watcher，对于list数组来说，subs数组只有一个渲染watcher，接着再执行watcher.update，最后是把渲染watcher放到queueWatcher函数中处理。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> original = arrayProto[method];</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [], len = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">while</span> (len--) args[len] = <span class="built_in">arguments</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    <span class="keyword">var</span> ob = <span class="built_in">this</span>.__ob__;</span><br><span class="line">    <span class="keyword">var</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) &#123; ob.observeArray(inserted); &#125;</span><br><span class="line">    ob.dep.notify();</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="vm-set"><a href="#vm-set" class="headerlink" title="vm.$set"></a>vm.$set</h3><p>如果要让视图中的obj更新，只要<code>this.obj.name=&#39;啦啦啦&#39;</code>即可，其更新视图的流程和上面分析的<code>this.msg=&#39;我是修改的数据&#39;</code>一致，当然我们修改的obj的name属性，因为在构建响应式系统时，已经给name属性添加get和set，自然可以触发视图更新了，假定我们<code>this.obj.age=28</code>这样是否可以触发视图更新呢，根据Vue的使用经验，其实这样是不会触发视图更新的，<br>如果就是希望<code>this.obj.age=28</code>来触发视图更新，可以使用<code>vm.$set</code>这个API来触发视图更新，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  methods:&#123;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.obj.name = <span class="string">&#x27;啦啦啦&#x27;</span> <span class="comment">//可以触发视图更新，因为构建响应式系统时已经添加set</span></span><br><span class="line">      <span class="built_in">this</span>.obj.age = <span class="number">28</span> <span class="comment">//不可以触发视图更新，因为构建响应式系统时，并没有添加set</span></span><br><span class="line">      vm.$set(<span class="built_in">this</span>.obj,<span class="string">&#x27;age&#x27;</span>,<span class="number">28</span>)  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接下来，我们看看<code>vm.$set</code>是如何实现的？</p><ol><li>取出ob，这里ob指向<code>this.obj</code>这个对象的Observe实例</li><li>使用defineReactive$$1函数给<code>ob.value</code>的age属性构建响应式系统，这里<code>ob.value</code>指向<code>this.obj</code></li><li><code>ob.dep.notify()</code>触发更新，也是把渲染watcher放到queueWatcher函数中处理，因为<code>childOb.dep.depend</code>的原因，所以这里<code>ob.dep</code>的subs中已经存储了渲染watcher。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$set = <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此处省略若干代码</span></span><br><span class="line">  <span class="keyword">var</span> ob = (target).__ob__;</span><br><span class="line">  defineReactive$$1(ob.value, key, val);</span><br><span class="line">  ob.dep.notify();</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h2><h3 id="queueWatcher"><a href="#queueWatcher" class="headerlink" title="queueWatcher"></a>queueWatcher</h3><p>上面我们讨论了三种触发视图更新的方式，不过我们只讨论到把watcher交给queueWatcher中处理，在这之前其实视图并没有更新，也就是说真正视图更新的逻辑是放在queueWatcher去做的，我们看看queueWatcher内部的代码逻辑：</p><ol><li>has存储不同的watcher.id</li><li>定义开关flushing，只要<code>flushing=false</code>那就把watcher放到queue数组中,其实flushSchedulerQueue没执行，flushing就一直为false</li><li>定义开关waiting，只要<code>waiting=false</code>那就触发<code>nextTick(flushSchedulerQueue)</code>,并立马把waiting置true，防止再次触发<code>nextTick(flushSchedulerQueue)</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> has = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> queue = [];</span><br><span class="line"><span class="keyword">var</span> waiting = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> flushing = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此处省略若干代码</span></span><br><span class="line">  <span class="keyword">var</span> id = watcher.id;</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span>;</span><br><span class="line">      nextTick(flushSchedulerQueue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p>nextTick的作用是收集本次传入的cb回调函数，并立马触发timerFunc，处理方式如下：</p><ol><li>callbacks存放传入的cb回调函数，例如上面的<code>nextTick(flushSchedulerQueue)</code>就是把flushSchedulerQueue放入到callbacks中，其实当用户手动触发<code>this.$nextTick(回调函数)</code>，也会将回调函数放入到callbacks中</li><li>定义开关pending，只要<code>pending=false</code>那就触发<code>timerFunc()</code>,并立马把pending置true，防止再次触发<code>timerFunc()</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = [];</span><br><span class="line"><span class="keyword">var</span> pending = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb, ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _resolve;</span><br><span class="line">  callbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">       cb.call(ctx);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span>;</span><br><span class="line">    timerFunc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 手动触发this.$nextTick(回调函数)的逻辑</span></span><br><span class="line">Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextTick(fn, <span class="built_in">this</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="timerFunc"><a href="#timerFunc" class="headerlink" title="timerFunc"></a>timerFunc</h3><p>timerFunc的作用异步处理<code>flushCallbacks</code>，其中<code>flushCallbacks</code>存放的全是<code>nextTick函数</code>中<code>callbacks</code>收集的cb回调函数，例如<code>flushSchedulerQueue，自定义回调</code>等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="comment">// 此处省略若干代码</span></span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  timerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    p.then(flushCallbacks);</span><br><span class="line">  &#125;;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> copies = callbacks.slice(<span class="number">0</span>);</span><br><span class="line">  callbacks.length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h3><p>终于走到flushSchedulerQueue函数了，这里才是真正视图更新的地方，先看看内部的逻辑：</p><ol><li>queue数组升序排列</li><li>判断before存在，其实只有渲染watcher创建时有配置before，所以对于渲染watcher需要触发before配置，即组件的<code>beforeUpdate</code>钩子函数</li><li>取出queue中的每个watcher，并执行watcher.run，在这个情况，queue数组中只有一个渲染watcher，可以看到watcher.run中就执行了get触发求值函数了，因为template中用到了<code>list/obj/splitMsg</code>三个值，所以求值函数会求出<code>list/obj/splitMsg</code>最新的值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  currentFlushTimestamp = getNow();</span><br><span class="line">  flushing = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> watcher, id;</span><br><span class="line">  queue.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a.id - b.id; &#125;);</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index];</span><br><span class="line">    <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">      watcher.before();</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id;</span><br><span class="line">    has[id] = <span class="literal">null</span>;</span><br><span class="line">    watcher.run();</span><br><span class="line">  &#125;</span><br><span class="line">  callUpdatedHooks(updatedQueue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置任务状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetSchedulerState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  queue.length = <span class="number">0</span>;</span><br><span class="line">  has = &#123;&#125;;</span><br><span class="line">  waiting = flushing = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.run = <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="built_in">this</span>.get();</span><br><span class="line">    <span class="keyword">if</span> ( value !== <span class="built_in">this</span>.value || isObject(value) || <span class="built_in">this</span>.deep) &#123;</span><br><span class="line">      <span class="keyword">var</span> oldValue = <span class="built_in">this</span>.value;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上就是Vue的更新策略，其实就是将所有的<code>watcher</code>都放到<code>queue</code>数组中，并异步执行<code>watcher.run</code>从而让视图更新，当然我们知道触发求值函数一定可以算出新值，即<code>list/obj/splitMsg</code>，那算出新值之后是直接把新值作为内容直接渲染到dom结构中嘛？这样其实并不合理，假如我们没有更新<code>list</code>,那算出的<code>list</code>就和更新之前的<code>list</code>是一样的。这种情况，其实没有必要把没变化的<code>list</code>作为内容直接渲染到dom结构中。即在算出新值时，我们需要和更新前的值比较，新值和老值一样，就不进行dom操作，新值和老值不一样，就更新dom，这就涉及到解析来我们要讲的Vue内部的diff算法了。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. Vue首次挂载，发生了肾么事?</title>
      <link href="2020/12/15/vue04/"/>
      <url>2020/12/15/vue04/</url>
      
        <content type="html"><![CDATA[<h2 id="挂载组件的入口"><a href="#挂载组件的入口" class="headerlink" title="挂载组件的入口"></a>挂载组件的入口</h2><p>在第三节文章中，我们知道了Vue把<code>template</code>编译成<code>render</code>函数的过程。接下来Vue内部会怎么处理呢？其实接下来Vue就会执行<code>mountComponent</code>函数来挂载组件，如下所示：</p><ol><li>触发<code>beforeMount</code>钩子</li><li>创建<code>watcher</code>的求值函数<code>updateComponent</code>，其中<code>_render</code>函数是创建虚拟dom,<code>_update</code>函数在首次触发时会基于创建的虚拟dom来生成真实dom</li><li>创建渲染<code>watcher</code>,其中最后一个参数true表示该<code>watcher</code>是<code>渲染watcher</code></li><li>触发<code>mounted</code>钩子</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vm, el,hydrating</span>) </span>&#123;</span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> updateComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        vm._update(vm._render(), hydrating);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">        before: <span class="function"><span class="keyword">function</span> <span class="title">before</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">                callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">        vm._isMounted = <span class="literal">true</span>;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建渲染watcher"><a href="#创建渲染watcher" class="headerlink" title="创建渲染watcher"></a>创建渲染watcher</h2><p>接下来咱们看看Vue是如何定义<code>Watcher</code>这个类的，对于<code>Watcher</code>类的参数需要详细说下：</p><ol><li><code>expOrFn</code>存储<code>watcher</code>的求值函数 ，对于<code>渲染watcher</code>，<code>expOrFn</code>就是<code>updateComponent</code> ，当然除了<code>渲染watcher</code>之后，其实还会有别的两<code>类watcher</code>，分别是为计算属性创建的<code>lazyWatcher</code>和为<code>watch</code>选项创建的<code>自定义watcher</code>，这两类对应的求值函数都是用户自定义传入的。</li><li><code>cb</code>存储求值函数执行后的回调函数，对于<code>渲染watcher</code>，<code>cb</code>就是<code>noop</code>空函数</li><li><code>options</code>存储<code>watcher</code>创建的配置参数，其中创建<code>渲染watcher</code>传入的配置对象有<code>before</code>钩子函数，创建<code>自定义watcher</code>时传入的配置对象有<code>user</code>属性为<code>true</code>，创建<code>lazyWatcher</code>时传入的配置对象有<code>lazy</code>属性为<code>true</code>。</li><li><code>isRenderWatcher</code> 表示创建的<code>watcher</code>是否是<code>渲染watcher</code>，<code>isRenderWatcher</code>为<code>true</code>表示<code>渲染watcher</code>，并将<code>渲染watcher</code>放到<code>vm._watcher</code>中。</li></ol><p>除了这些参数之外，还有别的处理，比如:</p><ol><li>每次创建<code>watcher</code>时都会把<code>watcher</code>放到<code>vm._watchers</code></li><li>在创建<code>watcher</code>时，基于<code>lazy</code>值判断是否执行求值函数，其中如果是<code>lazyWatcher</code>就不立马求值，不是<code>lazyWatcher</code>就立马求值。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Watcher = <span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params"> vm, expOrFn, cb, options, isRenderWatcher</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = !!options.deep;</span><br><span class="line">      <span class="built_in">this</span>.user = !!options.user;</span><br><span class="line">      <span class="built_in">this</span>.lazy = !!options.lazy;</span><br><span class="line">      <span class="built_in">this</span>.sync = !!options.sync;</span><br><span class="line">      <span class="built_in">this</span>.before = options.before;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = <span class="built_in">this</span>.user = <span class="built_in">this</span>.lazy = <span class="built_in">this</span>.sync = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.id = ++uid$<span class="number">2</span>; <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="built_in">this</span>.active = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="built_in">this</span>.lazy; <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="built_in">this</span>.deps = [];</span><br><span class="line">    <span class="built_in">this</span>.newDeps = [];</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="keyword">new</span> _Set();</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = <span class="keyword">new</span> _Set();</span><br><span class="line">    <span class="built_in">this</span>.expression = expOrFn.toString();</span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.lazy ? <span class="literal">undefined</span> : <span class="built_in">this</span>.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watche-run"><a href="#watche-run" class="headerlink" title="watche.run"></a>watche.run</h3><p>经过上面的分析，只要不是<code>lazyWatcher</code>就求值，那我们在初始化<code>渲染watcher</code>就会触发求值函数了，接下来我们看看run函数的逻辑：<br>1.触发<code>pushTarget</code>，当前的<code>watcher</code>入<code>targetStack</code>栈，<code>Dep.target</code>指向栈顶的<code>watcher</code><br>2.触发求值函数<code>getter</code><br>3.触发<code>popTarget</code>，当前的<code>watcher</code>出<code>targetStack</code>栈，<code>Dep.target</code>指向栈顶的<code>watcher</code><br>4.触发<code>cleanupDeps</code>函数，<code>depIds/deps</code>存储本次<code>newDepIds/newDeps</code>的值，之后再清空<code>newDepIds/newDeps</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    pushTarget(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>.vm;</span><br><span class="line">    value = <span class="built_in">this</span>.getter.call(vm, vm);</span><br><span class="line">    popTarget();</span><br><span class="line">    <span class="built_in">this</span>.cleanupDeps();</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> targetStack = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    targetStack.push(target);</span><br><span class="line">    Dep.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    targetStack.pop();</span><br><span class="line">    Dep.target = targetStack[targetStack.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.cleanupDeps = <span class="function"><span class="keyword">function</span> <span class="title">cleanupDeps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="built_in">this</span>.deps.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">var</span> dep = <span class="built_in">this</span>.deps[i];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="built_in">this</span>.depIds;</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="built_in">this</span>.newDepIds;</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = tmp;</span><br><span class="line">    <span class="built_in">this</span>.newDepIds.clear();</span><br><span class="line">    tmp = <span class="built_in">this</span>.deps;</span><br><span class="line">    <span class="built_in">this</span>.deps = <span class="built_in">this</span>.newDeps;</span><br><span class="line">    <span class="built_in">this</span>.newDeps = tmp;</span><br><span class="line">    <span class="built_in">this</span>.newDeps.length = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="渲染watcher求值"><a href="#渲染watcher求值" class="headerlink" title="渲染watcher求值"></a>渲染watcher求值</h3><p>对于<code>渲染watcher</code>来说，求值函数<code>getter</code>就是<code>updateComponent</code>，而<code>updateComponent</code>函数的逻辑也很清晰:</p><ol><li>触发<code>_render</code>函数</li><li>触发<code>_update</code>函数<br>可以看到<code>_render</code>函数内部就是执行生成的<code>render</code>函数，而这个<code>render</code>函数就是基于<code>template</code>模版创建的<code>render</code>函数，值的注意的是，执行<code>render</code>函数时，会将内部this指向<code>vm._renderProxy</code>，<code>vm._renderProxy</code>对象经过处理指向组件实例vm。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> updateComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    vm._update(vm._render(), hydrating);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> ref = vm.$options;</span><br><span class="line">    <span class="keyword">var</span> render = ref.render;</span><br><span class="line">    <span class="keyword">var</span> vnode = render.call(vm._renderProxy, vm.$createElement);</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假定template模版如下，则生成的render函数如下图所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">app</span> <span class="attr">class</span>=<span class="string">&quot;heaven&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;handleClick&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/images/render.png"  ><h3 id="渲染watcher收集依赖"><a href="#渲染watcher收集依赖" class="headerlink" title="渲染watcher收集依赖"></a>渲染watcher收集依赖</h3><p>当执行<code>render</code>函数时，有个<code>with</code>语句，执行<code>with</code>内部逻辑时，总是从<code>this</code>中取值，即取<code>msg</code>的值时，等价取<code>vm.msg</code>，因为我们之前做了数据代理的原因， 所以取<code>vm.msg</code>时，等价取<code>vm._data.msg</code> ,此时就触发了<code>msg</code>的<code>get</code>钩子函数。这时候<code>get</code>函数内部就会构建属性<code>msg</code>和<code>watcher</code>的依赖关系，我们看看<code>get</code>函数内部是怎么做的？</p><ol><li>判断<code>Dep.target</code>是否存在，之所以要有这个判断，是因为我们只要在<code>渲染watcher/lazyWatcher/自定义watcher</code>的求值函数触发时，才触发<code>dep.depend</code>函数</li><li>判断<code>childOb</code>是否存在，存在就执行<code>childOb.dep.depend</code>，childOb是什么？为什么要执行<code>childOb.dep.depend</code>，我们会在<code>Vue的更新策略</code>再说。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive$$1</span>(<span class="params"> obj, key, val, customSetter,shallow</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep(key);</span><br><span class="line">    <span class="keyword">var</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                dep.depend();</span><br><span class="line">                <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">                    childOb.dep.depend();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">                        dependArray(value);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            val = newVal;</span><br><span class="line">            childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面的分析，我们知道<code>Dep.target</code>存在的话就要执行<code>dep.depend</code>方法，我们看看这个函数内部做了什么？</p><ol><li>判断<code>Dep.target</code>是否存在，值得注意的是，此时<code>Dep.target</code>指向<code>渲染watcher</code>，并且执行<code>渲染watcher</code>的<code>addDep</code>方法</li><li><code>watcher</code>的<code>addDep</code>方法内部用到两个if判断，第一个判断是为了防止在本次求值过程中重复把<code>watcher</code>放到<code>dep</code>对象中，第二个if判断是为了防止在不同的求值时刻（用户更新视图会再次求值，再次求值会再次走到<code>addDep</code>的逻辑中）重复把<code>watcher</code>放到<code>dep</code>对象中。</li><li>最终会触发<code>dep.addSub</code>方法，把<code>watcher</code>放到<code>depd对象的subs</code>中。<br>至此属性<code>msg</code>的<code>dep</code>对象中的<code>subs</code>数组收集到了<code>渲染watcher</code>，这就是<code>msg</code>属性的依赖收集过程。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Dep = <span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.id = uid++;</span><br><span class="line">    <span class="built_in">this</span>.subs = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dep.prototype.addSub = <span class="function"><span class="keyword">function</span> <span class="title">addSub</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">&#125;;</span><br><span class="line">Dep.prototype.depend = <span class="function"><span class="keyword">function</span> <span class="title">depend</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        Dep.target.addDep(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.addDep = <span class="function"><span class="keyword">function</span> <span class="title">addDep</span>(<span class="params">dep</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = dep.id;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.newDepIds.add(id);</span><br><span class="line">        <span class="built_in">this</span>.newDeps.push(dep);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.depIds.has(id)) &#123;</span><br><span class="line">            dep.addSub(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="childOb-dep-depend的作用"><a href="#childOb-dep-depend的作用" class="headerlink" title="childOb.dep.depend的作用"></a>childOb.dep.depend的作用</h3><p>上面留了一个疑问，在<code>get</code>钩子中为什么要判断<code>childObj</code>?要明确这一点，我们先要知道<code>childObj</code>是什么？根据上面代码可知，<code>childObj</code>是<code>observe</code>函数的返回值，先看看<code>observe</code>函数是什么？其实<code>observe</code>函数就是第一节说到的Vue响应式系统的入口，<code>observe</code>函数返回的是个观测后的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value, asRootData</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ob;</span><br><span class="line">    <span class="keyword">if</span> (hasOwn(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">        ob = value.__ob__;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        shouldObserve &amp;&amp;</span><br><span class="line">        !isServerRendering() &amp;&amp;</span><br><span class="line">        (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">        <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">        !value._isVue</span><br><span class="line">    ) &#123;</span><br><span class="line">        ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep(value);</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">            protoAugment(value, arrayMethods);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">this</span>.observeArray(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果观测的数据是<code>value=[1,2,3,4]</code>,那么<code>observe</code>函数返回的结果如下：</p><img src="/images/childobj.png"  ><p>所以<code>childObj</code>就是类似上面的数据结构，之所以在<code>get</code>的钩子函数中还要在判断<code>childObj</code>是否存在，其实就是为了当<code>childObj</code>存在时，再把当前的<code>watcher</code>添加到<code>childObj.dep.subs</code>数组中，为什么要把<code>watcher</code>放到<code>subs</code>数组中？咱们在下一节<code>Vue的更新策略</code>中会讲到。</p><p>上面讲到的是<code>渲染watcher</code>的创建和收集依赖的过程，接下来再说一下<code>lazyWatcher</code>的创建和收集依赖的过程,假定模版如下所示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">app</span> <span class="attr">class</span>=<span class="string">&quot;heaven&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;splitMsg&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: <span class="string">&#x27;我是数据&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        <span class="function"><span class="title">splitMsg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建lazyWatcher"><a href="#创建lazyWatcher" class="headerlink" title="创建lazyWatcher"></a>创建lazyWatcher</h2><p>其实对于<code>computed</code>选项里的每个计算属性，Vue内部都会为其生成一个<code>lazyWatcher</code>，我们看下Vue内部的处理，大致逻辑如下：</p><ol><li>遍历<code>computed</code>选项，为每个计算属性都创建一个<code>watcher</code>，这里传递的求值函数是用户自己配置的属性的get</li><li>触发<code>defineComputed</code>函数，给计算属性添加<code>get/set</code>，即<code>vm.filterMsg</code>就会触发get钩子函数<br>值得注意的是，<code>computedWatcherOptions</code>的<code>lazy</code>值为<code>true</code>，用来标记是一个<code>lazyWatcher</code>，而且<code>lazyWatcher</code>上有个<code>dirty</code>表示<code>lazyWatcher</code>是否已经求值了，<code>lazyWatcher</code>初始时是不会求值的，所以<code>dirty</code>为<code>true</code>。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span>(<span class="params">vm, computed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">    <span class="keyword">var</span> isSSR = isServerRendering();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">        <span class="keyword">var</span> userDef = computed[key];</span><br><span class="line">        <span class="keyword">var</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.get;</span><br><span class="line">        <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">            <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">            watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">                vm,</span><br><span class="line">                getter || noop,</span><br><span class="line">                noop,</span><br><span class="line">                computedWatcherOptions</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        defineComputed(vm, key, userDef);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span>(<span class="params">target, key,userDef</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    sharedPropertyDefinition.get = createComputedGetter(key)</span><br><span class="line">    sharedPropertyDefinition.set = noop;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> watcher = <span class="built_in">this</span>._computedWatchers &amp;&amp; <span class="built_in">this</span>._computedWatchers[key];</span><br><span class="line">        <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">            <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">                watcher.evaluate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                watcher.depend();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> watcher.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="lazyWatcher收集依赖"><a href="#lazyWatcher收集依赖" class="headerlink" title="lazyWatcher收集依赖"></a>lazyWatcher收集依赖</h3><p>当然，在创建<code>watcher</code>时，一旦<code>lazy</code>是<code>true</code>，就不会在立马执行求值函数，那么<code>lazyWatcher</code>是在什么时刻求值的呢？其实也是在<code>render</code>函数中执行时才求值的，上面的模版最终编译的<code>render</code>函数如下，当执行<code>this.filterMsg</code>时，就会触发get函数，而get钩子函数的逻辑:</p><ol><li>从<code>_computedWatchers</code>中取出<code>lazyWatcher</code></li><li>判断<code>dirty</code>，如果值为<code>true</code>，就表示此刻<code>lazyWatcher</code>还没有求值，就触发<code>evaluate</code>函数</li></ol><img src="/images/computed.png"  ><p>在<code>evaluate</code>函数函数里面,就会触发求值函数了，之后会把<code>dirty</code>置<code>false</code>，表示<code>lazyWatcher</code>已经求值完成，在<code>lazyWatcher</code>求值时，需要注意下面几点：</p><ol><li><p>因为<code>lazyWatcher</code>是在<code>render</code>函数执行时遇到计算属性的基础上求值的，所以在<code>lazyWatcher</code>求值之前，<code>targetStack=[渲染watcher]</code>,在<code>lazyWatcher</code>求值之后，<code>targetStack=[渲染watcher,lazyWatcher]</code></p></li><li><p>此刻<code>Dep.target</code>指向<code>lazyWatcher</code></p></li><li><p><code>lazyWatcher</code>的求值函数是用户自定义的，在这里应该是<code> splitMsg() &#123; return this.msg.split(&#39;&#39;) &#125;</code>,可想而知，一旦执行该函数，就会执行<code>this.msg</code>，这时就会触发<code>msg</code>的get钩子函数进行依赖收集，把<code>lazyWatcher</code>添加到<code>msg</code>的<code>dep</code>(属性订阅器)的<code>subs</code>中（步骤和收集<code>渲染watcher</code>一致）。</p></li><li><p>执行<code>popTarget</code>函数，<code>lazyWatcher</code>从<code>targetStack</code>弹出，此刻<code>Dep.target</code>指向<code>渲染watcher</code></p></li><li><p>求值结束后，判断<code>Dep.target</code>是否存在，此刻是存在的，再把<code>Dep.target</code>即<code>渲染watcher</code>添加到<code>msg</code>的<code>dep</code>(属性订阅器)的<code>subs</code>中,最终<code>msg</code>的<code>dep</code>(属性订阅器)的<code>subs=[lazyWatcher,渲染watcher]</code></p></li></ol><p>至此属性<code>msg</code>的<code>dep</code>对象中的<code>subs</code>数组收集到了<code>lazyWatcher</code>和<code>渲染watcher</code>，这就是某个计算属性的依赖收集过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.evaluate = <span class="function"><span class="keyword">function</span> <span class="title">evaluate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    pushTarget(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>.vm;</span><br><span class="line">    value = <span class="built_in">this</span>.getter.call(vm, vm);</span><br><span class="line">    popTarget();</span><br><span class="line">    <span class="built_in">this</span>.cleanupDeps();</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="创建虚拟dom"><a href="#创建虚拟dom" class="headerlink" title="创建虚拟dom"></a>创建虚拟dom</h2><p>根据上面的分析，我们知道在触发<code>vm._render</code>函数时，会收集依赖，其实<code>vm._render</code>函数还有另外一个作用：创建虚拟dom，这就要说到生成的<code>render</code>函数里用到的辅助函数<code>_c</code>了，它是用来创建虚拟的元素节点，我们看看函数内部的逻辑：</p><ol><li>执行<code>createElement</code>函数，作用是参数重载，用来确保data存节点的属性，children存子节点</li><li>执行<code>_createElement</code>函数，该函数作用有三：<br> 2.1 处理传入的<code>children</code>子节点，<br> 2.2 处理原生html标签如<code>div,p</code>，并使用 <code>new VNode()</code>来创建标签对应的虚拟dom<br> 2.3 处理自定义组件，并使用<code>createComponent</code>来创建组件对应的虚拟dom(后面讲Vue组件系统时会讲到)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vm._c = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c, d</span>) </span>&#123; <span class="keyword">return</span> createElement(vm, a, b, c, d, <span class="literal">false</span>); &#125;;</span><br><span class="line"><span class="comment">// 参数重载 保证data存属性  children存子节点的顺序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">context,tag,data,children,normalizationType,alwaysNormalize </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data) || isPrimitive(data)) &#123;</span><br><span class="line">        normalizationType = children;</span><br><span class="line">        children = data;</span><br><span class="line">        data = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isTrue(alwaysNormalize)) &#123;</span><br><span class="line">        normalizationType = ALWAYS_NORMALIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _createElement(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createElement</span>(<span class="params">context,tag,data,children,normalizationType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">      children = normalizeChildren(children);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">      children = simpleNormalizeChildren(children);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> vnode;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> Ctor;</span><br><span class="line">        <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">            <span class="comment">// platform built-in elements</span></span><br><span class="line">            vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">            config.parsePlatformTagName(tag), data, children,</span><br><span class="line">            <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">            <span class="comment">// component</span></span><br><span class="line">            vnode = createComponent(Ctor, data, context, children, tag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Vue内部创建好虚拟dom后，就会把虚拟dom交给<code>vm._update</code>处理，我们看看这个函数内部的逻辑：</p><ol><li><code>prevEl</code>存储组件的挂载点(真实dom)</li><li><code>prevVnode</code>存储上次生成的虚拟dom，对于首次触发<code>_update</code>函数来说，<code>prevVnode</code>为<code>undefined</code></li><li><code>vm._vnode</code>存储本次生成的虚拟dom</li></ol><p>显然首次触发<code>_update</code>函数时，会走进if，从而触发<code>vm.__patch__</code>函数并传入<code>vm.$el</code>和<code>vnode</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode, hydrating</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> prevEl = vm.$el;</span><br><span class="line">    <span class="keyword">var</span> prevVnode = vm._vnode;</span><br><span class="line">    vm._vnode = vnode;</span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">        <span class="comment">// initial render</span></span><br><span class="line">        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// updates</span></span><br><span class="line">        vm.$el = vm.__patch__(prevVnode, vnode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="创建真实dom"><a href="#创建真实dom" class="headerlink" title="创建真实dom"></a>创建真实dom</h2><h3 id="vm-patch"><a href="#vm-patch" class="headerlink" title="vm.patch"></a>vm.<strong>patch</strong></h3><p>接下来，我们看看<code>vm.__patch__</code>函数的实现：</p><ol><li>判断<code>oldVnode</code>是不是真实的dom节点，如果是真实节点，那就说明是因为首次挂载组件触发<code>patch</code>函数的，那就使用<code>createElm</code>来创建真实dom</li><li>如果不是元素节点，那就说明是因为组件更新触发<code>patch</code>函数的，那就使用<code>patchVnode</code>来比对更新前后的虚拟dom。<br>对于首次触发<code>patch</code>函数时，因为<code>oldVnode</code>是真实节点，所以会走进else语句，最终触发<code>createElm</code>函数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode, vnode</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isRealElement = isDef(oldVnode.nodeType);</span><br><span class="line">    <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// patch existing root node</span></span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">            oldVnode = emptyNodeAt(oldVnode);</span><br><span class="line">            <span class="keyword">var</span> oldElm = oldVnode.elm;</span><br><span class="line">            <span class="keyword">var</span> parentElm = nodeOps.parentNode(oldElm);</span><br><span class="line">            <span class="comment">// create new node</span></span><br><span class="line">            createElm(</span><br><span class="line">                vnode,</span><br><span class="line">                insertedVnodeQueue,</span><br><span class="line">                oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">                nodeOps.nextSibling(oldElm)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="createElm"><a href="#createElm" class="headerlink" title="createElm"></a>createElm</h3><p>Vue内部是使用<code>createElm</code>函数来根据虚拟dom创建真实dom的，我们看看内部的处理:</p><ol><li>如果虚拟dom里有组件，那就创建组件(这里没有组件，后面在讲Vue组件系统会讲到)</li><li>把<code>vnode</code>及其子节点<code>children</code>放到<code>createChildren</code>函数中处理，生成子节点对应的真实dom。</li><li>最终把生成的子节点插入到父节点<code>parentElm</code>中</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span>(<span class="params"> vnode,insertedVnodeQueue,parentElm,refElm </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> data = vnode.data;</span><br><span class="line">    <span class="keyword">var</span> children = vnode.children;</span><br><span class="line">    <span class="keyword">var</span> tag = vnode.tag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDef(tag)) &#123;</span><br><span class="line">        vnode.elm = nodeOps.createElement(tag, vnode);</span><br><span class="line">        createChildren(vnode, children );</span><br><span class="line">        insert(parentElm, vnode.elm, refElm);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isTrue(vnode.isComment)) &#123;</span><br><span class="line">        vnode.elm = nodeOps.createComment(vnode.text);</span><br><span class="line">        insert(parentElm, vnode.elm, refElm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode.elm = nodeOps.createTextNode(vnode.text);</span><br><span class="line">        insert(parentElm, vnode.elm, refElm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createChildren</span>(<span class="params">vnode, children, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">        checkDuplicateKeys(children);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">            createElm(children[i], insertedVnodeQueue, vnode.elm, <span class="literal">null</span>, <span class="literal">true</span>, children, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，就是Vue内部从挂载组件到生成真实dom的全部过程。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现express的洋葱模型</title>
      <link href="2020/12/11/express01/"/>
      <url>2020/12/11/express01/</url>
      
        <content type="html"><![CDATA[<h2 id="Layer-js"><a href="#Layer-js" class="headerlink" title="Layer.js"></a>Layer.js</h2><h3 id="express-js"><a href="#express-js" class="headerlink" title="express.js"></a>express.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> CreateApplication()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="CreateApplication-js"><a href="#CreateApplication-js" class="headerlink" title="CreateApplication.js"></a>CreateApplication.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateApplication</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._router = <span class="keyword">new</span> Router()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">path, ...handlers</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._router.get(path, handlers)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">post</span>(<span class="params">path, ...handlers</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._router.post(path, handlers)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">use</span>(<span class="params">path, ...handlers</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._router.use(path, handlers)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">listen</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">      res.end(<span class="string">`Cannot <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.url&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._router.handle(req, res, done)</span><br><span class="line">    &#125;).listen(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Router-js"><a href="#Router-js" class="headerlink" title="Router.js"></a>Router.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stacks = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">path, handlers</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> layer = <span class="keyword">new</span> Layer(path, <span class="string">&#x27;get&#x27;</span>, handlers)</span><br><span class="line">    <span class="built_in">this</span>.stacks.push(layer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">post</span>(<span class="params">path, handlers</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> layer = <span class="keyword">new</span> Layer(path, <span class="string">&#x27;post&#x27;</span>, handlers)</span><br><span class="line">    <span class="built_in">this</span>.stacks.push(layer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">use</span>(<span class="params">path, handlers</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> layer = <span class="keyword">new</span> Layer(path, <span class="string">&#x27;use&#x27;</span>, handlers)</span><br><span class="line">    <span class="built_in">this</span>.stacks.push(layer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handle</span>(<span class="params">req, res, done</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; pathname &#125; = url.parse(req.url)</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (idx &gt;= <span class="built_in">this</span>.stacks.length) <span class="keyword">return</span> done(req, res)</span><br><span class="line">        <span class="keyword">let</span> layer = <span class="built_in">this</span>.stacks[idx++]</span><br><span class="line">        <span class="keyword">const</span> &#123; method &#125; = layer</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">          pathname === layer.path &amp;&amp; (method === req.method.toLowerCase() || method === <span class="string">&#x27;use&#x27;</span>)</span><br><span class="line">      ) &#123;</span><br><span class="line">        layer.dispatch(req, res, next)<span class="comment">//触发内层</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next() <span class="comment">//触发外层</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Layer-js-1"><a href="#Layer-js-1" class="headerlink" title="Layer.js"></a>Layer.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">path, method, handlers</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stacks = []</span><br><span class="line">    <span class="built_in">this</span>.method = method</span><br><span class="line">    <span class="built_in">this</span>.path = path</span><br><span class="line">    <span class="built_in">this</span>.stacks.push(...handlers)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">dispatch</span>(<span class="params">req, res, out</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> next = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (idx &gt;= <span class="built_in">this</span>.stacks.length) <span class="keyword">return</span> out()</span><br><span class="line">      <span class="keyword">let</span> handler = <span class="built_in">this</span>.stacks[idx++]</span><br><span class="line">      handler(req, res, next)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. Vue生成ast树后，发生了肾么事？</title>
      <link href="2020/12/06/vue03/"/>
      <url>2020/12/06/vue03/</url>
      
        <content type="html"><![CDATA[<p>Vue 生成了 ast 语法树之后，还对这个树结构进行了静态标记，之所以给 ast 树打上是否是静态的标记，是因为在后面 diff 算法的时候，直接跳过静态的节点，可以节省 diff 的开销。下面我们看看是怎么给节点打静态标记的吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ast = parse(template.trim(), options);</span><br><span class="line"><span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">  optimize(ast, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">optimize</span>(<span class="params">root, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  isStaticKey = genStaticKeysCached(options.staticKeys || <span class="string">&quot;&quot;</span>);</span><br><span class="line">  isPlatformReservedTag = options.isReservedTag || no;</span><br><span class="line">  <span class="comment">// 给节点打上是否是静态节点的标记</span></span><br><span class="line">  markStatic$<span class="number">1</span>(root);</span><br><span class="line">  <span class="comment">// 给节点打上是否是静态根节点的标记</span></span><br><span class="line">  markStaticRoots(root, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，markStatic$1 函数是给节点打上是否是静态节点的标记，markStaticRoots 函数是给节点打上是否是静态根节点的标记，我们先看看 markStatic$1 函数内部的逻辑，其实核心 isStatic 函数，这个函数是判断节点是否是静态节点。判断的逻辑大致如下</p><ol><li>如果是插值文本 那就不是静态节点</li><li>如果是普通文本 那就是静态节点</li><li>有跳过编译的指令 pre 那就是静态节点</li><li>没有属性绑定&amp;有 if for&amp;不是 Vue 内置标签等 那就是静态节点</li></ol><p>在经过上面判断出这个节点是否是静态节点，如果是那就给这个节点在加上<code>static:true</code>标记，当然这还没结束，接着还会在遍历这个节点的子节点们，判断子节点是否是静态节点，一旦某个子节点不是静态节点，那就给这个节点<br>打上<code>static:false</code>标记</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStatic$1</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  node.static = isStatic(node);</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> child = node.children[i];</span><br><span class="line">      markStatic$<span class="number">1</span>(child);</span><br><span class="line">      <span class="keyword">if</span> (!child.static) &#123;</span><br><span class="line">        node.static = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isStatic</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// expression</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// text</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !!(</span><br><span class="line">    node.pre ||</span><br><span class="line">    (!node.hasBindings &amp;&amp; <span class="comment">// no dynamic bindings</span></span><br><span class="line">      !node.if &amp;&amp;</span><br><span class="line">      !node.for &amp;&amp; <span class="comment">// not v-if or v-for or v-else</span></span><br><span class="line">      !isBuiltInTag(node.tag) &amp;&amp; <span class="comment">// not a built-in</span></span><br><span class="line">      isPlatformReservedTag(node.tag) &amp;&amp; <span class="comment">// not a component</span></span><br><span class="line">      !isDirectChildOfTemplateFor(node) &amp;&amp;</span><br><span class="line">      <span class="built_in">Object</span>.keys(node).every(isStaticKey))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再看看 markStaticRoots 函数的逻辑,判断节点是否是静态根节点的逻辑大致如下</p><ol><li>如果是该节点是静态节点，并且这个节点的子节点长度大于 1，那这个节点就是静态根节点</li><li>不满足上述条件，则这个节点就不是静态根节点<br>在经过上面判断出这个节点是否是静态根节点，如果是那就给这个节点在加上<code>staticRoot:true</code>标记，当然这还没结束，接着还会在遍历这个节点的子节点们，判断子节点是否是静态根节点，最后给子节点们打上 staticRoot 标记</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStaticRoots</span>(<span class="params">node, isInFor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// For a node to qualify as a static root, it should have children that</span></span><br><span class="line">    <span class="comment">// are not just static text. Otherwise the cost of hoisting out will</span></span><br><span class="line">    <span class="comment">// outweigh the benefits and it&#x27;s better off to just always render it fresh.</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      node.static &amp;&amp;</span><br><span class="line">      node.children.length &amp;&amp;</span><br><span class="line">      !(node.children.length === <span class="number">1</span> &amp;&amp; node.children[<span class="number">0</span>].type === <span class="number">3</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      node.staticRoot = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.staticRoot = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.children) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">        markStaticRoots(node.children[i], isInFor || !!node.for);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终 Vue 就处理好了 ast 树，接着会基于 ast 树生成代码，,这里使用到了 generate 函数，generate 这个函数内部的逻辑大致是:</p><ol><li>genElement 函数内部创建节点对应的代码存到 data 中</li><li>genChildren 函数内部创建节点的子节点对应的代码存到 children 中</li><li>最终基于 data 和 children 拼接成最终的 code，其中如果节点有 if for once 等指令，会转换成特殊的代码</li><li>如果是静态根节点，就生成代码并存到 staticRenderFns 中<br>值得注意的是，我们在下面代码中可以得到结论：v-for 的优先级比 v-if 的优先级<br>因为 generate 函数内部是先处理 el.for，再处理 el.if 的。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ast = parse(template.trim(), options);</span><br><span class="line"><span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">  optimize(ast, options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> code = generate(ast, options);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">ast, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="keyword">new</span> CodegenState(options);</span><br><span class="line">  <span class="keyword">var</span> code = ast ? genElement(ast, state) : <span class="string">&#x27;_c(&quot;div&quot;)&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render: <span class="string">&quot;with(this)&#123;return &quot;</span> + code + <span class="string">&quot;&#125;&quot;</span>,</span><br><span class="line">    staticRenderFns: state.staticRenderFns,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genElement</span>(<span class="params">el, state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.parent) &#123;</span><br><span class="line">    el.pre = el.pre || el.parent.pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;</span><br><span class="line">    <span class="keyword">return</span> genStatic(el, state);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.once &amp;&amp; !el.onceProcessed) &#123;</span><br><span class="line">    <span class="keyword">return</span> genOnce(el, state);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.for &amp;&amp; !el.forProcessed) &#123;</span><br><span class="line">    <span class="keyword">return</span> genFor(el, state);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.if &amp;&amp; !el.ifProcessed) &#123;</span><br><span class="line">    <span class="keyword">return</span> genIf(el, state);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.tag === <span class="string">&quot;template&quot;</span> &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123;</span><br><span class="line">    <span class="keyword">return</span> genChildren(el, state) || <span class="string">&quot;void 0&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.tag === <span class="string">&quot;slot&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> genSlot(el, state);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// component or element</span></span><br><span class="line">    <span class="keyword">var</span> code;</span><br><span class="line">    <span class="keyword">if</span> (el.component) &#123;</span><br><span class="line">      code = genComponent(el.component, el, state);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> data;</span><br><span class="line">      <span class="keyword">if</span> (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) &#123;</span><br><span class="line">        data = genData$<span class="number">2</span>(el, state);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> children = el.inlineTemplate ? <span class="literal">null</span> : genChildren(el, state, <span class="literal">true</span>);</span><br><span class="line">      code =</span><br><span class="line">        <span class="string">&quot;_c(&#x27;&quot;</span> +</span><br><span class="line">        el.tag +</span><br><span class="line">        <span class="string">&quot;&#x27;&quot;</span> +</span><br><span class="line">        (data ? <span class="string">&quot;,&quot;</span> + data : <span class="string">&quot;&quot;</span>) +</span><br><span class="line">        (children ? <span class="string">&quot;,&quot;</span> + children : <span class="string">&quot;&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// module transforms</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; state.transforms.length; i++) &#123;</span><br><span class="line">      code = state.transforms[i](el, code);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出的 code 为下图，其中 render 为可执行的字符串，staticRenderFns 为静态节点字符串</p><img src="/images/code.png" ><p>生成 code 之后，接下来的处理是在 compileToFunctions 函数中,大致逻辑是：</p><ol><li>定义 cache 缓存对象</li><li>compile 函数返回的是 code 对象,即 compiled-&gt;code 对象</li><li>基于 render/staticRenderFns 创建函数</li><li>返回 res 对象，并将 key-&gt;res 存到缓存对象中,这个是 vue 的优化策略，当第二次再次编译同样的模版时，会直接取出 render/staticRenderFns，不会重复编译出 render/staticRenderFns，这样在多次使用组件时，就可以极大的节省浏览器开销</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileToFunctions</span>(<span class="params">template, options, vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">//  此时省略很多代码</span></span><br><span class="line">  <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译模版</span></span><br><span class="line">  <span class="keyword">var</span> compiled = compile(template, options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> fnGenErrors = [];</span><br><span class="line">  res.render = createFunction(compiled.render, fnGenErrors);</span><br><span class="line">  res.staticRenderFns = compiled.staticRenderFns.map(<span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createFunction(code, fnGenErrors);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (cache[key] = res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunction</span>(<span class="params">code, errors</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此 Vue 编译模版终于结束了，过程是从 html 字符串-&gt;ast 语法树-&gt;code 对象-&gt;render 函数。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js小技巧</title>
      <link href="2020/12/03/js%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
      <url>2020/12/03/js%E9%AA%9A%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="金额格式化"><a href="#金额格式化" class="headerlink" title="金额格式化"></a>金额格式化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1:</span></span><br><span class="line"><span class="keyword">let</span> result = num.toLocaleString(); <span class="comment">// 1,000,000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2:</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/(?=(\B)(\d&#123;3&#125;)+$)/g</span>;</span><br><span class="line"><span class="keyword">let</span> result = num.toString().replace(reg, <span class="string">&quot;,&quot;</span>); <span class="comment">// 1,000,000</span></span><br></pre></td></tr></table></figure><h3 id="交换值"><a href="#交换值" class="headerlink" title="交换值"></a>交换值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1:</span></span><br><span class="line">b = [a, (a = b)][<span class="number">0</span>]; <span class="comment">//a=1 b=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b; <span class="comment">//a=1 b=2</span></span><br></pre></td></tr></table></figure><h3 id="暂无标题"><a href="#暂无标题" class="headerlink" title="暂无标题"></a>暂无标题</h3><p>key 为假值，则没有该属性，key 为真值，则添加该属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> objX = &#123; ...(x &amp;&amp; &#123; x &#125;) &#125;; <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> objY = &#123; ...(y &amp;&amp; &#123; y &#125;) &#125;; <span class="comment">// &#123;y:1&#125;</span></span><br></pre></td></tr></table></figure><h3 id="proxy-构建响应式系统"><a href="#proxy-构建响应式系统" class="headerlink" title="proxy 构建响应式系统"></a>proxy 构建响应式系统</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> origin === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> origin !== <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myReact</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">origin, key, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;依赖收集&quot;</span>);</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(origin, key, receiver);</span><br><span class="line">      <span class="keyword">return</span> isObject(res) ? myReact(res) : res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">origin, key, value, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;视图更新&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(origin, key, value, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;heaven&quot;</span>,</span><br><span class="line">  age: <span class="number">28</span>,</span><br><span class="line">  hobby: [<span class="string">&quot;cycle&quot;</span>, <span class="string">&quot;eat&quot;</span>],</span><br><span class="line">  friend: &#123; <span class="attr">name</span>: <span class="string">&quot;666&quot;</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> res = myReact(person);</span><br><span class="line">res.hobby.push(<span class="string">&quot;run&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="统计页面停留时间"><a href="#统计页面停留时间" class="headerlink" title="统计页面停留时间"></a>统计页面停留时间</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;visibilitychange&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;用户离开页面了&quot;</span>, <span class="string">`用户停留<span class="subst">$&#123;(now - start) / <span class="number">1000</span>&#125;</span>s`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;用户进入页面了&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="监视-dom-元素进入可视区"><a href="#监视-dom-元素进入可视区" class="headerlink" title="监视 dom 元素进入可视区"></a>监视 dom 元素进入可视区</h3><p>可应用于懒加载，监视图片进入视区，就去加载图片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dom = <span class="built_in">document</span>.getElementById(<span class="string">&quot;dom&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">  entries.forEach(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;entry.isIntersecting ? <span class="string">&quot;进入视区&quot;</span> : <span class="string">&quot;离开视区&quot;</span>&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">observer.observe(dom);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. Vue如何编译模版?</title>
      <link href="2020/12/01/vue02/"/>
      <url>2020/12/01/vue02/</url>
      
        <content type="html"><![CDATA[<p>Vue上手非常简单，因为我们可以直接编写html作为组件的模版，对比学习React还需要接触<code>jsx</code>语法，Vue对新手可以说是非常友好了，接下来我们看看vue是如何处理template模版的？</p><h2 id="Vue编译器入口"><a href="#Vue编译器入口" class="headerlink" title="Vue编译器入口"></a>Vue编译器入口</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createCompiler = createCompilerCreator(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span>(<span class="params">template, options</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// template -&gt; ast   对template的第一层抽象</span></span><br><span class="line">        <span class="keyword">var</span> ast = parse(template.trim(), options);</span><br><span class="line">        <span class="comment">// 优化ast树 标注静态节点</span></span><br><span class="line">        <span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">            optimize(ast, options);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ast -&gt; 可执行code  对template的第二层抽象</span></span><br><span class="line">        <span class="keyword">var</span> code = generate(ast, options);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ast: ast,</span><br><span class="line">            render: code.render,</span><br><span class="line">            staticRenderFns: code.staticRenderFns</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>可以看到首先是template模版放到parse函数中处理，得到ast对象(abstract syntax tree)，其实ast对象是对template的第一层抽象，template模版本质上是一个html字符串，现在用ast对象来描述template模版，接下来看看html字符串如何被转换成ast对象的？假定template模版如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html模版</span></span><br><span class="line"><span class="keyword">let</span> template = <span class="string">`</span></span><br><span class="line"><span class="string">     &lt;div id=app v-if=&#x27;msg&#x27; v-for=&#x27;item in 3&#x27; v-once:click=&#x27;handleClick&#x27;&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&#x27;text&#x27; title=&#x27;heaven&#x27;&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">        <span class="comment">// 解析到开始标签的钩子函数</span></span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        <span class="comment">//  解析到结束标签的钩子函数</span></span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        <span class="comment">// 解析到文本的钩子函数</span></span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="parseHTML-编译模版"><a href="#parseHTML-编译模版" class="headerlink" title="parseHTML 编译模版"></a>parseHTML 编译模版</h2><p>可以看到真正处理template的是parseHTML这个函数，我们看看这个函数内部的逻辑是什么？其实大致有4步</p><ol><li>定义token，这些token用来解析开始标签 标签属性 结束标签等</li><li>处理开始标签，并把处理的结果交给handleStartTag处理</li><li>处理结束标签，并把处理的结果交给parseEndTag处理</li><li>处理文本，并把文本交给chars钩子函数处理<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  解析属性的token id=&#x27;app&#x27;</span></span><br><span class="line"><span class="keyword">var</span> attribute = <span class="regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span>;</span><br><span class="line"><span class="keyword">var</span> ncname = <span class="string">&quot;[a-zA-Z_][\\-\\.0-9_a-zA-Z&quot;</span> + (unicodeRegExp.source) + <span class="string">&quot;]*&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> qnameCapture = <span class="string">&quot;((?:&quot;</span> + ncname + <span class="string">&quot;\\:)?&quot;</span> + ncname + <span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="comment">// 解析开始标签的token &lt;div </span></span><br><span class="line"><span class="keyword">var</span> startTagOpen = <span class="keyword">new</span> <span class="built_in">RegExp</span>((<span class="string">&quot;^&lt;&quot;</span> + qnameCapture));</span><br><span class="line"><span class="comment">// 解析开始标签结束的token /&gt;  &gt;</span></span><br><span class="line"><span class="keyword">var</span> startTagClose = <span class="regexp">/^\s*(\/?)&gt;/</span>;</span><br><span class="line"><span class="comment">// 解析结束标签的token &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> endTag = <span class="keyword">new</span> <span class="built_in">RegExp</span>((<span class="string">&quot;^&lt;\\/&quot;</span> + qnameCapture + <span class="string">&quot;[^&gt;]*&gt;&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseHTML</span>(<span class="params">html, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (html) &#123;</span><br><span class="line">        <span class="keyword">var</span> textEnd = html.indexOf(<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">        <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">        <span class="comment">// 处理开始标签</span></span><br><span class="line">        <span class="keyword">var</span> startTagMatch = parseStartTag();</span><br><span class="line">        <span class="keyword">if</span> (startTagMatch) &#123;</span><br><span class="line">            handleStartTag(startTagMatch);</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理结束标签</span></span><br><span class="line">        <span class="keyword">var</span> endTagMatch = html.match(endTag);</span><br><span class="line">        <span class="keyword">if</span> (endTagMatch) &#123;</span><br><span class="line">            <span class="keyword">var</span> curIndex = index;</span><br><span class="line">            advance(endTagMatch[<span class="number">0</span>].length);</span><br><span class="line">            parseEndTag(endTagMatch[<span class="number">1</span>], curIndex, index);</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理文本 包括静态文本和插值</span></span><br><span class="line">        <span class="keyword">var</span> text </span><br><span class="line">        <span class="keyword">if</span> (textEnd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">            text = html.substring(<span class="number">0</span>, textEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (text) advance(text.length);</span><br><span class="line">        <span class="keyword">if</span> (options.chars &amp;&amp; text) &#123;</span><br><span class="line">            options.chars(text, index - text.length, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析开始标签"><a href="#解析开始标签" class="headerlink" title="解析开始标签"></a>解析开始标签</h2>接下来，我们看看parseStartTag函数是如何处理开始标签的？<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制全局的index/html向前移动n</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">advance</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    index += n;</span><br><span class="line">    html = html.substring(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseStartTag</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 解析到开始标签</span></span><br><span class="line">    <span class="keyword">var</span> start = html.match(startTagOpen);</span><br><span class="line">    <span class="keyword">if</span> (start) &#123;</span><br><span class="line">        <span class="keyword">var</span> match = &#123;</span><br><span class="line">            tagName: start[<span class="number">1</span>], </span><br><span class="line">            attrs: [],</span><br><span class="line">            start: index</span><br><span class="line">        &#125;;</span><br><span class="line">        advance(start[<span class="number">0</span>].length);</span><br><span class="line">        <span class="keyword">var</span> end, attr;</span><br><span class="line">        <span class="keyword">while</span> (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(dynamicArgAttribute) || html.match(attribute))) &#123;</span><br><span class="line">            attr.start = index;</span><br><span class="line">            advance(attr[<span class="number">0</span>].length);</span><br><span class="line">            attr.end = index;</span><br><span class="line">            match.attrs.push(attr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end) &#123;</span><br><span class="line">            match.unarySlash = end[<span class="number">1</span>];</span><br><span class="line">            advance(end[<span class="number">0</span>].length);</span><br><span class="line">            match.end = index;</span><br><span class="line">            <span class="keyword">return</span> match</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>最终开始标签<code>&lt;div id=&#39;app&#39;&gt;</code>被解析成下面的结构，其中attrs里面存放开始标签的属性集合，start是开始标签的起始位置，end是开始标签的结束位置，tagName是开始标签的标签类型，unarySlash为空代表标签为双标签，这样开始标签所有信息都被这个对象完美描述了，下面是match的结构图<img src="/images/start.png" width="300px" ></li></ol><p>接下来，开始标签的处理结果match还需要交给handleStartTag处理，我们看看handleStartTag内部的逻辑，其实也是很清晰的</p><ol><li>处理attrs属性，最终把标签的属性改成key:value的形式，并且标记attrs内部的属性开始和结束位置</li><li>将开始标签的信息放到stack栈中</li><li>触发start钩子函数<br>值的注意的是value值为<code>args[3] || args[4] || args[5]</code>,这是怎么回事呢？<br>这是因为对于属性值的三种形式<code>&lt;div id=&quot;app&quot;&gt;</code> app可以是单引号，双引号，不加引号，分别对应<code>args[3] || args[4] || args[5]</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStartTag</span>(<span class="params">match</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> tagName = match.tagName;</span><br><span class="line">      <span class="keyword">var</span> unarySlash = match.unarySlash;</span><br><span class="line">      <span class="keyword">var</span> unary = isUnaryTag$$1(tagName) || !!unarySlash;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> l = match.attrs.length;</span><br><span class="line">      <span class="keyword">var</span> attrs = <span class="keyword">new</span> <span class="built_in">Array</span>(l);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> args = match.attrs[i];</span><br><span class="line">        <span class="keyword">var</span> value = args[<span class="number">3</span>] || args[<span class="number">4</span>] || args[<span class="number">5</span>] || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        attrs[i] = &#123;</span><br><span class="line">          name: args[<span class="number">1</span>],</span><br><span class="line">          value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (options.outputSourceRange) &#123;</span><br><span class="line">          attrs[i].start = args.start + args[<span class="number">0</span>].match(<span class="regexp">/^\s*/</span>).length;</span><br><span class="line">          attrs[i].end = args.end;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理双标签</span></span><br><span class="line">      <span class="keyword">if</span> (!unary) &#123;</span><br><span class="line">        stack.push(&#123; <span class="attr">tag</span>: tagName, <span class="attr">lowerCasedTag</span>: tagName.toLowerCase(), <span class="attr">attrs</span>: attrs, <span class="attr">start</span>: match.start, <span class="attr">end</span>: match.end &#125;);</span><br><span class="line">        lastTag = tagName;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (options.start) &#123;</span><br><span class="line">        options.start(tagName, attrs, unary, match.start, match.end);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到Vue把数据做了处理之后，又把这些数据交给了start钩子处理，我们看看start钩子里面的逻辑<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createASTElement</span>(<span class="params">tag,attrs,parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="number">1</span>,</span><br><span class="line">      tag: tag,</span><br><span class="line">      attrsList: attrs,</span><br><span class="line">      attrsMap: makeAttrsMap(attrs),</span><br><span class="line">      rawAttrsMap: &#123;&#125;,</span><br><span class="line">      parent: parent,</span><br><span class="line">      children: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">tag, attrs, unary, start$<span class="number">1</span>, end</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> element = createASTElement(tag, attrs, currentParent);</span><br><span class="line">            <span class="keyword">if</span> (options.outputSourceRange) &#123;</span><br><span class="line">                element.start = start$<span class="number">1</span>;</span><br><span class="line">                element.end = end;</span><br><span class="line">                element.rawAttrsMap = element.attrsList.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">cumulated, attr</span>) </span>&#123;</span><br><span class="line">                    cumulated[attr.name] = attr;</span><br><span class="line">                    <span class="keyword">return</span> cumulated</span><br><span class="line">                &#125;, &#123;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理v-for v-if指令</span></span><br><span class="line">            <span class="keyword">if</span> (!element.processed) &#123;</span><br><span class="line">                processFor(element);  </span><br><span class="line">                processIf(element);</span><br><span class="line">                processOnce(element);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解析到的第一个元素 就是根节点</span></span><br><span class="line">            <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">                root = element;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  如果是双标签 那currentParent就指定当前的ast元素，并存到stack栈中</span></span><br><span class="line">            <span class="keyword">if</span> (!unary) &#123;</span><br><span class="line">                currentParent = element;</span><br><span class="line">                stack.push(element);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                closeElement(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其实start钩子内部大致就做了三件事：</li><li>根据createASTElement生成一个ast元素，该ast元素也是用来描述开始标签，虽然match也用来描述开始标签，但是JS操作ast元素显然更方便些。</li><li>处理开始标签上面的v-if v-for v-once指令 </li><li>初始化root currentParent stack的值，其中root存储模版的根节点，currentParent指定当前解析到的ast元素，stack存放解析到的所有ast元素<br>下面是开始标签对应ast元素的结构图:</li></ol><img src="/images/ast.png" width="600px" ><h2 id="解析字符文本"><a href="#解析字符文本" class="headerlink" title="解析字符文本"></a>解析字符文本</h2><p>以上就是Vue内部解析开始标签的所有过程了，接下来我们再看看Vue内部如何解析文本的？,根据上面的分析，我们已经知道解析到文本会交给chars钩子处理，我们来看看chars钩子内部的逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        <span class="comment">// 解析到文本的钩子函数</span></span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span> (<span class="params">text, start, end</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> children = currentParent.children;</span><br><span class="line">            <span class="keyword">var</span> res;</span><br><span class="line">            <span class="keyword">var</span> child;</span><br><span class="line">            <span class="comment">//   解析到有插值的文本</span></span><br><span class="line">            <span class="keyword">if</span> (!inVPre &amp;&amp; text !== <span class="string">&#x27; &#x27;</span> &amp;&amp; (res = parseText(text, delimiters))) &#123;</span><br><span class="line">                child = &#123;</span><br><span class="line">                    type: <span class="number">2</span>,</span><br><span class="line">                    expression: res.expression,</span><br><span class="line">                    tokens: res.tokens,</span><br><span class="line">                    text: text</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (text !== <span class="string">&#x27; &#x27;</span> || !children.length || children[children.length - <span class="number">1</span>].text !== <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析到没有插值的文本</span></span><br><span class="line">                child = &#123;</span><br><span class="line">                    type: <span class="number">3</span>,</span><br><span class="line">                    text: text</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chars钩子内部逻辑很简单，就是区分文本是否有插值符号，有插值符号的话ast对象type标记为2，并解析插值，没有插值就当作普通文本处理ast对象type标记为3。下面是插值文本对应的ast对象</p><img src="/images/char.png" width="300px" ><h2 id="解析结束标签"><a href="#解析结束标签" class="headerlink" title="解析结束标签"></a>解析结束标签</h2><p>最后我们再看看Vue内部解析结束标签的过程，,根据上面的分析，我们已经知道解析到结束标签会交给parseEndTag函数处理，来看看parseEndTag函数内部的逻辑。大致意思是取出stack栈中的最后一项，并将最后一项的tag，start，end交给end钩子处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseEndTag</span>(<span class="params">tagName, start, end</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> pos, lowerCasedTagName;</span><br><span class="line">      <span class="keyword">if</span> (start == <span class="literal">null</span>) &#123; start = index; &#125;</span><br><span class="line">      <span class="keyword">if</span> (end == <span class="literal">null</span>) &#123; end = index; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Find the closest opened tag of the same type</span></span><br><span class="line">      <span class="keyword">if</span> (tagName) &#123;</span><br><span class="line">        lowerCasedTagName = tagName.toLowerCase();</span><br><span class="line">        <span class="keyword">for</span> (pos = stack.length - <span class="number">1</span>; pos &gt;= <span class="number">0</span>; pos--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If no tag name is provided, clean shop</span></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Close all the open elements, up the stack</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = stack.length - <span class="number">1</span>; i &gt;= pos; i--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (options.end) &#123;</span><br><span class="line">            options.end(stack[i].tag, start, end);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Remove the open elements from the stack</span></span><br><span class="line">        stack.length = pos;</span><br><span class="line">        lastTag = pos &amp;&amp; stack[pos - <span class="number">1</span>].tag;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看end钩子函数的处理逻辑，大致意思是取出stack栈中最后一项element，接着又使用closeElement来构建elemenet这个ast对象的父子级关系，currentParent又指定stack栈中的最后一项。<br>需要注意的是parse函数里面的stack栈和parseHTML函数里面的stack栈不是一回事，parse函数里面的stack栈中存放的是ast对象，parseHTML函数里面的stack栈存放的是所有开始标签的信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">template,options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> root;</span><br><span class="line">    <span class="keyword">var</span> currentParent;</span><br><span class="line">    parseHTML(template, &#123;</span><br><span class="line">        start: <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        end: <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> element = stack[stack.length - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// pop stack</span></span><br><span class="line">            stack.length -= <span class="number">1</span>;</span><br><span class="line">            currentParent = stack[stack.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (options.outputSourceRange) &#123;</span><br><span class="line">                element.end = end$<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            closeElement(element);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 解析到文本的钩子函数</span></span><br><span class="line">        chars: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建ast对象的父子级关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeElement</span> (<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    currentParent.children.push(element);</span><br><span class="line">    element.parent = currentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终返回的root根元素就是最终的ast树。以上，就是Vue内部如何把一个html字符串转换成ast树的过程，我们看看ast树的结构,其中包含了父子级关系，if for directives等指令标记，节点自身的相关信息</p><img src="/images/asttree.png" width="600px" >]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Vue如何构建响应式系统?</title>
      <link href="2020/11/21/vue01/"/>
      <url>2020/11/21/vue01/</url>
      
        <content type="html"><![CDATA[<h2 id="响应式系统入口"><a href="#响应式系统入口" class="headerlink" title="响应式系统入口"></a>响应式系统入口</h2><p>vue2.x版本的响应系统入口是observe函数，先看下Vue内部的处理：</p><h3 id="observe-amp-Observer"><a href="#observe-amp-Observer" class="headerlink" title="observe &amp; Observer"></a>observe &amp; Observer</h3><ol><li>可以看到observe函数只检测数组和普通对象，并对数组和普通对象做了不同处理</li><li>Observer类的实例会有dep属性，该属性用来指向dep订阅器对象，注意：初始化时dep订阅器对象为空。dep属性的作用是什么？我们会在<code>Vue如何构建依赖关系</code>时讲到。 </li><li><code>def(value, &#39;__ob__&#39;, this)</code>其实就是给观测的数组/普通对象添加__ob__属性，值指向Observer的实例，__ob__属性的作用是什么？我们会在<code>Vue的更新策略</code>时讲到。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value, asRootData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ob;</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep(value);</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123; <span class="comment">//构建数组对象的响应式系统</span></span><br><span class="line">       protoAugment(value, arrayMethods);</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//构建普通对象的响应式系统</span></span><br><span class="line">      <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h2><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>可以看到构建数据对象data的响应式系统很简单，就是用<code>Object.defineProperty</code>给data的每个key都设置get/set钩子,用户每次获取值的时候例如<code>this.data.msg</code>，都会触发key的get钩子，设置新值的时候例如<code>this.data.msg=&#39;新的msg&#39;</code>，都会触发key的set钩子从而让视图更新，不过视图更新我们会在<code>Vue的更新策略</code>讨论,不管怎样，普通对象的响应式系统确实是通过<code> Object.defineProperty</code>这个API很轻易的构建出来了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Observer.prototype.walk = <span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive$$1(obj, keys[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive$$1</span>(<span class="params"> obj, key, val, customSetter, shallow </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep(key);</span><br><span class="line">    <span class="keyword">var</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">        <span class="comment">// TODO </span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">        <span class="comment">// 老值和新值相等 就终止函数</span></span><br><span class="line">        <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (customSetter) &#123;</span><br><span class="line">          customSetter();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getter &amp;&amp; !setter) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">          setter.call(obj, newVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 劫持新设置的值  </span></span><br><span class="line">        childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">        dep.notify(); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h3><p>还有一个问题，平时我们都是<code>this.msg</code>就可以获取data中的<code>msg</code>了，现在这个响应式系统只能通过<code>this.data.msg</code>拿到data中的<code>msg</code>。很显然，这个响应式系统并不完善，我们看看vue源码如何实现更完善的响应式系统的？</p><ol><li>把数据对象data数据对象存到<code>_data</code>中</li><li>触发proxy函数，proxy函数的功能就是每次访问<code>vm[key]</code>时都会返回<code>vm._data[key]</code>属性<br>以上就实现了更完善的响应式系统了。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = vm.$options.data;</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line">  <span class="keyword">var</span> i = keys.length;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    proxy(vm, <span class="string">&quot;_data&quot;</span>, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据代理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">target, sourceKey, key</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key]</span><br><span class="line">  &#125;;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[sourceKey][key] = val;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// vm.msg --&gt; vm._data.msg</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h2><p>普通对象的响应式系统已经构建完成了，我们接下来再看看数组对象是如何构建响应式系统的？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep(value);</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      protoAugment(value, arrayMethods);</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改隐式原型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span>(<span class="params">target, src</span>) </span>&#123;</span><br><span class="line">  target.__proto__ = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，当处理数组的时候会触发<code>protoAugment</code>函数把数组的隐式原型<code>__proto__</code>指向了<code>arrayMethods</code>,那<code>arrayMethods</code>是什么呢？看下面的代码可知：</p><ol><li><code>arrayMethods</code>是一个空对象，其隐式原型<code>__proto__</code>指向了<code>Array.prototype</code>，这样的话，在<code>arrayMethods</code>这个对象的原型链上就有了数组的所有方法了。</li><li>遍历<code>methodsToPatch</code>，给<code>arrayMethods</code>对象添加<code>push,pop,shift,unshift,splice,sort,reverse</code>这七个属性，值是mutator函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">var</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> methodsToPatch = [</span><br><span class="line">    <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 基于原型链获取数组原型上的方法</span></span><br><span class="line">    <span class="keyword">var</span> original = arrayProto[method];</span><br><span class="line">    <span class="comment">// 给arrayMethods对象设置method属性  即arrayMethods[&#x27;push&#x27;] = mutator  </span></span><br><span class="line">    def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> args = [], len = <span class="built_in">arguments</span>.length;</span><br><span class="line">      <span class="keyword">while</span> (len--) args[len] = <span class="built_in">arguments</span>[len];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> result = original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      <span class="keyword">var</span> ob = <span class="built_in">this</span>.__ob__;</span><br><span class="line">      <span class="keyword">var</span> inserted;</span><br><span class="line">      <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">          inserted = args;</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">          inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (inserted) &#123; ob.observeArray(inserted); &#125;</span><br><span class="line">      <span class="comment">// notify change</span></span><br><span class="line">      ob.dep.notify();</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/images/1.png" width="300px" ><p>可以看到，最终的<code>arrayMethods</code>就是上面的结构，它是一个对象，自身有7个属性，隐式原型上有所有的数组方法，想象一下，如果我们执行<code>this.list.push(2)</code>，就会沿着原型链找到<code>arrayMethods</code>对象上的<code>push</code>方法执行，即mutator函数，mutator函数内部的逻辑其实就是触发视图更新。这个我们在后面章节<code>Vue的更新策略</code>讨论 ，不管怎样，数组对象的响应式系统确实是通过延长数组对象的原型链构建出来了。</p><p>需要注意的是，对于数组，Vue只为<code>methodsToPatch</code>中的7个方法构建了响应式系统，对于其他的数组方法，Vue并没有构建响应式系统。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>以上，就是Vue如何为数组对象/普通对象构建响应式系统的过程。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存策略</title>
      <link href="2020/11/19/cache/"/>
      <url>2020/11/19/cache/</url>
      
        <content type="html"><![CDATA[<h4 id="当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。"><a href="#当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。" class="headerlink" title="当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。"></a>当浏览器再次访问同一个资源时，会触发浏览器的缓存策略，我们用node来观察下浏览器的缓存行为。</h4><h2 id="1-目录结构如下"><a href="#1-目录结构如下" class="headerlink" title="1.目录结构如下"></a>1.目录结构如下</h2><img src="/images/directry.png" width="300px" ><h2 id="2-首页结构"><a href="#2-首页结构" class="headerlink" title="2.首页结构"></a>2.首页结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- cache.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;data:image/ico;base64,aWNv&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>基于node学习浏览器缓存策略<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是服务首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-搭建服务"><a href="#3-搭建服务" class="headerlink" title="3.搭建服务"></a>3.搭建服务</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (request.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createStream(<span class="string">&#x27;./cache.html&#x27;</span>); </span><br><span class="line">        readStream.pipe(response) </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.test(request.url)) &#123;  </span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;./script.js&#x27;</span>);</span><br><span class="line">        readStream.pipe(response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-强缓存"><a href="#4-强缓存" class="headerlink" title="4.强缓存"></a>4.强缓存</h2><h4 id="触发浏览器强缓存策略需要后端配置特殊字段Expires-Cache-Control均可，并且返回状态码200"><a href="#触发浏览器强缓存策略需要后端配置特殊字段Expires-Cache-Control均可，并且返回状态码200" class="headerlink" title="触发浏览器强缓存策略需要后端配置特殊字段Expires/Cache-Control均可，并且返回状态码200"></a>触发浏览器强缓存策略需要后端配置特殊字段Expires/Cache-Control均可，并且返回状态码200</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (request.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createStream(<span class="string">&#x27;./cache.html&#x27;</span>); </span><br><span class="line">        readStream.pipe(response) </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.test(request.url)) &#123;  </span><br><span class="line">        <span class="comment">// Expires字段设置的时间是固定的某个时间点</span></span><br><span class="line">        <span class="comment">// response.writeHead(200, &#123; </span></span><br><span class="line">        <span class="comment">//     &#x27;Expires&#x27;: new Date(&#x27;2020-12-30 12:00:00&#x27;),</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="comment">// Cache-Control字段设置的是相对于本次服务端返回的时间 单位s</span></span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">           <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=200&#x27;</span>   </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;./script.js&#x27;</span>);</span><br><span class="line">        readStream.pipe(response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一次访问资源命中强缓存之后，浏览器就不会同样的资源发起网络请求了，浏览器会直接强制从memory(内存)/disk(硬盘)中读取资源，如下所示<br><img src="/images/image.png"></p><h2 id="5-协商缓存"><a href="#5-协商缓存" class="headerlink" title="5.协商缓存"></a>5.协商缓存</h2><h4 id="触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified-Etag均可，并且返回状态码304"><a href="#触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified-Etag均可，并且返回状态码304" class="headerlink" title="触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified/Etag均可，并且返回状态码304"></a>触发浏览器协商缓存策略需要后端配置特殊字段Last-Modified/Etag均可，并且返回状态码304</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (request.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createStream(<span class="string">&#x27;./cache.html&#x27;</span>);   </span><br><span class="line">        readStream.pipe(response) </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.test(request.url)) &#123;  </span><br><span class="line">        <span class="comment">// const buffer = fs.readFileSync(&#x27;./script.js&#x27;);</span></span><br><span class="line">        <span class="comment">// const fileMd5 = md5(buffer); 文件的md5值</span></span><br><span class="line">        <span class="comment">// const noneMatch = request.headers[&#x27;if-none-match&#x27;]; 来自浏览器端传递的值</span></span><br><span class="line">        <span class="comment">// 协商成功 状态码返回304</span></span><br><span class="line">        <span class="comment">// if (noneMatch === fileMd5) &#123;</span></span><br><span class="line">        <span class="comment">//     response.statusCode = 304;</span></span><br><span class="line">        <span class="comment">//     response.end();</span></span><br><span class="line">        <span class="comment">//     return;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 协商失败 状态码返回200</span></span><br><span class="line">        <span class="comment">// response.writeHead(200, &#123;</span></span><br><span class="line">        <span class="comment">//     &#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;,</span></span><br><span class="line">        <span class="comment">//     &#x27;ETag&#x27;: fileMd5,</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="keyword">const</span> stat = fs.statSync(<span class="string">&#x27;./script.js&#x27;</span>); </span><br><span class="line">        <span class="keyword">const</span> mtime = stat.mtime.toGMTString() </span><br><span class="line">        <span class="keyword">const</span> requestMtime = request.headers[<span class="string">&#x27;if-modified-since&#x27;</span>]; </span><br><span class="line">        <span class="comment">// 协商成功  本次服务端不返回资源  让浏览器使用缓存的资源</span></span><br><span class="line">        <span class="keyword">if</span> (mtime === requestMtime) &#123;</span><br><span class="line">            response.statusCode = <span class="number">304</span>; <span class="comment">//必须返回304</span></span><br><span class="line">            response.end();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 协商失败 状态码返回200</span></span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;Last-Modified&#x27;</span>: mtime,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>, <span class="comment">// 必须设置，否则下次浏览器请求会命中强缓存</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;./script.js&#x27;</span>);</span><br><span class="line">        readStream.pipe(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一次访问资源命中协商缓存之后，浏览器会在下次网络请求中用特殊字段(if-modified-since/if-no-match)携带第一次访问后端时返回的响应头信息，后端在对比前后数据之后，判断资源的内容是否更改，如果更改，就协商失败，返回最新的资源给浏览器，如果没有更改，就协商成功，不返回数据给浏览器，浏览器最终使用缓存的资源</p><h2 id="6-强缓存和协商缓存对比"><a href="#6-强缓存和协商缓存对比" class="headerlink" title="6.强缓存和协商缓存对比"></a>6.强缓存和协商缓存对比</h2><p>6.1 强缓存优先级比协商缓存高，因为浏览器总是倾向于请求更少的资源，命中强缓存后，浏览器都不会向后端请求资源了，所以强缓存优先级比协商缓存高<br>6.2 判断是否命中强缓存的纬度是时间，Expires是固定时间，Cache-Control是相对时间 ;<br>判断是否命中协商缓存的纬度是资源内容是否被更改，Last-Modified是用资源的修改时间，Etag是用资源的hash值</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/17/hello-world/"/>
      <url>2020/11/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
